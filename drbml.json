[
    {
        "id": 1,
        "trimmed_code": "#include <stdio.h>\nint main(int argc, char* argv[])\n{   \n  int i;\n  int len = 1000;\n\n  int a[1000];\n\n  for (i=0; i<len; i++)\n    a[i]= i; \n\n#pragma omp parallel for\n  for (i=0;i< len -1 ;i++)\n    a[i]=a[i+1]+1;\n\n  printf (\"a[500]=%d\\n\", a[500] );\n  return 0;\n} \n",
        "data_race": 1
    },
    {
        "id": 2,
        "trimmed_code": "#include <stdlib.h>\nint main(int argc, char* argv[])\n{   \n  int i;\n  int len = 1000;\n\n  if (argc>1)\n    len = atoi(argv[1]);\n\n  int a[len];\n\n  for (i=0; i<len; i++)\n    a[i]= i; \n\n#pragma omp parallel for\n  for (i=0;i< len -1 ;i++)\n    a[i]=a[i+1]+1;\n\n  return 0;\n} \n",
        "data_race": 1
    },
    {
        "id": 3,
        "trimmed_code": "#include <stdio.h>\n\nint main(int argc,char *argv[])\n{\n  int i, j;\n  int len = 20; \n\n  double a[20][20];\n\n  for (i=0; i< len; i++)\n    for (j=0; j<len; j++)\n      a[i][j] = 0.5; \n\n#pragma omp parallel for private(j)\n  for (i = 0; i < len - 1; i += 1) {\n    for (j = 0; j < len ; j += 1) {\n      a[i][j] += a[i + 1][j];\n    }\n  }\n\n  printf (\"a[10][10]=%f\\n\", a[10][10]);\n  return 0;\n}\n\n",
        "data_race": 1
    },
    {
        "id": 4,
        "trimmed_code": "#include <stdlib.h>\nint main(int argc,char *argv[])\n{\n  int i, j;\n  int len = 20; \n\n  if (argc>1)\n    len = atoi(argv[1]);\n\n  double a[len][len];\n\n  for (i=0; i< len; i++)\n    for (j=0; j<len; j++)\n      a[i][j] = 0.5; \n\n#pragma omp parallel for private(j)\n  for (i = 0; i < len - 1; i += 1) {\n    for (j = 0; j < len ; j += 1) {\n      a[i][j] += a[i + 1][j];\n    }\n  }\n  return 0;\n}\n\n",
        "data_race": 1
    },
    {
        "id": 5,
        "trimmed_code": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#define N 180\nint indexSet[N] = {\n521, 523, 525, 527, 529, 531,\n547, 549, 551, 553, 555, 557,\n573, 575, 577, 579, 581, 583,\n599, 601, 603, 605, 607, 609,\n625, 627, 629, 631, 633, 635,\n\n651, 653, 655, 657, 659, 661,\n859, 861, 863, 865, 867, 869,\n885, 887, 889, 891, 893, 895,\n911, 913, 915, 917, 919, 923, \n937, 939, 941, 943, 945, 947,\n\n963, 965, 967, 969, 971, 973,\n989, 991, 993, 995, 997, 999, \n1197, 1199, 1201, 1203, 1205, 1207,\n1223, 1225, 1227, 1229, 1231, 1233,\n1249, 1251, 1253, 1255, 1257, 1259,\n\n1275, 1277, 1279, 1281, 1283, 1285,\n1301, 1303, 1305, 1307, 1309, 1311,\n1327, 1329, 1331, 1333, 1335, 1337,\n1535, 1537, 1539, 1541, 1543, 1545,\n1561, 1563, 1565, 1567, 1569, 1571,\n\n1587, 1589, 1591, 1593, 1595, 1597,\n1613, 1615, 1617, 1619, 1621, 1623,\n1639, 1641, 1643, 1645, 1647, 1649,\n1665, 1667, 1669, 1671, 1673, 1675,\n1873, 1875, 1877, 1879, 1881, 1883,\n\n1899, 1901, 1903, 1905, 1907, 1909,\n1925, 1927, 1929, 1931, 1933, 1935,\n1951, 1953, 1955, 1957, 1959, 1961,\n1977, 1979, 1981, 1983, 1985, 1987,\n2003, 2005, 2007, 2009, 2011, 2013};\n\nint main (int argc, char* argv[])\n{\n  \n  \n  double * base = (double*) malloc(sizeof(double)* (2013+12+1));\n  if (base == 0)\n  {\n    printf (\"Error in malloc(). Aborting ...\\n\");\n    return 1;  \n  }\n\n  double * xa1 = base;\n  double * xa2 = xa1 + 12;\n  int i;\n\n  \n  for (i =521; i<= 2025; ++i)\n  {\n    base[i]=0.5*i;\n  }\n\n#pragma omp parallel for schedule(static,1)\n  for (i =0; i< N; ++i) \n  {\n    int idx = indexSet[i];\n    xa1[idx]+= 1.0 + i;\n    xa2[idx]+= 3.0 + i;\n  }\n\n  printf(\"x1[999]=%f xa2[1285]=%f\\n\", xa1[999], xa2[1285]);\n  free (base);\n  return  0;\n}\n\n",
        "data_race": 1
    },
    {
        "id": 6,
        "trimmed_code": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#define N 180\nint indexSet[N] = {\n521, 523, 525, 527, 529, 533, \n547, 549, 551, 553, 555, 557,\n573, 575, 577, 579, 581, 583,\n599, 601, 603, 605, 607, 609,\n625, 627, 629, 631, 633, 635,\n\n651, 653, 655, 657, 659, 661,\n859, 861, 863, 865, 867, 869,\n885, 887, 889, 891, 893, 895,\n911, 913, 915, 917, 919, 921, \n937, 939, 941, 943, 945, 947,\n\n963, 965, 967, 969, 971, 973,\n989, 991, 993, 995, 997, 999, \n1197, 1199, 1201, 1203, 1205, 1207,\n1223, 1225, 1227, 1229, 1231, 1233,\n1249, 1251, 1253, 1255, 1257, 1259,\n\n1275, 1277, 1279, 1281, 1283, 1285,\n1301, 1303, 1305, 1307, 1309, 1311,\n1327, 1329, 1331, 1333, 1335, 1337,\n1535, 1537, 1539, 1541, 1543, 1545,\n1561, 1563, 1565, 1567, 1569, 1571,\n\n1587, 1589, 1591, 1593, 1595, 1597,\n1613, 1615, 1617, 1619, 1621, 1623,\n1639, 1641, 1643, 1645, 1647, 1649,\n1665, 1667, 1669, 1671, 1673, 1675,\n1873, 1875, 1877, 1879, 1881, 1883,\n\n1899, 1901, 1903, 1905, 1907, 1909,\n1925, 1927, 1929, 1931, 1933, 1935,\n1951, 1953, 1955, 1957, 1959, 1961,\n1977, 1979, 1981, 1983, 1985, 1987,\n2003, 2005, 2007, 2009, 2011, 2013};\n\nint main (int argc, char* argv[])\n{\n  double * base = (double*) malloc(sizeof(double)* (2013+12+1));\n\n  if (base == 0)\n  {\n    printf (\"Error in malloc(). Aborting ...\\n\");\n    return 1;  \n  }\n  double * xa1 = base;\n  double * xa2 = xa1 + 12;\n  int i;\n\n  \n  for (i =521; i<= 2025; ++i)\n  {\n    base[i]=0.5*i;\n  }\n\n#pragma omp parallel for \n  for (i =0; i< N; ++i) \n  {\n    int idx = indexSet[i];\n    xa1[idx]+= 1.0;\n    xa2[idx]+= 3.0;\n  }\n  printf(\"x1[999]=%f xa2[1285]=%f\\n\", xa1[999], xa2[1285]);\n  free (base);\n  return  0;\n}\n\n",
        "data_race": 1
    },
    {
        "id": 7,
        "trimmed_code": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#define N 180\nint indexSet[N] = {\n521, 523, 525, 533, 529, 531, \n547, 549, 551, 553, 555, 557,\n573, 575, 577, 579, 581, 583,\n599, 601, 603, 605, 607, 609,\n625, 627, 629, 631, 633, 635,\n\n651, 653, 655, 657, 659, 661,\n859, 861, 863, 865, 867, 869,\n885, 887, 889, 891, 893, 895,\n911, 913, 915, 917, 919, 921, \n937, 939, 941, 943, 945, 947,\n\n963, 965, 967, 969, 971, 973,\n989, 991, 993, 995, 997, 999, \n1197, 1199, 1201, 1203, 1205, 1207,\n1223, 1225, 1227, 1229, 1231, 1233,\n1249, 1251, 1253, 1255, 1257, 1259,\n\n1275, 1277, 1279, 1281, 1283, 1285,\n1301, 1303, 1305, 1307, 1309, 1311,\n1327, 1329, 1331, 1333, 1335, 1337,\n1535, 1537, 1539, 1541, 1543, 1545,\n1561, 1563, 1565, 1567, 1569, 1571,\n\n1587, 1589, 1591, 1593, 1595, 1597,\n1613, 1615, 1617, 1619, 1621, 1623,\n1639, 1641, 1643, 1645, 1647, 1649,\n1665, 1667, 1669, 1671, 1673, 1675,\n1873, 1875, 1877, 1879, 1881, 1883,\n\n1899, 1901, 1903, 1905, 1907, 1909,\n1925, 1927, 1929, 1931, 1933, 1935,\n1951, 1953, 1955, 1957, 1959, 1961,\n1977, 1979, 1981, 1983, 1985, 1987,\n2003, 2005, 2007, 2009, 2011, 2013};\n\nint main (int argc, char* argv[])\n{\n  double * base = (double*) malloc(sizeof(double)* (2013+12+1));\n  if (base == 0)\n  {\n    printf (\"Error in malloc(). Aborting ...\\n\");\n    return 1;  \n  }\n\n  double * xa1 = base;\n  double * xa2 = xa1 + 12;\n  int i;\n\n  \n  for (i =521; i<= 2025; ++i)\n  {\n    base[i]=0.5*i;\n  }\n\n#pragma omp parallel for \n  for (i =0; i< N; ++i) \n  {\n    int idx = indexSet[i];\n    xa1[idx]+= 1.0;\n    xa2[idx]+= 3.0;\n  }\n  printf(\"x1[999]=%f xa2[1285]=%f\\n\", xa1[999], xa2[1285]);\n  free (base);\n  return  0;\n}\n\n",
        "data_race": 1
    },
    {
        "id": 8,
        "trimmed_code": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#define N 180\nint indexSet[N] = {\n521, 533, 525, 527, 529, 531, \n547, 549, 551, 553, 555, 557,\n573, 575, 577, 579, 581, 583,\n599, 601, 603, 605, 607, 609,\n625, 627, 629, 631, 633, 635,\n\n651, 653, 655, 657, 659, 661,\n859, 861, 863, 865, 867, 869,\n885, 887, 889, 891, 893, 895,\n911, 913, 915, 917, 919, 921, \n937, 939, 941, 943, 945, 947,\n\n963, 965, 967, 969, 971, 973,\n989, 991, 993, 995, 997, 999, \n1197, 1199, 1201, 1203, 1205, 1207,\n1223, 1225, 1227, 1229, 1231, 1233,\n1249, 1251, 1253, 1255, 1257, 1259,\n\n1275, 1277, 1279, 1281, 1283, 1285,\n1301, 1303, 1305, 1307, 1309, 1311,\n1327, 1329, 1331, 1333, 1335, 1337,\n1535, 1537, 1539, 1541, 1543, 1545,\n1561, 1563, 1565, 1567, 1569, 1571,\n\n1587, 1589, 1591, 1593, 1595, 1597,\n1613, 1615, 1617, 1619, 1621, 1623,\n1639, 1641, 1643, 1645, 1647, 1649,\n1665, 1667, 1669, 1671, 1673, 1675,\n1873, 1875, 1877, 1879, 1881, 1883,\n\n1899, 1901, 1903, 1905, 1907, 1909,\n1925, 1927, 1929, 1931, 1933, 1935,\n1951, 1953, 1955, 1957, 1959, 1961,\n1977, 1979, 1981, 1983, 1985, 1987,\n2003, 2005, 2007, 2009, 2011, 2013};\n\nint main (int argc, char* argv[])\n{\n  double * base = (double*) malloc(sizeof(double)* (2013+12+1));\n  if (base == 0)\n  {\n    printf (\"Error in malloc(). Aborting ...\\n\");\n    return 1;  \n  }\n  double * xa1 = base;\n  double * xa2 = xa1 + 12;\n  int i;\n\n  \n  for (i =521; i<= 2025; ++i)\n  {\n    base[i]=0.5*i;\n  }\n\n#pragma omp parallel for \n  for (i =0; i< N; ++i) \n  {\n    int idx = indexSet[i];\n    xa1[idx]+= 1.0;\n    xa2[idx]+= 3.0;\n  }\n  printf(\"x1[999]=%f xa2[1285]=%f\\n\", xa1[999], xa2[1285]);\n  free (base);\n  return  0;\n}\n\n",
        "data_race": 1
    },
    {
        "id": 9,
        "trimmed_code": "#include <stdio.h>\nint main(int argc, char* argv[])\n{\n  int i,x;\n  int len = 10000;\n\n#pragma omp parallel for private (i) \n  for (i=0;i<len;i++)\n    x=i;\n\n  printf(\"x=%d\",x);\n  return 0;\n}\n\n",
        "data_race": 1
    },
    {
        "id": 10,
        "trimmed_code": "#include <stdio.h>\n#include <stdlib.h>\nint main(int argc, char* argv[])\n{\n  int i,x;\n  int len = 10000;\n  if (argc>1)\n    len = atoi(argv[1]);\n\n#pragma omp parallel for private (i) \n  for (i=0;i<len;i++)\n    x=i;\n  printf(\"x=%d\",x);\n  return 0;\n}\n\n",
        "data_race": 1
    },
    {
        "id": 11,
        "trimmed_code": "#include <stdlib.h>  \n#include <stdio.h>\nint main(int argc, char* argv[])  \n{\n  int i;\n  int len=100;\n\n  int numNodes=len, numNodes2=0; \n  int x[100]; \n\n  \n  for (i=0; i< len; i++)\n  {\n    if (i%2==0)\n      x[i]=5;\n    else\n      x[i]= -5;\n  }\n\n#pragma omp parallel for\n  for (i=numNodes-1 ; i>-1 ; --i) {\n    if (x[i]<=0) {\n      numNodes2-- ;\n    }\n  }\n  printf (\"numNodes2 = %d\\n\", numNodes2);\n  return 0;\n} \n",
        "data_race": 1
    },
    {
        "id": 12,
        "trimmed_code": "#include <stdlib.h>  \nint main(int argc, char* argv[])  \n{\n  int i;\n  int len=100;\n\n  if (argc>1)\n    len = atoi(argv[1]);\n\n  int numNodes=len, numNodes2=0; \n  int x[len]; \n\n  for (i=0; i< len; i++)\n  {\n    if (i%2==0)\n      x[i]=5;\n    else\n      x[i]= -5;\n  }\n\n#pragma omp parallel for\n  for (i=numNodes-1 ; i>-1 ; --i) {\n    if (x[i]<=0) {\n      numNodes2-- ;\n    }\n  }         \n  return 0;\n} \n",
        "data_race": 1
    },
    {
        "id": 13,
        "trimmed_code": "#include <stdio.h>\nint main()\n{\n  int i,error;\n  int len = 1000;\n  int a[len], b=5;\n\n  for (i=0; i<len; i++)\n    a[i]= i;\n \n#pragma omp parallel shared(b, error) \n  {\n#pragma omp for nowait\n    for(i = 0; i < len; i++)\n      a[i] = b + a[i]*5;\n\n#pragma omp single\n    error = a[9] + 1;\n  }\n\n  printf (\"error = %d\\n\", error);\n  return 0;\n}  \n",
        "data_race": 1
    },
    {
        "id": 14,
        "trimmed_code": "#include <stdio.h>\nint main(int argc, char* argv[]) \n{\n  int i,j;\n  int n=100, m=100;\n  double b[n][m];\n#pragma omp parallel for private(j)\n  for (i=1;i<n;i++)\n    for (j=0;j<m;j++) \n      b[i][j]=b[i][j-1];\n\n  printf (\"b[50][50]=%f\\n\",b[50][50]);\n\n  return 0;     \n}\n  \n",
        "data_race": 1
    },
    {
        "id": 15,
        "trimmed_code": "#include <stdlib.h>\nint main(int argc, char* argv[]) \n{\n  int i,j;\n  int len=100;\n  if (argc>1)\n    len = atoi(argv[1]);\n\n  int n=len, m=len;\n  double b[n][m];\n#pragma omp parallel for private(j)\n  for (i=1;i<n;i++)\n    for (j=0;j<m;j++) \n      b[i][j]=b[i][j-1];\n\n return 0;     \n}\n  \n",
        "data_race": 1
    },
    {
        "id": 16,
        "trimmed_code": "#include <stdio.h>\nint a[100];\n\nint main()\n{\n  int len=100; \n  int i,x=10;\n\n#pragma omp parallel for \n  for (i=0;i<len;i++)\n  {\n    a[i] = x;\n    x=i;\n  }\n  printf(\"x=%d\",x);    \n  return 0;\n} \n\n",
        "data_race": 1
    },
    {
        "id": 17,
        "trimmed_code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char* argv[])\n{\n  int len=100; \n\n  if (argc>1)\n    len = atoi(argv[1]);\n\n  int a[len];\n  int i,x=10;\n\n#pragma omp parallel for \n  for (i=0;i<len;i++)\n  {\n    a[i] = x;\n    x=i;\n  }\n  printf(\"x=%d, a[0]=%d\\n\",x,a[0]);    \n  return 0;\n} \n\n",
        "data_race": 1
    },
    {
        "id": 18,
        "trimmed_code": "#include <stdlib.h>\n#include <stdio.h>\nint input[1000]; \nint output[1000];\n\nint main()\n{\n  int i ;\n  int inLen=1000 ; \n  int outLen = 0;\n\n  for (i=0; i<inLen; ++i) \n    input[i]= i;  \n\n#pragma omp parallel for\n  for (i=0; i<inLen; ++i) \n  {\n    output[outLen++] = input[i] ;\n  }  \n\n  printf(\"output[500]=%d\\n\",output[500]);\n\n  return 0;\n}\n",
        "data_race": 1
    },
    {
        "id": 19,
        "trimmed_code": "#include <stdlib.h>\n#include <stdio.h>\nint main(int argc, char* argv[])\n{\n  int i ;\n  int inLen=1000 ; \n  int outLen = 0;\n\n  if (argc>1)\n    inLen= atoi(argv[1]);\n\n  int input[inLen]; \n  int output[inLen];\n  for (i=0; i<inLen; ++i) \n    input[i]=i; \n\n#pragma omp parallel for\n  for (i=0; i<inLen; ++i) {\n    output[outLen++] = input[i] ;\n  }  \n\n  printf(\"output[0]=%d\\n\", output[0]);\n  return 0;\n}\n",
        "data_race": 1
    },
    {
        "id": 20,
        "trimmed_code": "#include <stdlib.h>\nint main(int argc, char* argv[])\n{\n  int i;\n  int tmp;\n  int len=100;\n  if (argc>1)\n    len = atoi(argv[1]);\n  int a[len];\n  for (i=0;i<len;i++)\n    a[i]=i;\n\n#pragma omp parallel for\n  for (i=0;i<len;i++)\n  {\n    tmp =a[i]+i;\n    a[i] = tmp;\n  }\n  return 0;\n}\n",
        "data_race": 1
    },
    {
        "id": 21,
        "trimmed_code": "#include <stdio.h>\nint main(int argc, char* argv[])\n{\n  int i,j;\n  float temp, sum=0.0;\n  int len=100;\n\n  float u[100][100];\n  for (i = 0; i < len; i++)\n    for (j = 0; j < len; j++)\n        u[i][j] = 0.5; \n\n#pragma omp parallel for private (temp,i,j)\n  for (i = 0; i < len; i++)\n    for (j = 0; j < len; j++)\n    {\n      temp = u[i][j];\n      sum = sum + temp * temp;\n    }\n\n  printf (\"sum = %f\\n\", sum);  \n  return 0;\n}\n",
        "data_race": 1
    },
    {
        "id": 22,
        "trimmed_code": "#include <stdio.h>\n#include <stdlib.h>\nint main(int argc, char* argv[])\n{\n  int i,j;\n  float temp, sum=0.0;\n  int len=100;\n  if (argc>1)\n    len = atoi(argv[1]);\n  float u[len][len];\n  for (i = 0; i < len; i++)\n    for (j = 0; j < len; j++)\n        u[i][j] = 0.5;\n\n#pragma omp parallel for private (temp,i,j)\n  for (i = 0; i < len; i++)\n    for (j = 0; j < len; j++)\n    {\n      temp = u[i][j];\n      sum = sum + temp * temp;\n    }\n  printf (\"sum = %f\\n\", sum); \n  return 0;\n}\n",
        "data_race": 1
    },
    {
        "id": 23,
        "trimmed_code": "#include <stdio.h> \nint main()\n{\n  int i=0;\n#pragma omp parallel sections\n  {\n#pragma omp section\n    i = 1;    \n#pragma omp section\n    i = 2;    \n  }\n  printf(\"i=%d\\n\",i);\n  return 0;\n} \n",
        "data_race": 1
    },
    {
        "id": 24,
        "trimmed_code": "#include <stdio.h>\nint main(int argc, char* argv[])\n{\n  int i;\n  int len=100;\n  int a[100], b[100];\n\n  for (i=0;i<len;i++)\n  {\n    a[i]=i;\n    b[i]=i+1;\n  }\n\n#pragma omp simd \n  for (i=0;i<len-1;i++)\n    a[i+1]=a[i]+b[i];\n\n  for (i=0;i<len;i++)\n    printf(\"i=%d a[%d]=%d\\n\",i,i,a[i]);\n  return 0;\n}\n",
        "data_race": 1
    },
    {
        "id": 25,
        "trimmed_code": "#include <stdlib.h>\nint main(int argc, char* argv[])\n{\n  int i;\n  int len=100;\n\n  if (argc>1)\n    len = atoi(argv[1]);\n\n  int a[len], b[len];\n  for (i=0;i<len;i++)\n  {\n    a[i]=i;\n    b[i]=i+1;\n  }\n#pragma omp simd\n  for (i=0;i<len-1;i++)\n    a[i+1]=a[i]*b[i];\n  return 0;\n}\n",
        "data_race": 1
    },
    {
        "id": 26,
        "trimmed_code": "int main(int argc, char* argv[])\n{\n  int i;\n  int len = 1000;\n  int a[1000];\n\n  for (i=0; i<len; i++)\n    a[i]= i;\n\n#pragma omp target map(a[0:len])\n#pragma omp parallel for\n  for (i=0;i< len -1 ;i++)\n    a[i]=a[i+1]+1;\n\n  return 0;\n}\n",
        "data_race": 1
    },
    {
        "id": 27,
        "trimmed_code": "#include <assert.h> \n#include <stdio.h> \nint main()\n{\n  int i=0;\n#pragma omp parallel\n#pragma omp single\n  {\n#pragma omp task\n    i = 1;    \n#pragma omp task\n    i = 2;    \n  }\n\n  printf (\"i=%d\\n\",i);\n  return 0;\n} \n",
        "data_race": 1
    },
    {
        "id": 28,
        "trimmed_code": "#include <stdlib.h>\n#include <stdio.h>\nint main(int argc, char* argv[])\n{\n  int i;\n  int tmp;\n  int len=100;\n  int a[100];\n  for (i=0;i<len;i++)\n    a[i]=i;\n\n#pragma omp parallel for\n  for (i=0;i<len;i++)\n  {\n    tmp =a[i]+i;\n    a[i] = tmp;\n  }\n\n  printf(\"a[50]=%d\\n\", a[50]);\n  return 0;\n}\n",
        "data_race": 1
    },
    {
        "id": 29,
        "trimmed_code": "#include <stdlib.h>\n#include <stdio.h>\nint main(int argc, char* argv[])\n{\n  int i;\n  int len=100;\n  int a[100];\n\n  for (i=0;i<len;i++)\n    a[i]=i;\n\n#pragma omp parallel for\n  for (i=0;i<len-1;i++)\n    a[i+1]=a[i]+1;\n\n  printf(\"a[50]=%d\\n\", a[50]);   \n  return 0;\n}\n",
        "data_race": 1
    },
    {
        "id": 30,
        "trimmed_code": "#include <stdlib.h>\n#include <stdio.h>\n\nint main(int argc, char* argv[])\n{\n  int i;\n  int len=100;\n\n  if (argc>1)\n    len = atoi(argv[1]);\n\n  int a[len];\n  for (i=0;i<len;i++)\n    a[i]=i;\n\n#pragma omp parallel for\n  for (i=0;i<len-1;i++)\n    a[i+1]=a[i]+1;\n\n  return 0;\n}\n",
        "data_race": 1
    },
    {
        "id": 31,
        "trimmed_code": "#include <stdlib.h>\n#include <stdio.h>\nint main(int argc, char* argv[])\n{\n  int i,j;\n  int n=1000, m=1000;\n  double b[1000][1000];\n\n  for (i=0; i<n; i++)\n    for (j=0; j<m; j++)\n      b[i][j] = 0.5; \n\n#pragma omp parallel for private(j)\n  for (i=1;i<n;i++)\n    for (j=1;j<m;j++)\n      b[i][j]=b[i-1][j-1];\n\n  printf(\"b[500][500]=%f\\n\", b[500][500]);  \n  return 0;\n}\n",
        "data_race": 1
    },
    {
        "id": 32,
        "trimmed_code": "#include <stdlib.h>\nint main(int argc, char* argv[])\n{\n  int i,j;\n  int len = 1000;\n  if (argc>1)\n    len = atoi(argv[1]);\n\n  int n=len, m=len;\n  double b[len][len];\n\n  for (i=0; i<n; i++)\n    for (j=0; j<m; j++)\n      b[i][j] = 0.5; \n\n#pragma omp parallel for private(j)\n  for (i=1;i<n;i++)\n    for (j=1;j<m;j++)\n      b[i][j]=b[i-1][j-1];\n\n  return 0;\n}\n",
        "data_race": 1
    },
    {
        "id": 33,
        "trimmed_code": "#include <stdlib.h>\n#include <stdio.h>\nint main(int argc, char* argv[])\n{\n  int i;\n\n  int a[2000];\n\n  for (i=0; i<2000; i++)\n    a[i]=i; \n\n#pragma omp parallel for\n  for (i=0;i<1000;i++)\n    a[2*i+1]=a[i]+1;\n\n  printf(\"a[1001]=%d\\n\", a[1001]);  \n  return 0;\n}\n\n",
        "data_race": 1
    },
    {
        "id": 34,
        "trimmed_code": "#include <stdlib.h>\nint main(int argc, char* argv[])\n{\n  int i;\n  int len=2000;\n\n  if (argc>1)\n    len = atoi(argv[1]);\n  int a[len];\n\n  for (i=0; i<len; i++)\n    a[i]=i; \n\n#pragma omp parallel for\n  for (i=0;i<len/2;i++)\n    a[2*i+1]=a[i]+1;\n\n  return 0;\n}\n\n",
        "data_race": 1
    },
    {
        "id": 35,
        "trimmed_code": "#include <stdlib.h>\n#include <stdio.h>\n\nint main(int argc, char* argv[])\n{ \n  int i; \n  int tmp;\n  tmp = 10;\n  int len=100;\n\n  int a[100];\n\n#pragma omp parallel for\n  for (i=0;i<len;i++)\n  { \n    a[i] = tmp;\n    tmp =a[i]+i;\n  }\n\n  printf(\"a[50]=%d\\n\", a[50]);\n  return 0;      \n}\n\n",
        "data_race": 1
    },
    {
        "id": 36,
        "trimmed_code": "#include <stdlib.h>\nint main(int argc, char* argv[])\n{ \n  int i; \n  int tmp;\n  tmp = 10;\n  int len=100;\n\n  if (argc>1)\n    len = atoi(argv[1]);\n\n  int a[len];\n#pragma omp parallel for\n  for (i=0;i<len;i++)\n  { \n    a[i] = tmp;\n    tmp =a[i]+i;\n  }     \n  return 0;      \n}\n\n",
        "data_race": 1
    },
    {
        "id": 37,
        "trimmed_code": "#include <stdlib.h>\n#include <stdio.h>\ndouble b[1000][1000];\n\nint main(int argc, char* argv[]) \n{\n  int i,j;\n  int n=1000, m=1000;\n  for (i=0;i<n;i++)\n#pragma omp parallel for\n    for (j=1;j<m;j++)\n      b[i][j]=b[i][j-1];\n\n  printf(\"b[500][500]=%f\\n\", b[500][500]);\n  return 0;\n}\n\n",
        "data_race": 1
    },
    {
        "id": 38,
        "trimmed_code": "#include <stdlib.h>\nint main(int argc, char* argv[]) \n{\n  int i,j;\n  int len = 1000;\n  if (argc>1)\n    len = atoi(argv[1]);\n\n  int n=len, m=len;\n  double b[n][m];\n\n  for (i=0;i<n;i++)\n#pragma omp parallel for\n    for (j=1;j<m;j++)\n      b[i][j]=b[i][j-1];\n\n  return 0;\n}\n\n",
        "data_race": 1
    },
    {
        "id": 39,
        "trimmed_code": "#include <stdlib.h>\n#include <stdio.h>\nint main (int argc, char* argv[])\n{\n  int len=1000;\n  int i; \n\n  int a[1000];\n  a[0] = 2;\n\n#pragma omp parallel for\n  for (i=0;i<len;i++)\n    a[i]=a[i]+a[0];\n\n  printf(\"a[500]=%d\\n\", a[500]);\n  return 0;\n}\n",
        "data_race": 1
    },
    {
        "id": 40,
        "trimmed_code": "#include <stdlib.h>\nint main (int argc, char* argv[])\n{\n  int len=1000;\n  int i; \n\n  if (argc>1)\n    len = atoi(argv[1]);\n  int a[len];\n  a[0] = 2;\n\n#pragma omp parallel for\n  for (i=0;i<len;i++)\n    a[i]=a[i]+a[0];\n\n  return 0;\n}\n",
        "data_race": 1
    },
    {
        "id": 41,
        "trimmed_code": "#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <math.h>\n\n#include \"polybench/polybench.h\"\n\n\n#include \"polybench/adi.h\"\n\n\nstatic void init_array(int n,double X[500 + 0][500 + 0],double A[500 + 0][500 + 0],double B[500 + 0][500 + 0])\n{\n  \n  \n{\n    int c1;\n    int c2;\n    if (n >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = 0; c1 <= n + -1; c1++) {\n        for (c2 = 0; c2 <= n + -1; c2++) {\n          X[c1][c2] = (((double )c1) * (c2 + 1) + 1) / n;\n          A[c1][c2] = (((double )c1) * (c2 + 2) + 2) / n;\n          B[c1][c2] = (((double )c1) * (c2 + 3) + 3) / n;\n        }\n      }\n    }\n  }\n}\n\n\nstatic void print_array(int n,double X[500 + 0][500 + 0])\n{\n  int i;\n  int j;\n  for (i = 0; i < n; i++) \n    for (j = 0; j < n; j++) {\n      fprintf(stderr,\"%0.2lf \",X[i][j]);\n      if ((i * 500 + j) % 20 == 0) \n        fprintf(stderr,\"\\n\");\n    }\n  fprintf(stderr,\"\\n\");\n}\n\n\nstatic void kernel_adi(int tsteps,int n,double X[500 + 0][500 + 0],double A[500 + 0][500 + 0],double B[500 + 0][500 + 0])\n{\n  \n  \n  \n  \n  \n{\n    int c0;\n    int c2;\n    int c8;\n    for (c0 = 0; c0 <= 9; c0++) {\n#pragma omp parallel for private(c8)\n      for (c2 = 0; c2 <= 499; c2++) {\n        for (c8 = 1; c8 <= 499; c8++) {\n          B[c2][c8] = B[c2][c8] - A[c2][c8] * A[c2][c8] / B[c2][c8 - 1];\n        }\n        for (c8 = 1; c8 <= 499; c8++) {\n          X[c2][c8] = X[c2][c8] - X[c2][c8 - 1] * A[c2][c8] / B[c2][c8 - 1];\n        }\n        for (c8 = 0; c8 <= 497; c8++) {\n          X[c2][500 - c8 - 2] = (X[c2][500 - 2 - c8] - X[c2][500 - 2 - c8 - 1] * A[c2][500 - c8 - 3]) / B[c2][500 - 3 - c8];\n        }\n      }\n#pragma omp parallel for\n      for (c2 = 0; c2 <= 499; c2++) {\n        X[c2][500 - 1] = X[c2][500 - 1] / B[c2][500 - 1];\n      }\n#pragma omp parallel for private(c8)\n      for (c2 = 0; c2 <= 499; c2++) {\n        for (c8 = 1; c8 <= 499; c8++) {\n          B[c8][c2] = B[c8][c2] - A[c8][c2] * A[c8][c2] / B[c8 - 1][c2];\n        }\n        for (c8 = 1; c8 <= 499; c8++) {\n          X[c8][c2] = X[c8][c2] - X[c8 - 1][c2] * A[c8][c2] / B[c8 - 1][c2];\n        }\n        for (c8 = 0; c8 <= 497; c8++) {\n          X[500 - 2 - c8][c2] = (X[500 - 2 - c8][c2] - X[500 - c8 - 3][c2] * A[500 - 3 - c8][c2]) / B[500 - 2 - c8][c2];\n        }\n      }\n#pragma omp parallel for\n      for (c2 = 0; c2 <= 499; c2++) {\n        X[500 - 1][c2] = X[500 - 1][c2] / B[500 - 1][c2];\n      }\n    }\n  }\n  \n\n}\n\nint main(int argc,char **argv)\n{\n\n  int n = 500;\n  int tsteps = 10;\n\n  double (*X)[500 + 0][500 + 0];\n  X = ((double (*)[500 + 0][500 + 0])(polybench_alloc_data(((500 + 0) * (500 + 0)),(sizeof(double )))));\n  ;\n  double (*A)[500 + 0][500 + 0];\n  A = ((double (*)[500 + 0][500 + 0])(polybench_alloc_data(((500 + 0) * (500 + 0)),(sizeof(double )))));\n  ;\n  double (*B)[500 + 0][500 + 0];\n  B = ((double (*)[500 + 0][500 + 0])(polybench_alloc_data(((500 + 0) * (500 + 0)),(sizeof(double )))));\n  ;\n\n  init_array(n, *X, *A, *B);\n\n  polybench_timer_start();\n  ;\n\n  kernel_adi(tsteps,n, *X, *A, *B);\n\n  polybench_timer_stop();\n  ;\n  polybench_timer_print();\n  ;\n\n  if (argc > 42 && !strcmp(argv[0],\"\")) \n    print_array(n, *X);\n\n  free(((void *)X));\n  ;\n  free(((void *)A));\n  ;\n  free(((void *)B));\n  ;\n  return 0;\n}\n",
        "data_race": 0
    },
    {
        "id": 42,
        "trimmed_code": "#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <math.h>\n\n#include \"polybench/polybench.h\"\n\n\n#include \"polybench/adi.h\"\n\n\nstatic void init_array(int n,double X[500 + 0][500 + 0],double A[500 + 0][500 + 0],double B[500 + 0][500 + 0])\n{\n  \n  \n{\n    int c1;\n    int c3;\n    int c2;\n    int c4;\n    if (n >= 1) {\n#pragma omp parallel for private(c4, c2, c3)\n      for (c1 = 0; c1 <= (((n + -1) * 16 < 0?((16 < 0?-((-(n + -1) + 16 + 1) / 16) : -((-(n + -1) + 16 - 1) / 16))) : (n + -1) / 16)); c1++) {\n        for (c2 = 0; c2 <= (((n + -1) * 16 < 0?((16 < 0?-((-(n + -1) + 16 + 1) / 16) : -((-(n + -1) + 16 - 1) / 16))) : (n + -1) / 16)); c2++) {\n          for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < n + -1?16 * c1 + 15 : n + -1)); c3++) {\n#pragma omp simd\n            for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < n + -1?16 * c2 + 15 : n + -1)); c4++) {\n              X[c3][c4] = (((double )c3) * (c4 + 1) + 1) / n;\n              A[c3][c4] = (((double )c3) * (c4 + 2) + 2) / n;\n              B[c3][c4] = (((double )c3) * (c4 + 3) + 3) / n;\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\n\nstatic void print_array(int n,double X[500 + 0][500 + 0])\n{\n  int i;\n  int j;\n  for (i = 0; i < n; i++) \n    for (j = 0; j < n; j++) {\n      fprintf(stderr,\"%0.2lf \",X[i][j]);\n      if ((i * 500 + j) % 20 == 0) \n        fprintf(stderr,\"\\n\");\n    }\n  fprintf(stderr,\"\\n\");\n}\n\n\nstatic void kernel_adi(int tsteps,int n,double X[500 + 0][500 + 0],double A[500 + 0][500 + 0],double B[500 + 0][500 + 0])\n{\n  \n  \n  \n  \n  \n{\n    int c0;\n    int c2;\n    int c8;\n    int c9;\n    int c15;\n    if (n >= 1 && tsteps >= 1) {\n      for (c0 = 0; c0 <= tsteps + -1; c0++) {\n        if (n >= 2) {\n#pragma omp parallel for private(c15, c9, c8)\n          for (c2 = 0; c2 <= (((n + -1) * 16 < 0?((16 < 0?-((-(n + -1) + 16 + 1) / 16) : -((-(n + -1) + 16 - 1) / 16))) : (n + -1) / 16)); c2++) {\n            for (c8 = 0; c8 <= (((n + -1) * 16 < 0?((16 < 0?-((-(n + -1) + 16 + 1) / 16) : -((-(n + -1) + 16 - 1) / 16))) : (n + -1) / 16)); c8++) {\n              for (c9 = (1 > 16 * c8?1 : 16 * c8); c9 <= ((16 * c8 + 15 < n + -1?16 * c8 + 15 : n + -1)); c9++) {\n#pragma omp simd\n                for (c15 = 16 * c2; c15 <= ((16 * c2 + 15 < n + -1?16 * c2 + 15 : n + -1)); c15++) {\n                  B[c15][c9] = B[c15][c9] - A[c15][c9] * A[c15][c9] / B[c15][c9 - 1];\n                }\n              }\n            }\n            for (c8 = 0; c8 <= (((n + -1) * 16 < 0?((16 < 0?-((-(n + -1) + 16 + 1) / 16) : -((-(n + -1) + 16 - 1) / 16))) : (n + -1) / 16)); c8++) {\n              for (c9 = (1 > 16 * c8?1 : 16 * c8); c9 <= ((16 * c8 + 15 < n + -1?16 * c8 + 15 : n + -1)); c9++) {\n#pragma omp simd\n                for (c15 = 16 * c2; c15 <= ((16 * c2 + 15 < n + -1?16 * c2 + 15 : n + -1)); c15++) {\n                  X[c15][c9] = X[c15][c9] - X[c15][c9 - 1] * A[c15][c9] / B[c15][c9 - 1];\n                }\n              }\n            }\n            for (c8 = 0; c8 <= (((n + -3) * 16 < 0?((16 < 0?-((-(n + -3) + 16 + 1) / 16) : -((-(n + -3) + 16 - 1) / 16))) : (n + -3) / 16)); c8++) {\n              for (c9 = 16 * c8; c9 <= ((16 * c8 + 15 < n + -3?16 * c8 + 15 : n + -3)); c9++) {\n#pragma omp simd\n                for (c15 = 16 * c2; c15 <= ((16 * c2 + 15 < n + -1?16 * c2 + 15 : n + -1)); c15++) {\n                  X[c15][n - c9 - 2] = (X[c15][n - 2 - c9] - X[c15][n - 2 - c9 - 1] * A[c15][n - c9 - 3]) / B[c15][n - 3 - c9];\n                }\n              }\n            }\n          }\n        }\n#pragma omp parallel for private(c15)\n        for (c2 = 0; c2 <= (((n + -1) * 16 < 0?((16 < 0?-((-(n + -1) + 16 + 1) / 16) : -((-(n + -1) + 16 - 1) / 16))) : (n + -1) / 16)); c2++) {\n#pragma omp simd\n          for (c15 = 16 * c2; c15 <= ((16 * c2 + 15 < n + -1?16 * c2 + 15 : n + -1)); c15++) {\n            X[c15][n - 1] = X[c15][n - 1] / B[c15][n - 1];\n          }\n        }\n        if (n >= 2) {\n#pragma omp parallel for private(c15, c9, c8)\n          for (c2 = 0; c2 <= (((n + -1) * 16 < 0?((16 < 0?-((-(n + -1) + 16 + 1) / 16) : -((-(n + -1) + 16 - 1) / 16))) : (n + -1) / 16)); c2++) {\n            for (c8 = 0; c8 <= (((n + -1) * 16 < 0?((16 < 0?-((-(n + -1) + 16 + 1) / 16) : -((-(n + -1) + 16 - 1) / 16))) : (n + -1) / 16)); c8++) {\n              for (c9 = (1 > 16 * c8?1 : 16 * c8); c9 <= ((16 * c8 + 15 < n + -1?16 * c8 + 15 : n + -1)); c9++) {\n#pragma omp simd\n                for (c15 = 16 * c2; c15 <= ((16 * c2 + 15 < n + -1?16 * c2 + 15 : n + -1)); c15++) {\n                  B[c9][c15] = B[c9][c15] - A[c9][c15] * A[c9][c15] / B[c9 - 1][c15];\n                }\n              }\n            }\n            for (c8 = 0; c8 <= (((n + -1) * 16 < 0?((16 < 0?-((-(n + -1) + 16 + 1) / 16) : -((-(n + -1) + 16 - 1) / 16))) : (n + -1) / 16)); c8++) {\n              for (c9 = (1 > 16 * c8?1 : 16 * c8); c9 <= ((16 * c8 + 15 < n + -1?16 * c8 + 15 : n + -1)); c9++) {\n#pragma omp simd\n                for (c15 = 16 * c2; c15 <= ((16 * c2 + 15 < n + -1?16 * c2 + 15 : n + -1)); c15++) {\n                  X[c9][c15] = X[c9][c15] - X[c9 - 1][c15] * A[c9][c15] / B[c9 - 1][c15];\n                }\n              }\n            }\n            for (c8 = 0; c8 <= (((n + -3) * 16 < 0?((16 < 0?-((-(n + -3) + 16 + 1) / 16) : -((-(n + -3) + 16 - 1) / 16))) : (n + -3) / 16)); c8++) {\n              for (c9 = 16 * c8; c9 <= ((16 * c8 + 15 < n + -3?16 * c8 + 15 : n + -3)); c9++) {\n#pragma omp simd\n                for (c15 = 16 * c2; c15 <= ((16 * c2 + 15 < n + -1?16 * c2 + 15 : n + -1)); c15++) {\n                  X[n - 2 - c9][c15] = (X[n - 2 - c9][c15] - X[n - c9 - 3][c15] * A[n - 3 - c9][c15]) / B[n - 2 - c9][c15];\n                }\n              }\n            }\n          }\n        }\n#pragma omp parallel for private(c15)\n        for (c2 = 0; c2 <= (((n + -1) * 16 < 0?((16 < 0?-((-(n + -1) + 16 + 1) / 16) : -((-(n + -1) + 16 - 1) / 16))) : (n + -1) / 16)); c2++) {\n#pragma omp simd\n          for (c15 = 16 * c2; c15 <= ((16 * c2 + 15 < n + -1?16 * c2 + 15 : n + -1)); c15++) {\n            X[n - 1][c15] = X[n - 1][c15] / B[n - 1][c15];\n          }\n        }\n      }\n    }\n  }\n  \n\n}\n\nint main(int argc,char **argv)\n{\n\n  int n = 500;\n  int tsteps = 10;\n\n  double (*X)[500 + 0][500 + 0];\n  X = ((double (*)[500 + 0][500 + 0])(polybench_alloc_data(((500 + 0) * (500 + 0)),(sizeof(double )))));\n  ;\n  double (*A)[500 + 0][500 + 0];\n  A = ((double (*)[500 + 0][500 + 0])(polybench_alloc_data(((500 + 0) * (500 + 0)),(sizeof(double )))));\n  ;\n  double (*B)[500 + 0][500 + 0];\n  B = ((double (*)[500 + 0][500 + 0])(polybench_alloc_data(((500 + 0) * (500 + 0)),(sizeof(double )))));\n  ;\n\n  init_array(n, *X, *A, *B);\n\n  polybench_timer_start();\n  ;\n\n  kernel_adi(tsteps,n, *X, *A, *B);\n\n  polybench_timer_stop();\n  ;\n  polybench_timer_print();\n  ;\n\n  if (argc > 42 && !strcmp(argv[0],\"\")) \n    print_array(n, *X);\n\n  free(((void *)X));\n  ;\n  free(((void *)A));\n  ;\n  free(((void *)B));\n  ;\n  return 0;\n}\n",
        "data_race": 0
    },
    {
        "id": 43,
        "trimmed_code": "int a[100];\nint main()\n{\nint i;\n#pragma omp parallel for\n  for (i=0;i<100;i++)\n    a[i]=a[i]+1;\n  return 0;\n} \n",
        "data_race": 0
    },
    {
        "id": 44,
        "trimmed_code": "int a[100][100];\nint main()\n{\n  int i,j;\n#pragma omp parallel for private(j)\n  for (i=0;i<100;i++)\n    for (j=0;j<100;j++)\n      a[i][j]=a[i][j]+1;\n  return 0;\n}\n\n",
        "data_race": 0
    },
    {
        "id": 45,
        "trimmed_code": "char a[100];\nint main()\n{\n  int i;\n#pragma omp parallel for\n  for (i=0;i<100;i++)\n    a[i]=a[i]+1;\n  return 0;\n} \n",
        "data_race": 0
    },
    {
        "id": 46,
        "trimmed_code": "void foo(int * a, int n, int g)\n{\n  int i;\n#pragma omp parallel for firstprivate (g)\n  for (i=0;i<n;i++)\n  {\n    a[i] = a[i]+g;\n  }\n}\n\nint a[100];\nint main()\n{\n  foo(a, 100, 7);\n  return 0;\n}  \n",
        "data_race": 0
    },
    {
        "id": 47,
        "trimmed_code": "#include <stdio.h>\nint main(int argc, char* argv[])\n{\n  int i;\n  int ret;\n  FILE* pfile;\n  int len=1000;\n\n  int A[1000];\n\n  for (i=0; i<len; i++)\n    A[i]=i;\n\n  pfile = fopen(\"mytempfile.txt\",\"a+\");\n  if (pfile ==NULL)\n  {\n    fprintf(stderr,\"Error in fopen()\\n\");\n  }\n\n#pragma omp parallel for\n  for (i=0; i<len; ++i)\n  {\n    fprintf(pfile, \"%d\\n\", A[i] );\n  }\n\n  fclose(pfile);\n  ret = remove(\"mytempfile.txt\");\n  if (ret != 0)\n  {\n    fprintf(stderr, \"Error: unable to delete mytempfile.txt\\n\");\n  }\n  return 0;\n}\n\n",
        "data_race": 0
    },
    {
        "id": 48,
        "trimmed_code": "void foo1(double o1[], double c[], int len)\n{ \n  int i ;\n#pragma omp parallel for\n  for (i = 0; i < len; ++i) {\n    double volnew_o8 = 0.5 * c[i];\n    o1[i] = volnew_o8;\n  } \n}\n\ndouble o1[100];\ndouble c[100];\nint main()\n{\n  foo1 (o1, c, 100);\n  return 0;\n}\n",
        "data_race": 0
    },
    {
        "id": 49,
        "trimmed_code": "#include <omp.h>\n#include <stdio.h>\n\nint main()\n{\n  int numThreads=0 ; \n#pragma omp parallel\n  {\n    if ( omp_get_thread_num()==0 ) {\n      numThreads = omp_get_num_threads();\n    }\n  }\n  printf (\"numThreads=%d\\n\", numThreads);\n  return 0;\n}\n",
        "data_race": 0
    },
    {
        "id": 50,
        "trimmed_code": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#define N 180\nint indexSet[N] = {\n521, 523, 525, 527, 529, 531,\n547, 549, 551, 553, 555, 557,\n573, 575, 577, 579, 581, 583,\n599, 601, 603, 605, 607, 609,\n625, 627, 629, 631, 633, 635,\n\n651, 653, 655, 657, 659, 661,\n859, 861, 863, 865, 867, 869,\n885, 887, 889, 891, 893, 895,\n911, 913, 915, 917, 919, 921, \n937, 939, 941, 943, 945, 947,\n\n963, 965, 967, 969, 971, 973,\n989, 991, 993, 995, 997, 999,\n1197, 1199, 1201, 1203, 1205, 1207,\n1223, 1225, 1227, 1229, 1231, 1233,\n1249, 1251, 1253, 1255, 1257, 1259,\n\n1275, 1277, 1279, 1281, 1283, 1285,\n1301, 1303, 1305, 1307, 1309, 1311,\n1327, 1329, 1331, 1333, 1335, 1337,\n1535, 1537, 1539, 1541, 1543, 1545,\n1561, 1563, 1565, 1567, 1569, 1571,\n\n1587, 1589, 1591, 1593, 1595, 1597,\n1613, 1615, 1617, 1619, 1621, 1623,\n1639, 1641, 1643, 1645, 1647, 1649,\n1665, 1667, 1669, 1671, 1673, 1675,\n1873, 1875, 1877, 1879, 1881, 1883,\n\n1899, 1901, 1903, 1905, 1907, 1909,\n1925, 1927, 1929, 1931, 1933, 1935,\n1951, 1953, 1955, 1957, 1959, 1961,\n1977, 1979, 1981, 1983, 1985, 1987,\n2003, 2005, 2007, 2009, 2011, 2013};\n\nint main (int argc, char* argv[])\n{\n  double * base = (double*) malloc(sizeof(double)* (2013+12+1));\n  if (base == 0)\n  {\n    printf(\"Error, malloc() returns NULL. End execution. \\n\");\n    return 1;  \n  }\n\n  double * xa1 = base;\n  double * xa2 = base + 12;\n  int i;\n\n  for (i =521; i<= 2025; ++i)\n  {\n    base[i]=0.0;\n  }\n\n#pragma omp parallel for\n  for (i =0; i< N; ++i) \n  {\n    int idx = indexSet[i];\n    xa1[idx]+= 1.0;\n    xa2[idx]+= 3.0;\n  }\n\n  \n  for (i =521; i<= 2025; ++i)\n  {\n    \n    assert (base[i]!=4.0);\n  }\n\n  free (base);\n  return  0;\n}\n\n",
        "data_race": 0
    },
    {
        "id": 51,
        "trimmed_code": "#include <string.h>\nint main(int argc,char *argv[])\n{\n  int i;\n  int j;\n  double a[20][20];\n  memset(a,0,(sizeof(a)));\n\n  for (i = 0; i < 20 -1; i += 1) {\n#pragma omp parallel for\n    for (j = 0; j < 20; j += 1) {\n      a[i][j] += a[i + 1][j];\n    }\n  }\n  return 0;\n}\n",
        "data_race": 0
    },
    {
        "id": 52,
        "trimmed_code": "int main()\n{\n  int i,j;\n  int n=100, m=100;\n  double b[n][m];\n\n  for(i=0;i<n; i++) \n    for(j=0;j<n; j++) \n      b[i][j]=(double)(i*j);\n\n  for (i=1;i<n;i++)\n#pragma omp parallel for\n    for (j=1;j<m;j++)\n      b[i][j]=b[i-1][j-1];\n  return 0;\n}\n",
        "data_race": 0
    },
    {
        "id": 53,
        "trimmed_code": "#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <math.h>\n\n#include \"polybench/polybench.h\"\n\n\n#include \"polybench/jacobi-2d-imper.h\"\n\n\nstatic void init_array(int n,double A[500 + 0][500 + 0],double B[500 + 0][500 + 0])\n{\n  \n  \n{\n    int c2;\n    int c1;\n    if (n >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = 0; c1 <= n + -1; c1++) {\n        for (c2 = 0; c2 <= n + -1; c2++) {\n          A[c1][c2] = (((double )c1) * (c2 + 2) + 2) / n;\n          B[c1][c2] = (((double )c1) * (c2 + 3) + 3) / n;\n        }\n      }\n    }\n  }\n}\n\n\nstatic void print_array(int n,double A[500 + 0][500 + 0])\n{\n  int i;\n  int j;\n  for (i = 0; i < n; i++) \n    for (j = 0; j < n; j++) {\n      fprintf(stderr,\"%0.2lf \",A[i][j]);\n      if ((i * n + j) % 20 == 0) \n        fprintf(stderr,\"\\n\");\n    }\n  fprintf(stderr,\"\\n\");\n}\n\n\nstatic void kernel_jacobi_2d_imper(int tsteps,int n,double A[500 + 0][500 + 0],double B[500 + 0][500 + 0])\n{\n  \n  \n  \n  \n  \n{\n    int c2;\n    int c1;\n    int c0;\n    for (c2 = 1; c2 <= 498; c2++) {\n      B[1][c2] = 0.2 * (A[1][c2] + A[1][c2 - 1] + A[1][1 + c2] + A[1 + 1][c2] + A[1 - 1][c2]);\n    }\n    for (c0 = 2; c0 <= 525; c0++) {\n      if (c0 <= 28) {\n        if ((2 * c0 + 1) % 3 == 0) {\n          for (c2 = ((2 * c0 + 1) * 3 < 0?-(-(2 * c0 + 1) / 3) : ((3 < 0?(-(2 * c0 + 1) + - 3 - 1) / - 3 : (2 * c0 + 1 + 3 - 1) / 3))); c2 <= (((2 * c0 + 1492) * 3 < 0?((3 < 0?-((-(2 * c0 + 1492) + 3 + 1) / 3) : -((-(2 * c0 + 1492) + 3 - 1) / 3))) : (2 * c0 + 1492) / 3)); c2++) {\n            B[1][(-2 * c0 + 3 * c2 + 2) / 3] = 0.2 * (A[1][(-2 * c0 + 3 * c2 + 2) / 3] + A[1][(-2 * c0 + 3 * c2 + 2) / 3 - 1] + A[1][1 + (-2 * c0 + 3 * c2 + 2) / 3] + A[1 + 1][(-2 * c0 + 3 * c2 + 2) / 3] + A[1 - 1][(-2 * c0 + 3 * c2 + 2) / 3]);\n          }\n        }\n      }\n#pragma omp parallel for private(c2)\n      for (c1 = ((((2 * c0 + 2) * 3 < 0?-(-(2 * c0 + 2) / 3) : ((3 < 0?(-(2 * c0 + 2) + - 3 - 1) / - 3 : (2 * c0 + 2 + 3 - 1) / 3)))) > c0 + -9?(((2 * c0 + 2) * 3 < 0?-(-(2 * c0 + 2) / 3) : ((3 < 0?(-(2 * c0 + 2) + - 3 - 1) / - 3 : (2 * c0 + 2 + 3 - 1) / 3)))) : c0 + -9); c1 <= (((((2 * c0 + 498) * 3 < 0?((3 < 0?-((-(2 * c0 + 498) + 3 + 1) / 3) : -((-(2 * c0 + 498) + 3 - 1) / 3))) : (2 * c0 + 498) / 3)) < c0?(((2 * c0 + 498) * 3 < 0?((3 < 0?-((-(2 * c0 + 498) + 3 + 1) / 3) : -((-(2 * c0 + 498) + 3 - 1) / 3))) : (2 * c0 + 498) / 3)) : c0)); c1++) {\n        B[-2 * c0 + 3 * c1][1] = 0.2 * (A[-2 * c0 + 3 * c1][1] + A[-2 * c0 + 3 * c1][1 - 1] + A[-2 * c0 + 3 * c1][1 + 1] + A[1 + (-2 * c0 + 3 * c1)][1] + A[-2 * c0 + 3 * c1 - 1][1]);\n        for (c2 = 2 * c0 + -2 * c1 + 2; c2 <= 2 * c0 + -2 * c1 + 498; c2++) {\n          A[-2 * c0 + 3 * c1 + -1][-2 * c0 + 2 * c1 + c2 + -1] = B[-2 * c0 + 3 * c1 + -1][-2 * c0 + 2 * c1 + c2 + -1];\n          B[-2 * c0 + 3 * c1][-2 * c0 + 2 * c1 + c2] = 0.2 * (A[-2 * c0 + 3 * c1][-2 * c0 + 2 * c1 + c2] + A[-2 * c0 + 3 * c1][-2 * c0 + 2 * c1 + c2 - 1] + A[-2 * c0 + 3 * c1][1 + (-2 * c0 + 2 * c1 + c2)] + A[1 + (-2 * c0 + 3 * c1)][-2 * c0 + 2 * c1 + c2] + A[-2 * c0 + 3 * c1 - 1][-2 * c0 + 2 * c1 + c2]);\n        }\n        A[-2 * c0 + 3 * c1 + -1][498] = B[-2 * c0 + 3 * c1 + -1][498];\n      }\n      if (c0 >= 499) {\n        if ((2 * c0 + 1) % 3 == 0) {\n          for (c2 = ((2 * c0 + -992) * 3 < 0?-(-(2 * c0 + -992) / 3) : ((3 < 0?(-(2 * c0 + -992) + - 3 - 1) / - 3 : (2 * c0 + -992 + 3 - 1) / 3))); c2 <= (((2 * c0 + 499) * 3 < 0?((3 < 0?-((-(2 * c0 + 499) + 3 + 1) / 3) : -((-(2 * c0 + 499) + 3 - 1) / 3))) : (2 * c0 + 499) / 3)); c2++) {\n            A[498][(-2 * c0 + 3 * c2 + 995) / 3] = B[498][(-2 * c0 + 3 * c2 + 995) / 3];\n          }\n        }\n      }\n    }\n    for (c2 = 20; c2 <= 517; c2++) {\n      A[498][c2 + -19] = B[498][c2 + -19];\n    }\n  }\n  \n\n}\n\nint main(int argc,char **argv)\n{\n\n  int n = 500;\n  int tsteps = 10;\n\n  double (*A)[500 + 0][500 + 0];\n  A = ((double (*)[500 + 0][500 + 0])(polybench_alloc_data(((500 + 0) * (500 + 0)),(sizeof(double )))));\n  ;\n  double (*B)[500 + 0][500 + 0];\n  B = ((double (*)[500 + 0][500 + 0])(polybench_alloc_data(((500 + 0) * (500 + 0)),(sizeof(double )))));\n  ;\n\n  init_array(n, *A, *B);\n\n  polybench_timer_start();\n  ;\n\n  kernel_jacobi_2d_imper(tsteps,n, *A, *B);\n\n  polybench_timer_stop();\n  ;\n  polybench_timer_print();\n  ;\n\n  if (argc > 42 && !strcmp(argv[0],\"\")) \n    print_array(n, *A);\n\n  free(((void *)A));\n  ;\n  free(((void *)B));\n  ;\n  return 0;\n}\n",
        "data_race": 0
    },
    {
        "id": 54,
        "trimmed_code": "#include <stdio.h>\n#include <math.h>\n\n#define MSIZE 200\nint n=MSIZE, m=MSIZE;\ndouble alpha = 0.0543;\ndouble u[MSIZE][MSIZE], f[MSIZE][MSIZE], uold[MSIZE][MSIZE];\ndouble dx, dy;\n\nvoid\ninitialize ()\n{\n  int i, j, xx, yy;\n\n  dx = 2.0 / (n - 1);\n  dy = 2.0 / (m - 1);\n\n  \n#pragma omp parallel for private(i,j,xx,yy)\n  for (i = 0; i < n; i++)\n    for (j = 0; j < m; j++)\n    {\n      xx = (int) (-1.0 + dx * (i - 1));       \n      yy = (int) (-1.0 + dy * (j - 1));       \n      u[i][j] = 0.0;\n      f[i][j] = -1.0 * alpha * (1.0 - xx * xx) * (1.0 - yy * yy)\n        - 2.0 * (1.0 - xx * xx) - 2.0 * (1.0 - yy * yy);\n\n    }\n}\n\nint main()\n{\n  initialize();\n  return 0;\n}\n",
        "data_race": 0
    },
    {
        "id": 55,
        "trimmed_code": "#include <stdio.h>\n#include <math.h>\n\n#define MSIZE 200\nint n=MSIZE, m=MSIZE, mits=1000;\ndouble tol=0.0000000001, relax = 1.0, alpha = 0.0543;\ndouble u[MSIZE][MSIZE], f[MSIZE][MSIZE], uold[MSIZE][MSIZE];\ndouble dx, dy;\n\nvoid\ninitialize ()\n{\n  int i, j, xx, yy;\n\n  dx = 2.0 / (n - 1);\n  dy = 2.0 / (m - 1);\n\n\n\n  for (i = 0; i < n; i++)\n    for (j = 0; j < m; j++)\n    {\n      xx = (int) (-1.0 + dx * (i - 1));       \n      yy = (int) (-1.0 + dy * (j - 1));       \n      u[i][j] = 0.0;\n      f[i][j] = -1.0 * alpha * (1.0 - xx * xx) * (1.0 - yy * yy)\n        - 2.0 * (1.0 - xx * xx) - 2.0 * (1.0 - yy * yy);\n\n    }\n}\n\nvoid\njacobi ()\n{\n  double omega;\n  int i, j, k;\n  double error, resid,  ax, ay, b;\n\n  omega = relax;\n\n\n  dx = 2.0 / (n - 1); \n  dy = 2.0 / (m - 1);\n\n  ax = 1.0 / (dx * dx);         \n  ay = 1.0 / (dy * dy);         \n  b = -2.0 / (dx * dx) - 2.0 / (dy * dy) - alpha;       \n\n  error = 10.0 * tol;\n  k = 1;\n\n  while (k <= mits)\n    {\n      error = 0.0;\n\n\n#pragma omp parallel\n      {\n#pragma omp for private(i,j)\n        for (i = 0; i < n; i++)\n          for (j = 0; j < m; j++)\n            uold[i][j] = u[i][j];\n#pragma omp for private(i,j,resid) reduction(+:error) nowait\n        for (i = 1; i < (n - 1); i++)\n          for (j = 1; j < (m - 1); j++)\n            {\n              resid = (ax * (uold[i - 1][j] + uold[i + 1][j])\n                       + ay * (uold[i][j - 1] + uold[i][j + 1]) +\n                       b * uold[i][j] - f[i][j]) / b;\n\n              u[i][j] = uold[i][j] - omega * resid;\n              error = error + resid * resid;\n            }\n      }\n\n\n\n\n     k = k + 1;\n      error = sqrt (error) / (n * m);\n    }                           \n\n  printf (\"Total Number of Iterations:%d\\n\", k);\n  printf (\"Residual:%E\\n\", error);\n}\n\nint main()\n{\n  initialize();\n  jacobi();\n  return 0;\n}\n",
        "data_race": 0
    },
    {
        "id": 56,
        "trimmed_code": "#include <stdio.h>\n\nvoid foo()\n{\n  int i,x;\n#pragma omp parallel for private (i) lastprivate (x)\n  for (i=0;i<100;i++)\n    x=i;\n  printf(\"x=%d\",x);\n}\n\nint main()\n{\n  foo();\n  return 0;\n}\n\n",
        "data_race": 0
    },
    {
        "id": 57,
        "trimmed_code": "#define N 100\n#define M 100 \n#define K 100\ndouble a[N][M],b[M][K],c[N][K];\n            \nint mmm()   \n{           \n  int i,j,k;\n#pragma omp parallel for private(j,k)\n  for (i = 0; i < N; i++) \n    for (k = 0; k < K; k++) \n      for (j = 0; j < M; j++)\n        c[i][j]= c[i][j]+a[i][k]*b[k][j];\n  return 0; \n} \n\nint main()\n{\n  mmm();\n  return 0;\n}  \n",
        "data_race": 0
    },
    {
        "id": 58,
        "trimmed_code": "#define N 100\n\ndouble a[N][N],v[N],v_out[N];\nint mv()\n{           \n  int i,j;\n#pragma omp parallel for private (i,j)\n  for (i = 0; i < N; i++)\n  {         \n    float sum = 0.0;\n    for (j = 0; j < N; j++)\n    { \n      sum += a[i][j]*v[j];\n    }  \n    v_out[i] = sum;\n  }         \n  return 0; \n}\n\nint main()\n{\n  mv();\n  return 0;\n}\n\n",
        "data_race": 0
    },
    {
        "id": 59,
        "trimmed_code": "#define N 1000\ndouble a[N][N],v[N],v_out[N];\n\nvoid mv()\n{           \n  int i,j;\n  for (i = 0; i < N; i++)\n  {         \n    float sum = 0.0;\n#pragma omp parallel for reduction(+:sum)\n    for (j = 0; j < N; j++)\n    { \n      sum += a[i][j]*v[j];\n    }  \n    v_out[i] = sum;\n  }         \n}\n\nint main()\n{\n  mv();\n  return 0;\n}\n",
        "data_race": 0
    },
    {
        "id": 60,
        "trimmed_code": "int n=100, m=100;\ndouble b[100][100];\n\nvoid foo()\n{\n  int i,j;\n#pragma omp parallel for private(j)\n  for (i=0;i<n;i++)\n    for (j=0;j<m-1;j++) \n      b[i][j]=b[i][j+1];\n}\n\nint main()\n{\n  foo();\n  return 0;\n}\n",
        "data_race": 0
    },
    {
        "id": 61,
        "trimmed_code": "int n=100, m=100;\ndouble b[100][100];\n\nvoid foo()\n{\n  int i,j;\n#pragma omp parallel for private(j)\n  for (i=0;i<n;i++)\n    for (j=1;j<m;j++) \n      b[i][j]=b[i][j-1];\n}\n\nint main()\n{\n  foo();\n  return 0;\n}\n",
        "data_race": 0
    },
    {
        "id": 62,
        "trimmed_code": "#define num_steps 2000000000 \n\n#include <stdio.h>\nint main(int argc, char** argv)\n{\n  double pi = 0.0;\n  long int i;\n  double x, interval_width;\n  interval_width = 1.0/(double)num_steps;\n\n#pragma omp parallel for reduction(+:pi) private(x)\n  for (i = 0; i < num_steps; i++) {\n    x = (i+ 0.5) * interval_width;\n    pi += 1.0 / (x*x + 1.0);\n  }\n\n  pi = pi * 4.0 * interval_width;\n  printf (\"PI=%f\\n\", pi);\n  return 0;\n}\n",
        "data_race": 0
    },
    {
        "id": 63,
        "trimmed_code": "#include <stdlib.h>\nvoid setup(int N)\n{\n  double * m_pdv_sum = (double* ) malloc (sizeof (double) * N );\n  double * m_nvol = (double* ) malloc (sizeof (double) * N );\n\n#pragma omp parallel for schedule(static)\n  for (int i=0; i < N; ++i ) \n  { \n    m_pdv_sum[ i ] = 0.0;\n    m_nvol[ i ]   = i*2.5;\n  }\n\n  free(m_pdv_sum);\n  free(m_nvol);\n}\n\nint main()\n{\n  int N =1000;\n  setup(N);\n}\n  \n",
        "data_race": 0
    },
    {
        "id": 64,
        "trimmed_code": "#include <stdlib.h>\ntypedef double real8;\n\nvoid foo(real8 * restrict newSxx, real8 * restrict newSyy, int length)\n{\n  int i;\n\n#pragma omp parallel for private (i) firstprivate (length)\n  for (i = 0; i <= length - 1; i += 1) {\n    newSxx[i] = 0.0;\n    newSyy[i] = 0.0;\n  }\n}\n\nint main()\n{\n  int length=1000;\n  real8* newSxx = malloc (length* sizeof (real8));\n  real8* newSyy = malloc (length* sizeof (real8));\n\n  foo(newSxx, newSyy, length);\n\n  free (newSxx);\n  free (newSyy);\n  return 0;\n}\n\n",
        "data_race": 0
    },
    {
        "id": 65,
        "trimmed_code": "#include <stdlib.h>\n#include <stdio.h>\n\nvoid foo(int n, int * restrict  a, int * restrict b, int * restrict  c)\n{\n  int i;\n#pragma omp parallel for \n  for (i = 0; i < n; i++)\n    a[i] = b[i] + c[i];  \n}\n\nint main()\n{\n  int n = 1000;\n  int * a , *b, *c;\n\n  a = (int*) malloc (n* sizeof (int));\n  if (a ==0)\n  {\n    fprintf (stderr, \"skip the execution due to malloc failures.\\n\");\n    return 1;\n  }\n\n  b = (int*) malloc (n* sizeof (int));\n  if (b ==0)\n  {\n    fprintf (stderr, \"skip the execution due to malloc failures.\\n\");\n    return 1;\n  }\n\n  c = (int*) malloc (n* sizeof (int));\n  if (c ==0)\n  {\n    fprintf (stderr, \"skip the execution due to malloc failures.\\n\");\n    return 1;\n  }\n\n  foo (n, a, b,c);\n\n  free (a);\n  free (b);\n  free (c);\n  return 0;\n}  \n\n",
        "data_race": 0
    },
    {
        "id": 66,
        "trimmed_code": "#include <omp.h>\n#include <assert.h> \nint main()\n{\n  omp_lock_t lck;\n  int i=0;\n  omp_init_lock(&lck);\n#pragma omp parallel sections\n  {\n#pragma omp section\n    {\n      omp_set_lock(&lck);\n      i += 1;    \n      omp_unset_lock(&lck);\n    }\n#pragma omp section\n    {\n      omp_set_lock(&lck);\n      i += 2;    \n      omp_unset_lock(&lck);\n    }\n  }\n\n  omp_destroy_lock(&lck);\n  assert (i==3);\n  return 0;\n} \n",
        "data_race": 0
    },
    {
        "id": 67,
        "trimmed_code": "int a[100], b[100], c[100];\nint main()\n{\n  int i;\n#pragma omp simd\n  for (i=0;i<100;i++)\n    a[i]=b[i]*c[i];\n  return 0;\n}\n",
        "data_race": 0
    },
    {
        "id": 68,
        "trimmed_code": "int main(int argc, char* argv[])\n{\n  int i;\n  int len = 1000;\n  int a[len];\n\n  for (i=0; i<len; i++)\n    a[i]= i;\n\n#pragma omp target map(a[0:len])\n#pragma omp parallel for\n  for (i=0;i< len;i++)\n    a[i]=a[i]+1;\n\n  return 0;\n}\n",
        "data_race": 0
    },
    {
        "id": 69,
        "trimmed_code": "#include <assert.h> \nint main()\n{\n  int i=0;\n#pragma omp parallel\n#pragma omp single\n  {\n#pragma omp task depend (out:i)\n    i = 1;    \n#pragma omp task depend (in:i)\n    i = 2;    \n  }\n\n  assert (i==2);\n  return 0;\n} \n",
        "data_race": 0
    },
    {
        "id": 70,
        "trimmed_code": "#include <stdio.h>\n\nint a[100][100];\nint main()\n{\n  int i,j;\n#pragma omp parallel for\n  for (i=0;i<100;i++)\n    for (j=0;j<100;j++)\n      a[i][j]=a[i][j]+1;\n  return 0;\n}\n\n",
        "data_race": 1
    },
    {
        "id": 71,
        "trimmed_code": "#include<stdio.h>\n#include<assert.h>\n\nvoid f1(int *q)\n{\n#pragma omp critical\n  *q = 1;\n#pragma omp flush\n}\n\nint main()\n{ \n  int i=0, sum=0; \n  \n  #pragma omp parallel reduction(+:sum) num_threads(10) \n  {\n     f1(&i);\n     sum+=i;\n  }\n  assert (sum==10);\n  printf(\"sum=%d\\n\", sum);\n  return 0;   \n}\n",
        "data_race": 1
    },
    {
        "id": 72,
        "trimmed_code": "#include <omp.h>\n#include <stdio.h>\nint main()\n{\n  int numThreads=0 ; \n#pragma omp parallel\n  {\n    if ( omp_get_thread_num()==0 ) {\n      numThreads = omp_get_num_threads();\n    }\n    else\n    {\n      printf(\"numThreads=%d\\n\", numThreads);\n    }\n  }\n  return 0;\n}\n",
        "data_race": 1
    },
    {
        "id": 73,
        "trimmed_code": "#include<stdio.h>\n#include<assert.h>\nvoid f1(int *q)\n{\n  *q = 1;\n}\n\nint main()\n{ \n  int i=0, sum=0; \n  #pragma omp parallel reduction(+:sum) num_threads(10) private(i)\n  {\n     f1(&i);\n     sum+= i; \n  }\n  assert (sum==10);\n  printf(\"sum=%d\\n\", sum);\n  return 0;   \n}\n",
        "data_race": 0
    },
    {
        "id": 74,
        "trimmed_code": "#include <stdio.h>\n\nint main()\n{\n  int count=0;\n\n#pragma omp parallel shared(count) \n  {\n#pragma omp single\n    count += 1;\n  }\n\n  printf (\"count= %d\\n\", count);\n  return 0;\n}\n",
        "data_race": 0
    },
    {
        "id": 75,
        "trimmed_code": "#include <assert.h> \n#include <unistd.h>\nint main()\n{\n  int i=0;\n#pragma omp parallel\n#pragma omp single\n  {\n#pragma omp task depend (out:i)\n    {\n      sleep(3);\n      i = 1;    \n    }\n#pragma omp task depend (out:i)\n    i = 2;    \n  }\n\n  assert (i==2);\n  return 0;\n} \n",
        "data_race": 0
    },
    {
        "id": 76,
        "trimmed_code": "#include <stdio.h> \n#include <assert.h> \n#include <unistd.h>\nint main()\n{\n  int i=0, j, k;\n#pragma omp parallel\n#pragma omp single\n  {\n#pragma omp task depend (out:i)\n    {\n      sleep(3);\n      i = 1;    \n    }\n#pragma omp task depend (in:i)\n    j =i; \n#pragma omp task depend (in:i)\n    k =i; \n  }\n  printf (\"j=%d k=%d\\n\", j, k);\n  assert (j==1 && k==1);\n  return 0;\n} \n",
        "data_race": 0
    },
    {
        "id": 77,
        "trimmed_code": "#include<stdio.h>\n\n\nvoid f1(int* q)\n{\n  *q += 1;\n}\n\nint main()\n{ \n  int i=0; \n  #pragma omp parallel \n  {\n     f1(&i);\n  }\n  printf (\"i=%d\\n\",i);\n  return 0;   \n}\n",
        "data_race": 1
    },
    {
        "id": 78,
        "trimmed_code": "#include<stdio.h>\n#include<assert.h>\n\nvoid f1(int q)\n{\n  q += 1;\n}\n\nint main()\n{\n  int i=0;\n  #pragma omp parallel \n  {\n     f1(i);\n  }\n  assert (i==0);\n  printf (\"i=%d\\n\",i);\n  return 0;\n}\n\n",
        "data_race": 0
    },
    {
        "id": 79,
        "trimmed_code": "void foo()\n{\n  static int q; \n  q += 1;\n}\n\nint main()\n{ \n  #pragma omp parallel \n  {\n     foo();\n  }\n  return 0;   \n}\n\n",
        "data_race": 1
    },
    {
        "id": 80,
        "trimmed_code": "void foo()\n{\n  int q=0; \n  q += 1;\n}\n\nint main()\n{ \n  #pragma omp parallel \n  {\n     foo();\n  }\n  return 0;   \n}\n\n",
        "data_race": 0
    },
    {
        "id": 81,
        "trimmed_code": "#include <stdio.h>\n#include <assert.h>\nint sum0=0, sum1=0;\n\n\nvoid foo (int i)\n{\n  sum0=sum0+i;\n}\n\nint main()\n{\n  int i, sum=0;\n#pragma omp parallel\n  {\n#pragma omp for\n    for (i=1;i<=1000;i++)\n    {\n       foo (i);\n    }   \n#pragma omp critical\n    {\n      sum= sum+sum0;\n    } \n  }  \n\n  for (i=1;i<=1000;i++)\n  {\n    sum1=sum1+i;\n  }\n  printf(\"sum=%d; sum1=%d\\n\",sum,sum1);\n\n  return 0;\n}\n\n",
        "data_race": 1
    },
    {
        "id": 82,
        "trimmed_code": "#include <stdio.h>\n#include <assert.h>\n\nint sum0=0, sum1=0;\n#pragma omp threadprivate(sum0)\n\nvoid foo (int i)\n{\n  sum0=sum0+i;\n}\n\nint main()\n{\n  int len=1000;\n  int i, sum=0;\n#pragma omp parallel copyin(sum0)\n  {\n#pragma omp for\n    for (i=0;i<len;i++)\n    {\n       foo (i);\n    }   \n#pragma omp critical\n    {\n      sum= sum+sum0;\n    } \n  }  \n\n  for (i=0;i<len;i++)\n  {\n    sum1=sum1+i;\n  }\n  printf(\"sum=%d; sum1=%d\\n\",sum,sum1);\n  assert(sum==sum1);\n  return 0;\n}\n\n",
        "data_race": 0
    },
    {
        "id": 83,
        "trimmed_code": "#include<iostream>\n#include<cassert>\nusing namespace std;\n\nclass A {\npublic:\n  static int counter; \n  static int pcounter; \n#pragma omp threadprivate(pcounter)\n};\n\nint A::counter=0; \nint A::pcounter=0; \n\nA a; \n\nvoid foo()\n{\n   a.counter++; \n   a.pcounter++; \n}\n\nint main()\n{ \n  #pragma omp parallel \n  {\n     foo();\n  }\n  assert (A::pcounter == 1);\n  cout<<A::counter <<\" \"<< A::pcounter<<endl;\n  return 0;   \n}\n",
        "data_race": 1
    },
    {
        "id": 84,
        "trimmed_code": "#include<iostream>\n#include<cassert>\nusing namespace std;\n\nclass A {\npublic:\n  static int counter; \n  static int pcounter; \n#pragma omp threadprivate(pcounter)\n};\n\nint A::counter=0; \nint A::pcounter=0; \n\nA a; \n\nint main()\n{ \n  #pragma omp parallel \n  {\n   a.counter++; \n   a.pcounter++; \n  }\n  assert (A::pcounter == 1);\n  cout<<A::counter <<\" \"<< A::pcounter<<endl;\n  return 0;   \n}\n",
        "data_race": 1
    },
    {
        "id": 85,
        "trimmed_code": "#include<stdio.h>\n#include<stdlib.h>\n\nint* counter; \n\nvoid foo()\n{\n   (*counter)++; \n}\n\nint main()\n{ \n  counter = (int*) malloc(sizeof(int));\n  if (counter== NULL)\n  {\n    fprintf(stderr, \"malloc() fails\\n\");\n    exit(1);\n  }\n  *counter = 0; \n #pragma omp parallel \n  {\n     foo();\n  }\n  printf(\"%d \\n\", *counter);\n  free (counter);\n  return 0;   \n}\n\n",
        "data_race": 1
    },
    {
        "id": 86,
        "trimmed_code": "#include<stdio.h>\n#include<stdlib.h>\n\nint* counter; \n\n\nint main()\n{ \n  counter = (int*) malloc(sizeof(int));\n  if (counter== NULL)\n  {\n    fprintf(stderr, \"malloc() fails\\n\");\n    exit(1);\n  }\n  *counter = 0; \n #pragma omp parallel \n  {\n    (*counter)++; \n  }\n  printf(\"%d \\n\", *counter);\n  free (counter);\n  return 0;   \n}\n\n",
        "data_race": 1
    },
    {
        "id": 87,
        "trimmed_code": "#include<stdio.h>\n\nint main(int argc, char* argv[])\n{\n  int i;\n  int len=100;\n  int a[len], b[len];\n\n  for (i=0;i<len;i++)\n  {  a[i]=i; b[i]=i;} \n\n#pragma omp parallel \n  {\n    static int tmp;\n#pragma omp for\n    for (i=0;i<len;i++)\n    {\n      tmp = a[i]+i;\n      a[i] = tmp;\n    }\n  }\n\n\n#pragma omp parallel \n  {\n    int tmp;\n#pragma omp for\n    for (i=0;i<len;i++)\n    {\n      tmp = b[i]+i;\n      b[i] = tmp;\n    }\n  }\n\n  printf(\"a[50]=%d b[50]=%d\\n\", a[50], b[50]);\n \n  return 0;\n}\n",
        "data_race": 1
    },
    {
        "id": 88,
        "trimmed_code": "#include <stdio.h>\n#include <assert.h>\n\nint sum0=0, sum1=0;\n#pragma omp threadprivate(sum0)\n\nint main()\n{\n  int len=1000;\n  int i, sum=0;\n#pragma omp parallel copyin(sum0)\n  {\n#pragma omp for\n    for (i=0;i<len;i++)\n    {\n      sum0=sum0+i;\n    }   \n#pragma omp critical\n    {\n      sum= sum+sum0;\n    } \n  }  \n  \n  for (i=0;i<len;i++)\n  {\n    sum1=sum1+i;\n  }\n  printf(\"sum=%d; sum1=%d\\n\",sum,sum1);\n  assert(sum==sum1);\n  return 0;\n}\n\n",
        "data_race": 0
    },
    {
        "id": 89,
        "trimmed_code": "#include <stdio.h>\n#include <assert.h>\nint sum0=0, sum1=0;\n\n\nint main()\n{\n  int i, sum=0;\n#pragma omp parallel\n  {\n#pragma omp for\n    for (i=1;i<=1000;i++)\n    {\n      sum0=sum0+i;\n    }   \n#pragma omp critical\n    {\n      sum= sum+sum0;\n    } \n  }  \n\n  for (i=1;i<=1000;i++)\n  {\n    sum1=sum1+i;\n  }\n  printf(\"sum=%d; sum1=%d\\n\",sum,sum1);\n\n  return 0;\n}\n\n",
        "data_race": 1
    },
    {
        "id": 90,
        "trimmed_code": "int a[100][100];\nint main()\n{\n  int i,j;\n#pragma omp parallel for collapse(2)\n  for (i=0;i<100;i++)\n    for (j=0;j<100;j++)\n      a[i][j]=a[i][j]+1;\n  return 0;\n}\n\n",
        "data_race": 0
    },
    {
        "id": 91,
        "trimmed_code": "#if (_OPENMP<201511)\n#error \"An OpenMP 4.5 compiler is needed to compile this test.\"\n#endif\n#include <stdio.h>\nint a[100][100];\nint main()\n{\n  int i, j;\n#pragma omp parallel for ordered(2)\n  for (i = 0; i < 100; i++)\n    for (j = 0; j < 100; j++)\n    {\n      a[i][j] = a[i][j] + 1;\n#pragma omp ordered depend(sink:i-1,j) depend (sink:i,j-1)\n      printf (\"test i=%d j=%d\\n\",i,j);\n#pragma omp ordered depend(source)\n    }\n  return 0;\n}\n\n",
        "data_race": 0
    },
    {
        "id": 92,
        "trimmed_code": "#if (_OPENMP<201511)\n#error \"An OpenMP 4.5 compiler is needed to compile this test.\"\n#endif\n#include <stdio.h>\nint a[100][100];\nint main()\n{\n  int i, j;\n#pragma omp parallel\n  {\n#pragma omp single\n    {\n#pragma omp taskloop\n      for (i = 0; i < 100; i++)\n        for (j = 0; j < 100; j++)\n          a[i][j]+=1; \n    }\n  }\n  printf (\"a[50][50]=%d\\n\", a[50][50]);\n  return 0;\n}\n",
        "data_race": 1
    },
    {
        "id": 93,
        "trimmed_code": "#if (_OPENMP<201511)\n#error \"An OpenMP 4.5 compiler is needed to compile this test.\"\n#endif\n\n#include <stdio.h>\nint a[100][100];\nint main()\n{\n  int i, j;\n#pragma omp parallel\n  {\n#pragma omp single\n    {\n#pragma omp taskloop collapse(2)\n      for (i = 0; i < 100; i++)\n        for (j = 0; j < 100; j++)\n          a[i][j]+=1; \n    }\n  }\n  printf (\"a[50][50]=%d\\n\", a[50][50]);\n  return 0;\n}\n",
        "data_race": 0
    },
    {
        "id": 94,
        "trimmed_code": "#include <stdio.h>\n#define min(x, y) (((x) < (y)) ? (x) : (y))\n\n\nint main(int argc, char* argv[])\n{\n  int i, i2;\n  int len = 2560;\n  double sum =0.0, sum2=0.0;\n  double a[len], b[len];\n  \n  for (i=0; i<len; i++)\n  {\n    a[i]= ((double)i)/2.0;\n    b[i]= ((double)i)/3.0;\n  }\n\n#pragma omp target map(to: a[0:len], b[0:len]) map(tofrom: sum)\n#pragma omp teams num_teams(10) thread_limit(256) reduction (+:sum) \n#pragma omp distribute\n  for (i2=0; i2< len; i2+=256)  \n#pragma omp parallel for reduction (+:sum)\n    for (i=i2;i< min(i2+256, len); i++)\n      sum += a[i]*b[i];\n\n  \n#pragma omp parallel for reduction (+:sum2)\n    for (i=0;i< len; i++)\n      sum2 += a[i]*b[i];\n  printf (\"sum=%f sum2=%f\\n\", sum, sum2);\n  return 0;\n}\n",
        "data_race": 0
    },
    {
        "id": 95,
        "trimmed_code": "#include <stdio.h>\n\nint main()\n{\n  int len=100;\n  double a[len][len], b[len][len], c[len][len];\n  int i,j;\n\n  for (i=0;i<len;i++)\n    for (j=0;j<len;j++)\n    {\n      a[i][j]=((double)i)/2.0; \n      b[i][j]=((double)i)/3.0; \n      c[i][j]=((double)i)/7.0; \n    }\n\n#pragma omp simd collapse(2)\n  for (i=0;i<len;i++)\n    for (j=0;j<len;j++)\n      c[i][j]=a[i][j]*b[i][j];\n\n  printf (\"c[50][50]=%f\\n\",c[50][50]);\n  return 0;\n}\n",
        "data_race": 0
    },
    {
        "id": 96,
        "trimmed_code": "#include <stdio.h>\n\nvoid foo (double* a, double* b, int N)\n{\n  int i; \n#pragma omp target map(to:a[0:N]) map(from:b[0:N])\n#pragma omp parallel for\n  for (i=0;i< N ;i++)\n    b[i]=a[i]*(double)i;\n}\n\nint main(int argc, char* argv[])\n{\n  int i;\n  int len = 1000;\n  double a[len], b[len];\n  for (i=0; i<len; i++)\n  {\n    a[i]= ((double)i)/2.0;\n    b[i]=0.0;\n  }\n\n  foo(a, b, len);\n\n  printf(\"b[50]=%f\\n\",b[50]);\n  return 0;\n}\n",
        "data_race": 0
    },
    {
        "id": 97,
        "trimmed_code": "#if (_OPENMP<201511)\n#error \"OpenMP 4.5 compilers (e.g. GCC 6.x or later ) are needed to compile this test.\"\n#endif\n\n#include <stdio.h>\n#define MYLEN 100\nint a[MYLEN];\n\nvoid gen_task(int& i)\n{\n#pragma omp task\n  {\n    a[i]= i+1;\n  }\n}\n\nint main()\n{\n  int i=0;\n#pragma omp parallel\n  {\n#pragma omp single\n    {\n      for (i=0; i<MYLEN; i++)\n      {\n        gen_task(i);\n      }\n    }\n  }\n  \n  \n  for (i=0; i<MYLEN; i++)\n  {\n    \n    if (a[i]!= i+1)\n    {\n      printf(\"warning: a[%d] = %d, not expected %d\\n\", i, a[i], i+1);\n    }\n  }\n  return 0;\n}\n\n",
        "data_race": 0
    },
    {
        "id": 98,
        "trimmed_code": "#include <stdio.h>\n\n#define MYLEN 100\nint a[MYLEN];\n\nvoid gen_task(int i)\n{\n#pragma omp task\n  {\n    a[i]= i+1;\n  }\n}\n\nint main()\n{\n  int i=0;\n#pragma omp parallel\n  {\n#pragma omp single\n    {\n      for (i=0; i<MYLEN; i++)\n      {\n        gen_task(i);\n      }\n    }\n  }\n  \n  \n  for (i=0; i<MYLEN; i++)\n  {\n    \n    if (a[i]!= i+1)\n    {\n      printf(\"warning: a[%d] = %d, not expected %d\\n\", i, a[i], i+1);\n    }\n  }\n  return 0;\n}\n\n",
        "data_race": 0
    },
    {
        "id": 99,
        "trimmed_code": "#include <stdio.h>\n \nfloat x=0.0;\nint y=0;\n#pragma omp threadprivate(x,y)\n\nint main (int argc, char * argv[])\n{\n#pragma omp parallel\n  {\n#pragma omp single copyprivate(x,y)\n    {\n      x=1.0;\n      y=1;\n    }\n  }\n  printf (\"x=%f y=%d\\n\", x, y);\n  return 0;\n}\n",
        "data_race": 0
    },
    {
        "id": 100,
        "trimmed_code": "#include <omp.h>\n#include <stdio.h>\n\nint main()\n{\n  int k;\n\n#pragma omp parallel\n  {\n#pragma omp master\n    {\n      k = omp_get_num_threads();\n      printf (\"Number of Threads requested = %i\\n\",k);\n    }\n  }\n  return 0;\n}\n",
        "data_race": 0
    },
    {
        "id": 101,
        "trimmed_code": "#include <stdio.h>\n#include <assert.h>\nint main()\n{\n  int i,error;\n  int len = 1000;\n  int a[len], b=5;\n\n  for (i=0; i<len; i++)\n    a[i]= i;\n \n#pragma omp parallel shared(b, error) \n  {\n#pragma omp for nowait\n    for(i = 0; i < len; i++)\n      a[i] = b + a[i]*5;\n\n#pragma omp barrier\n\n#pragma omp single\n    error = a[9] + 1;\n  }\n  assert (error == 51);\n  printf (\"error = %d\\n\", error);\n  return 0;\n}  \n",
        "data_race": 0
    },
    {
        "id": 102,
        "trimmed_code": "#include <stdio.h>\n#include <assert.h>\nunsigned int input = 30;\nint fib(unsigned int n)\n{\n  if (n<2)\n    return n;\n  else\n  {\n    int i, j;\n#pragma omp task shared(i)\n    i=fib(n-1);\n#pragma omp task shared(j)\n    j=fib(n-2);\n#pragma omp taskwait\n    return i+j;\n  }\n}\nint main()\n{\n  int result = 0;\n#pragma omp parallel\n  {\n   #pragma omp single\n    {\n      result = fib(input);\n    }\n  }\n  printf (\"Fib(%d)=%d\\n\", input, result);\n  assert (result==832040);\n  return 0;\n}\n",
        "data_race": 0
    },
    {
        "id": 103,
        "trimmed_code": "#include <stdio.h>\n\nunsigned int input = 10;\nint fib(unsigned int n)\n{\n  if (n<2)\n    return n;\n  else\n  {\n    int i, j;\n#pragma omp task shared(i)\n    i=fib(n-1);\n#pragma omp task shared(j)\n    j=fib(n-2);\n\n    int res= i+j; \n\n#pragma omp taskwait\n    return res;\n  }\n}\nint main()\n{\n  int result = 0;\n#pragma omp parallel\n  {\n   #pragma omp single\n    {\n      result = fib(input);\n    }\n  }\n  printf (\"Fib(%d)=%d (correct answer should be 55)\\n\", input, result);\n  return 0;\n}\n",
        "data_race": 1
    },
    {
        "id": 104,
        "trimmed_code": "#include <stdio.h>\n#include <assert.h>\n#include <unistd.h>\n\nint main()\n{\n  int result = 0;\n#pragma omp parallel\n  {\n#pragma omp single\n    {\n#pragma omp taskgroup\n      {\n#pragma omp task\n        {\n          sleep(3);\n          result = 1; \n        }\n      }\n#pragma omp task\n      {\n        result = 2; \n      }\n    }\n  }\n  printf (\"result=%d\\n\", result);\n  assert (result==2);\n  return 0;\n}\n",
        "data_race": 0
    },
    {
        "id": 105,
        "trimmed_code": "#include <stdio.h>\n\nint main (void)\n{\n  int a=0;\n#pragma omp parallel \n  {\n#pragma omp atomic\n    a+=1;\n  }\n  printf (\"a=%d\\n\",a);\n  return 0;\n}\n\n",
        "data_race": 0
    },
    {
        "id": 106,
        "trimmed_code": "#include <stdio.h>\n\nint main()\n{\n  int x =0;\n#pragma omp parallel for ordered \n  for (int i = 0; i < 100; ++i) {\n    x++;\n  }\n  printf (\"x=%d\\n\",x);\n  return 0;\n} \n",
        "data_race": 1
    },
    {
        "id": 107,
        "trimmed_code": "#include <assert.h> \n#include <stdio.h>\n\nint main()\n{\n  int x =0;\n#pragma omp parallel for ordered \n  for (int i = 0; i < 100; ++i) {\n#pragma omp ordered\n    {\n      x++;\n    }\n  }\n  assert (x==100);\n  printf (\"x=%d\\n\",x);\n  return 0;\n} \n",
        "data_race": 0
    },
    {
        "id": 108,
        "trimmed_code": "#include <stdio.h>\n\nint main()\n{\n  int len=100;\n  double a[len], b[len], c[len];\n  int i,j=0;\n\n  for (i=0;i<len;i++)\n  {\n    a[i]=((double)i)/2.0; \n    b[i]=((double)i)/3.0; \n    c[i]=((double)i)/7.0; \n  }\n\n#pragma omp parallel for \n  for (i=0;i<len;i++)\n  {\n    c[j]+=a[i]*b[i];\n    j++;\n  }\n\n  printf (\"c[50]=%f\\n\",c[50]);\n  return 0;\n}\n",
        "data_race": 1
    },
    {
        "id": 109,
        "trimmed_code": "#if (_OPENMP<201511)\n#error \"An OpenMP 4.5 compiler is needed to compile this test.\"\n#endif\n#include <stdio.h>\nint main()\n{\n  int len=100;\n  double a[len], b[len], c[len];\n  int i,j=0;\n\n  for (i=0;i<len;i++)\n  {\n    a[i]=((double)i)/2.0; \n    b[i]=((double)i)/3.0; \n    c[i]=((double)i)/7.0; \n  }\n\n#pragma omp parallel for linear(j)\n  for (i=0;i<len;i++)\n  {\n    c[j]+=a[i]*b[i];\n    j++;\n  }\n\n  printf (\"c[50]=%f\\n\",c[50]);\n  return 0;\n}\n",
        "data_race": 0
    },
    {
        "id": 110,
        "trimmed_code": "int a[100][100];\nint b[100][100];\nint main()\n{\n  int i,j;\n#pragma omp parallel for default(none) shared(a) private(i,j)\n  for (i=0;i<100;i++)\n    for (j=0;j<100;j++)\n      a[i][j]=a[i][j]+1;\n\n#pragma omp parallel for default(shared) private(i,j)\n  for (i=0;i<100;i++)\n    for (j=0;j<100;j++)\n      b[i][j]=b[i][j]+1;\n\n  return 0;\n}\n\n",
        "data_race": 0
    },
    {
        "id": 111,
        "trimmed_code": "#include <stdlib.h>\n#include <stdio.h>\n#include <time.h>\nint main(int argc, char* argv[])\n{\n  int i;\n  int len=100;\n  int a[100];\n\n  for (i=0;i<len;i++)\n    a[i]=i;\n   \n  srand(time(NULL));\n#pragma omp parallel for if (rand()%2)\n  for (i=0;i<len-1;i++)\n    a[i+1]=a[i]+1;\n\n  printf(\"a[50]=%d\\n\", a[50]);   \n  return 0;\n}\n",
        "data_race": 1
    },
    {
        "id": 112,
        "trimmed_code": "#include <stdio.h>\nint main(int argc, char* argv[])\n{\n  int i;\n  int len=100;\n  int a[100], b[100];\n\n  for (i=0;i<len;i++)\n  {\n    a[i]=i;\n    b[i]=i+1;\n  }\n\n#pragma omp parallel for simd \n  for (i=0;i<len-1;i++)\n    a[i+1]=a[i]+b[i];\n\n  printf(\"a[50]=%d\\n\",a[50]);\n  return 0;\n}\n",
        "data_race": 1
    },
    {
        "id": 113,
        "trimmed_code": "#include <stdio.h>\n\n\nint main(int argc, char* argv[])\n{\n  int i;\n  int len = 100;\n  double a[len];\n\n  \n  for (i=0; i<len; i++)\n    a[i]= ((double)i)/2.0;\n\n#pragma omp target map(tofrom: a[0:len]) \n#pragma omp teams num_teams(2) \n  {\n    a[50]*=2.0;\n  }\n\n  printf (\"a[50]=%f\\n\", a[50]);\n  return 0;\n}\n",
        "data_race": 1
    },
    {
        "id": 114,
        "trimmed_code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main(){\n\n  int a[4];\n  int psum[2];\n  int sum;\n\n  #pragma omp parallel num_threads(2)\n  {\n    #pragma omp for schedule(dynamic, 1)\n    for (int i=0; i < 4; ++i){\n      a[i] = i;\n      int s;\n      s = (- 3 - 3) / - 3;\n    }\n\n    #pragma omp single\n    {\n      #pragma omp task\n      {\n       #pragma omp task\n       {\n         psum[1] = a[2] + a[3];\n       }\n        psum[0] = a[0] + a[1];\n      }\n\n      #pragma omp taskwait\n      sum = psum[1] + psum[0];\n    }\n  }\n\n  printf(\"sum = %d\\n\", sum);\n  return 0;\n }\n",
        "data_race": 1
    },
    {
        "id": 115,
        "trimmed_code": "#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n  int a, b;\n  omp_nest_lock_t lck;\n} pair;\n\nvoid incr_a(pair *p){\n  p->a += 1;\n}\nvoid incr_b(pair *p){\n  omp_set_nest_lock(&p->lck);\n    p->b += 1;\n  omp_unset_nest_lock(&p->lck);\n}\n\n\nint main(int argc, char* argv[])\n{\n  pair p[1];\n  p->a = 0;\n  p->b = 0;\n  omp_init_nest_lock(&p->lck);\n\n  #pragma omp parallel sections\n  {\n    #pragma omp section\n    {\n      omp_set_nest_lock(&p->lck);\n      incr_b(p);\n      incr_a(p);\n      omp_unset_nest_lock(&p->lck);\n    }\n    #pragma omp section\n      incr_b(p);\n  }\n\n  omp_destroy_nest_lock(&p->lck);\n\n  printf(\"%d\\n\",p->b);\n  return 0;\n}\n",
        "data_race": 0
    },
    {
        "id": 116,
        "trimmed_code": "#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n  int a, b;\n  omp_nest_lock_t lck;\n} pair;\n\nvoid incr_a(pair *p){\n  p->a += 1;\n}\n\nvoid incr_b(pair *p){\n  p->b += 1;\n}\n\n\nint main(int argc, char* argv[])\n{\n  pair p[1];\n  p->a = 0;\n  p->b = 0;\n  omp_init_nest_lock(&p->lck);\n\n  #pragma omp parallel sections\n  {\n    #pragma omp section\n    {\n      omp_set_nest_lock(&p->lck);\n      incr_b(p);\n      incr_a(p);\n      omp_unset_nest_lock(&p->lck);\n    }\n    #pragma omp section\n      incr_b(p);\n  }\n\n  omp_destroy_nest_lock(&p->lck);\n\n  printf(\"%d\\n\",p->b);\n  return 0;\n}\n",
        "data_race": 1
    },
    {
        "id": 117,
        "trimmed_code": "#include <omp.h>\n#include <stdio.h>\n\nint main(int argc, char* argv[])\n{\n  int var = 0;\n\n  #pragma omp parallel shared(var)\n  {\n    #pragma omp single\n    var++;\n\n    #pragma omp barrier\n\n    #pragma omp single\n    var++;\n  }\n\n  if(var != 2) printf(\"%d\\n\",var);\n  int error = (var != 2);\n  return error;\n}\n",
        "data_race": 0
    },
    {
        "id": 118,
        "trimmed_code": "#include <omp.h>\n#include <stdio.h>\n\nint main(int argc, char* argv[])\n{\n  int var = 0, i, res;\n  int sum1 = 0;\n  int sum2 = 0;\n\n  res = omp_get_max_threads();\n\n  #pragma omp parallel reduction(+: var)\n  {\n    #pragma omp for schedule(static) reduction(+: sum1)\n    for (i=0; i<5; i++)\n    sum1+=i;\n    #pragma omp for schedule(static) reduction(+: sum2)\n    for (i=0; i<5; i++)\n    sum2+=i;\n\n    var = sum1 + sum2;\n  }\n\n  int error = (var != 20*res);\n  if (error) printf(\"%d %d\\n\",var,20*res);\n  return error;\n}\n",
        "data_race": 0
    },
    {
        "id": 119,
        "trimmed_code": "#include <omp.h>\n#include <stdio.h>\n#include <unistd.h>\n\nint main(int argc, char* argv[])\n{\n  int var = 0;\n  int i;\n\n  #pragma omp parallel sections \n  {\n    for (i = 0; i < 10; i++) {\n      #pragma omp task shared(var) if(0)\n      {\n        var++;\n      }\n    }\n  }\n\n  printf(\"%d\\n\",var);\n  return 0;\n}\n",
        "data_race": 0
    },
    {
        "id": 120,
        "trimmed_code": "#include <omp.h>\n#include <stdio.h>\n#include <unistd.h>\n\nint main(int argc, char* argv[])\n{\n  int var = 0;\n  int i;\n\n  #pragma omp parallel sections\n  {\n    for (i = 0; i < 10; i++) {\n      #pragma omp task shared(var)\n      {\n        var++;\n      }\n    }\n  }\n\n  if (var!=10) printf(\"%d\\n\",var);\n  return 0;\n}\n",
        "data_race": 1
    },
    {
        "id": 121,
        "trimmed_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint main (int argc, char **argv)\n{\n  int init, local;\n\n  #pragma omp parallel shared(init) private(local)\n  {\n    #pragma omp master\n    {\n      init = 10;\n    }\n\n    local = init;\n  }\n\n  return 0;\n}\n\n\n",
        "data_race": 1
    },
    {
        "id": 122,
        "trimmed_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint main (int argc, char **argv)\n{\n  int init, local;\n\n  #pragma omp parallel shared(init) private(local)\n  {\n    #pragma omp single\n    {\n    init = 10;\n    }\n    local = init;\n  }\n\n  return 0;\n}\n\n\n",
        "data_race": 0
    },
    {
        "id": 123,
        "trimmed_code": "#include <omp.h>\n#include <stdio.h>\n\nint main(){\n  int section_count = 0;\n  omp_set_dynamic(0);\n  \n  omp_set_num_threads(1);\n\n  #pragma omp parallel\n  #pragma omp sections firstprivate( section_count )\n  {\n    #pragma omp section\n    {\n      section_count++;\n      printf(\"%d\\n\",section_count);\n    }\n    #pragma omp section\n    {\n      section_count++;\n      printf(\"%d\\n\",section_count);\n    }\n  }\n  return 0;\n}\n",
        "data_race": 0
    },
    {
        "id": 124,
        "trimmed_code": "#include <omp.h>\n#include <stdio.h>\n\nint tp;\n#pragma omp threadprivate(tp)\nint var;\n\nint main(){\n  #pragma omp task\n  {\n    #pragma omp task\n    {\n      tp = 1;\n      #pragma omp task\n      {\n      }\n      var = tp;\n    }\n    tp=2;\n  }\n\n  if(var==2) printf(\"%d\\n\",var);\n  return 0;\n}\n",
        "data_race": 0
    },
    {
        "id": 125,
        "trimmed_code": "#include <omp.h>\n#include <stdio.h>\n\nint tp;\n#pragma omp threadprivate(tp)\nint var;\n\nint main(){\n  #pragma omp task\n  {\n    #pragma omp task\n    {\n      tp = 1;\n      #pragma omp task\n      {\n      }\n      var = tp;\n    }\n  }\n  return 0;\n}\n",
        "data_race": 0
    },
    {
        "id": 126,
        "trimmed_code": "#include <omp.h>\n#include <stdio.h>\n\n\nint main(){\n  int x = 2;\n\n  #pragma omp task mergeable\n  {\n    x++;\n  }\n  #pragma omp taskwait\n\n  printf(\"%d\\n\",x);\n  return 0;\n}\n",
        "data_race": 1
    },
    {
        "id": 127,
        "trimmed_code": "#include <omp.h>\n#include <stdio.h>\n\n\nint main(){\n  int x = 2;\n\n  #pragma omp task shared(x) mergeable\n  {\n    x++;\n  }\n  #pragma omp taskwait\n\n  printf(\"%d\\n\",x);\n  return 0;\n}\n",
        "data_race": 0
    },
    {
        "id": 128,
        "trimmed_code": "#include <stdio.h>\n#include <omp.h>\n\nvoid foo(){\n\n  int x = 0, y = 2;\n\n  #pragma omp task depend(inout: x) shared(x)\n  x++;                                                \n\n  #pragma omp task shared(y)\n  y--;                                                \n\n  #pragma omp task depend(in: x) if(0)                \n  {}\n\n  printf(\"x=%d\\n\",x);\n  printf(\"y=%d\\n\",y);\n  #pragma omp taskwait                                \n}\n\n\nint main(){\n  #pragma omp parallel\n  #pragma omp single\n  foo();\n\n  return 0;\n}\n",
        "data_race": 1
    },
    {
        "id": 129,
        "trimmed_code": "#include <stdio.h>\n#include <omp.h>\n\nvoid foo(){\n\n  int x = 0, y = 2;\n\n  #pragma omp task depend(inout: x) shared(x)\n  x++;                                                \n\n  #pragma omp task shared(y)\n  y--;                                                \n\n  #pragma omp task depend(in: x) if(0)                \n  {}\n\n  printf(\"x=%d\\n\",x);\n\n  #pragma omp taskwait                                \n\n  printf(\"y=%d\\n\",y);\n}\n\n\nint main(){\n  #pragma omp parallel\n  #pragma omp single\n  foo();\n\n  return 0;\n}\n\n",
        "data_race": 0
    },
    {
        "id": 130,
        "trimmed_code": "#include <stdio.h>\n#include <omp.h>\n\nvoid foo(){\n  int x = 0, y = 2;\n\n  #pragma omp task depend(inout: x) shared(x)\n  x++;                                                                  \n\n  #pragma omp task depend(in: x) depend(inout: y) shared(x, y)\n  y = y-x;                                                              \n\n  #pragma omp task depend(in: x) if(0)                                  \n  {}\n\n  printf(\"x=%d\\n\",x);\n\n  #pragma omp taskwait                                                  \n\n  printf(\"y=%d\\n\",y);\n}\n\nint main(){\n  #pragma omp parallel\n  #pragma omp single\n  foo();\n\n  return 0;\n}\n\n",
        "data_race": 0
    },
    {
        "id": 131,
        "trimmed_code": "#include <stdio.h>\n#include <omp.h>\n\nvoid foo(){\n  int x = 0, y = 2;\n\n  #pragma omp task depend(inout: x) shared(x)\n  x++;                                                             \n\n  #pragma omp task depend(in: x) depend(inout: y) shared(x, y)\n  y -= x;                                                         \n\n  #pragma omp task depend(in: x) if(0)                             \n  {}\n\n  printf(\"x=%d\\n\",x);\n  printf(\"y=%d\\n\",y);\n\n  #pragma omp taskwait\t\t                                         \n\n}\n\nint main(){\n  #pragma omp parallel\n  #pragma omp single\n  foo();\n\n  return 0;\n}\n\n",
        "data_race": 1
    },
    {
        "id": 132,
        "trimmed_code": "#include <stdio.h>\n#include <omp.h>\n\nint main(){\n  int a, b, c, d;\n\n  #pragma omp parallel\n  #pragma omp single\n  {\n    #pragma omp task depend(out: c)\n      c = 1;\n    #pragma omp task depend(out: a)\n      a = 2;\n    #pragma omp task depend(out: b)\n      b = 3;\n    #pragma omp task depend(in: a) depend(mutexinoutset: c)\n      c += a;\n    #pragma omp task depend(in: b) depend(mutexinoutset: c)\n      c += b;\n    #pragma omp task depend(in: c)\n      d = c;\n  }\n\n  printf(\"%d\\n\",d);\n  return 0;\n}\n",
        "data_race": 0
    },
    {
        "id": 133,
        "trimmed_code": "#include <stdio.h>\n#include <omp.h>\n\nint main(){\n  int a, b, c, d;\n\n  #pragma omp parallel\n  #pragma omp single\n  {\n    #pragma omp task depend(out: c)\n      c = 1;\n    #pragma omp task depend(out: a)\n      a = 2;\n    #pragma omp task depend(out: b)\n      b = 3;\n    #pragma omp task depend(in: a)\n      c += a;\n    #pragma omp task depend(in: b)\n      c += b;\n    #pragma omp task depend(in: c)\n      d = c;\n  }\n\n  printf(\"%d\\n\",d);\n  return 0;\n}\n",
        "data_race": 1
    },
    {
        "id": 134,
        "trimmed_code": "#include <stdio.h>\n#include <omp.h>\n\nint main(){\n\n  int i, m=2, n=4;\n  int b[4] = {};\n\n  #pragma omp simd safelen(2)\n  for (i = m; i<n; i++)\n    b[i] = b[i-m] - 1.0f;\n\n  printf(\"Expected: -1; Real: %d\\n\",b[3]);\n  return 0;\n}\n\n\n",
        "data_race": 0
    },
    {
        "id": 135,
        "trimmed_code": "#include <stdio.h>\n#include <omp.h>\n\nint main(){\n\n  int i, m=1, n=4;\n  int b[4] = {};\n\n  #pragma omp simd safelen(2)\n  for (i = m; i<n; i++)\n    b[i] = b[i-m] - 1.0f;\n\n  printf(\"Expected: -1; Real: %d\\n\",b[3]);\n  return 0;\n}\n",
        "data_race": 1
    },
    {
        "id": 136,
        "trimmed_code": "#include <stdio.h>\n#include <omp.h>\n\nint main(){\n\n  int i = 1;\n\n  #pragma omp parallel sections\n  {\n    #pragma omp section\n    {\n      #pragma omp critical (name)\n      {\n        #pragma omp parallel\n        {\n          #pragma omp single\n          {\n            i++;\n          }\n        }\n      }\n    }\n  }\n\n  printf(\"%d\\n\",i);\n  return 0;\n}\n",
        "data_race": 0
    },
    {
        "id": 137,
        "trimmed_code": "#include <stdio.h>\n#include <omp.h>\n\nint main(){\n  int a, i;\n\n  #pragma omp parallel shared(a) private(i)\n  {\n    #pragma omp master\n    a = 0;\n\n    #pragma omp for reduction(+:a)\n    for (i=0; i<10; i++){\n      a = a + i;\n    }\n\n    #pragma omp single\n    printf(\"Sum is %d\\n\", a);\n  }\n\n  return 0;\n}\n",
        "data_race": 1
    },
    {
        "id": 138,
        "trimmed_code": "#include <stdio.h>\n#include <omp.h>\n\nint main(){\n  int a, i;\n\n  #pragma omp parallel shared(a) private(i)\n  {\n    #pragma omp master\n    a = 0;\n\n    #pragma omp barrier\n\n    #pragma omp for reduction(+:a)\n    for (i=0; i<10; i++){\n      a += i;\n    }\n\n    #pragma omp single\n    printf(\"Sum is %d\\n\", a);\n  }\n\n  return 0;\n}\n",
        "data_race": 0
    },
    {
        "id": 139,
        "trimmed_code": "#include <stdio.h>\n#include <omp.h>\n\nint main(){\n\n  int x = 0, y;\n\n  #pragma omp parallel num_threads(2)\n  {\n    int thrd = omp_get_thread_num();\n    if (thrd == 0) {\n      #pragma omp critical\n      { x = 10; }\n      #pragma omp atomic write\n      y = 1;\n    } else {\n      int tmp = 0;\n      while (tmp == 0) {\n        #pragma omp atomic read acquire\n        tmp = y;\n    }\n    #pragma omp critical\n    { if (x!=10) printf(\"x = %d\\n\", x); }\n    }\n  }\n  return 0;\n}\n",
        "data_race": 1
    },
    {
        "id": 140,
        "trimmed_code": "#include <stdio.h>\n#include <omp.h>\n\nint main(){\n\n  int x = 0, y;\n\n  #pragma omp parallel num_threads(2)\n  {\n  int thrd = omp_get_thread_num();\n  if (thrd == 0) {\n    #pragma omp critical\n    { x = 10; }\n\n    #pragma omp flush(x)\n\n    #pragma omp atomic write\n    y = 1;\n  } else {\n      int tmp = 0;\n      while (tmp == 0) {\n      #pragma omp atomic read acquire\n      tmp = y;\n      }\n    #pragma omp critical\n    { if (x!=10) printf(\"x = %d\\n\", x); }\n  }\n  }\n  return 0;\n}\n",
        "data_race": 0
    },
    {
        "id": 141,
        "trimmed_code": "#include <stdio.h>\n#include <omp.h>\n#define N 100\n\nint var = 0;\n\nint main(){\n  #pragma omp target map(tofrom:var) device(0)\n  #pragma omp teams distribute parallel for\n  for(int i=0; i<N*2; i++){\n    #pragma omp critical\n    var++;\n  }\n\n  printf(\"%d\\n \",var);\n\n  return 0;\n}\n",
        "data_race": 1
    },
    {
        "id": 142,
        "trimmed_code": "#include <stdio.h>\n#include <omp.h>\n#define N 100\n\nint var = 0;\n\nint main(){\n  #pragma omp target map(tofrom:var) device(0)\n  #pragma omp teams distribute parallel for reduction(+:var)\n  for (int i=0; i<N; i++){\n    var++;\n  }\n\n  printf(\"%d\\n\",var);\n  return 0;\n}\n",
        "data_race": 0
    },
    {
        "id": 143,
        "trimmed_code": "#include <stdio.h>\n#include <omp.h>\n#define N 100\n\nint var = 0;\n\nint main(){\n  #pragma omp target map(tofrom:var) device(0)\n  #pragma omp teams distribute\n  for (int i=0; i<N; i++){\n    #pragma omp atomic update\n    var++;\n  }\n  printf(\"%d\\n \",var);\n  return 0;\n}\n",
        "data_race": 0
    },
    {
        "id": 144,
        "trimmed_code": "#include <omp.h>\n#include <stdio.h>\n\n#define N 100\n\nint var = 0;\n\nint main(){\n\n  #pragma omp target map(tofrom:var) device(0)\n  #pragma omp teams distribute parallel for\n  for(int i=0; i<N; i++){\n    #pragma omp atomic\n    var++;\n\n    #pragma omp atomic\n    var -= 2;\n  }\n\n  printf(\"%d\\n\",var);\n  return 0;\n}\n",
        "data_race": 0
    },
    {
        "id": 145,
        "trimmed_code": "#include <omp.h>\n#include <stdio.h>\n\n#define N 100\n\nint var = 0;\n\nint main(){\n\n  #pragma omp target map(tofrom:var) device(0)\n  #pragma omp teams distribute parallel for\n  for(int i=0; i<N; i++){\n    #pragma omp critical(addlock)\n    var++;\n\n    #pragma omp critical(sublock)\n    var -= 2;\n  }\n\n  printf(\"%d\\n\",var);\n\n  return 0;\n}\n",
        "data_race": 1
    },
    {
        "id": 146,
        "trimmed_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <omp.h>\n#define C 100\n\nint *a;\nint *b;\nint *c;\n\nint main(){\n  a = malloc(C*sizeof(int));\n  b = malloc(C*C*sizeof(int));\n  c = malloc(C*sizeof(int));\n\n  for(int i=0; i<C; i++){\n    for(int j=0; j<C; j++){\n      b[j+i*C]=1;\n    }\n    a[i]=1;\n    c[i]=0;\n  }\n\n  #pragma omp target map(to:a[0:C],b[0:C*C]) map(tofrom:c[0:C]) device(0)\n  {\n    #pragma omp teams distribute parallel for\n    for(int i=0; i<C; i++){\n      for(int j=0; j<C; j++){\n        c[i]+=b[j+i*C]*a[j];\n      }\n    }\n  }\n\n  for(int i=0; i<C; i++){\n    if(c[i]!=C){\n      printf(\"Data Race\\n\");\n      return 1;\n    }\n  }\n\n  free(a);\n  free(b);\n  free(c);\n\n  return 0;\n}\n",
        "data_race": 0
    },
    {
        "id": 147,
        "trimmed_code": "#include <omp.h>\n#include <stdio.h>\n\nint main(){\n\n  omp_lock_t lck;\n  int var=0,i;\n  omp_init_lock(&lck);\n\n  #pragma omp target map(tofrom:var) device(0)\n  #pragma omp teams distribute parallel for\n  for (int i=0; i<100; i++){\n    omp_set_lock(&lck);\n    var++;\n    omp_unset_lock(&lck);\n  }\n\n  omp_destroy_lock(&lck);\n\n  printf(\"%d\\n\",var);\n  return 0;\n}\n",
        "data_race": 1
    },
    {
        "id": 148,
        "trimmed_code": "#include <omp.h>\n#include <stdio.h>\n\nint main(){\n\n  int var=0,i;\n\n  #pragma omp target map(tofrom:var) device(0)\n  #pragma omp teams distribute parallel for\n  for (int i=0; i<100; i++){\n    var++;\n  }\n\n  printf(\"%d\\n\",var);\n  return 0;\n}\n",
        "data_race": 1
    },
    {
        "id": 149,
        "trimmed_code": "#include <stdio.h>\n#include <omp.h>\n#define N 100\n\nint main(){\n  omp_lock_t lck;\n  int var=0;\n  omp_init_lock(&lck);\n\n  #pragma omp target map(tofrom:var) device(0)\n  #pragma omp teams num_teams(1)\n  #pragma omp distribute parallel for\n  for (int i=0; i<N; i++){\n    omp_set_lock(&lck);\n    var++;\n    omp_unset_lock(&lck);\n  }\n\n  omp_destroy_lock(&lck);\n  printf(\"%d\\n\",var);\n  return 0;\n}\n",
        "data_race": 0
    },
    {
        "id": 150,
        "trimmed_code": "#include <stdio.h>\n#include <omp.h>\n#define N 100\n\nint main(){\n  int var = 0;\n\n  #pragma omp target map(tofrom:var) device(0)\n  #pragma omp teams num_teams(1)\n  #pragma omp distribute parallel for\n  for (int i=0; i<N; i++){\n    var++;\n  }\n\n  printf(\"%d\\n \",var);\n  return 0;\n}\n",
        "data_race": 1
    },
    {
        "id": 151,
        "trimmed_code": "#include <stdio.h>\n#include <omp.h>\n\nint main(){\n  omp_lock_t lck;\n  int var = 0;\n  omp_init_lock(&lck);\n\n  #pragma omp target map(tofrom:var) device(0)\n  #pragma omp teams distribute reduction(+:var)\n  for (int i=0; i<100; i++){\n    omp_set_lock(&lck);\n    var++;\n    omp_unset_lock(&lck);\n  }\n\n  omp_destroy_lock(&lck);\n  printf(\"%d\\n \",var);\n  return 0;\n}\n",
        "data_race": 0
    },
    {
        "id": 152,
        "trimmed_code": "#include <stdio.h>\n#include <omp.h>\n#include <stdlib.h>\n#define N 100\n\nint main(){\n\n  int var[N];\n\n  for(int i=0; i<N; i++){\n    var[i]=0;\n  }\n\n  #pragma omp target map(tofrom:var[0:N]) device(0)\n    #pragma omp parallel for ordered\n    for (int i=1; i<N; i++){\n      #pragma omp ordered\n      {\n        var[i]=var[i-1]+1;\n      }\n    }\n\n  for(int i=0; i<N; i++){\n    if(var[i]!=i){\n      printf(\"Data Race Present\");\n      return 0;\n    }\n  }\n\n  return 0;\n}\n",
        "data_race": 0
    },
    {
        "id": 153,
        "trimmed_code": "#include <stdio.h>\n#include <omp.h>\n#include <stdlib.h>\n#define N 100\n\nint main(){\n  int var[N];\n  for(int i=0; i<N; i++){\n    var[i]=0;\n  }\n\n  #pragma omp target map(tofrom:var[0:N]) device(0)\n  #pragma omp teams distribute parallel for\n  for (int i=1; i<N; i++){\n    var[i]=var[i-1]+1;\n  }\n\n  for(int i=0; i<N; i++){\n    if(var[i]!=i){\n      printf(\"Data Race Present\\n\");\n      return 0;\n    }\n  }\n  return 0;\n}\n",
        "data_race": 1
    },
    {
        "id": 154,
        "trimmed_code": "#include <stdio.h>\n#include <omp.h>\n#include <stdlib.h>\n#define N 100\n#define C 16\n\nint main(){\n  int var[N];\n\n  for(int i=0; i<N; i++){\n    var[i]=0;\n  }\n\n  #pragma omp target map(tofrom:var[0:N]) device(0)\n  #pragma omp teams distribute parallel for simd safelen(C)\n  for (int i=C; i<N; i++){\n    var[i]=var[i-C]+1;\n  }\n\n  printf(\"%d\\n\",var[97]);\n\n  return 0;\n}\n",
        "data_race": 1
    },
    {
        "id": 155,
        "trimmed_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <omp.h>\n#define C 64\n\nfloat a;\nfloat x[C];\nfloat y[C];\n\nint main(){\n  for(int i=0; i<C; i++){\n    a=5;\n    x[i]=0;\n    y[i]=3;\n  }\n\n  #pragma omp target map(to:y[0:C],a) map(tofrom:x[0:C]) device(0)\n  {\n    for(int i=0; i<C; i++){\n      #pragma omp task depend(inout:x[i])\n      {\n        x[i] = a * x[i];\n      }\n      #pragma omp task depend(inout:x[i])\n      {\n        x[i] = x[i] + y[i];\n      }\n    }\n  }\n\n  for(int i=0; i<C; i++){\n    if(x[i]!=3){\n      printf(\"Data Race Detected\\n\");\n      return 0;\n    }\n  }\n\n  #pragma omp taskwait\n  return 0;\n}\n",
        "data_race": 0
    },
    {
        "id": 156,
        "trimmed_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <omp.h>\n#define N 100\n#define C 8\n\n\nint a;\nint b[C];\nint c[C];\nint temp[C];\n\nint main(){\n  for(int i=0; i<C; i++){\n    b[i]=0;\n    c[i]=2;\n    temp[i]=0;\n  }\n  a=2;\n\n  #pragma omp target map(tofrom:b[0:C]) map(to:c[0:C],temp[0:C],a) device(0)\n  #pragma omp parallel\n  {\n    for(int i=0; i<N ;i++){\n      #pragma omp for\n      for(int i=0; i<C; i++){\n        temp[i] = b[i] + c[i];\n      }\n\n      #pragma omp for\n      for(int i=C-1; i>=0; i--){\n        b[i] = temp[i] * a;\n      }\n    }\n  }\n\n  int val = 0;\n\n  for(int i=0; i<N; i++){\n    val = val + 2;\n    val = val * 2;\n  }\n\n  for(int i=0; i<C; i++){\n    if(b[i]!=val){\n      printf(\"expected %d real %d \\n\",val, b[i]);\n      return 0;\n    }\n  }\n\n  return 0;\n}\n",
        "data_race": 0
    },
    {
        "id": 157,
        "trimmed_code": "#include <stdio.h>\n#include <omp.h>\n#include <stdlib.h>\n#define N 100\n#define C 16\n\n\nint a;\nint b[C];\nint c[C];\nint temp[C];\n\nint main(){\n  for(int i=0; i<C; i++){\n    b[i]=0;\n    c[i]=2;\n    temp[i]=0;\n  }\n  a=2;\n\n  #pragma omp target map(tofrom:b[0:C]) map(to:c[0:C],temp[0:C],a) device(0)\n  {\n    #pragma omp teams\n    for(int i=0; i<N ;i++){\n      #pragma omp distribute\n      for(int i=0; i<C; i++){\n        temp[i] = b[i] + c[i];\n      }\n\n      #pragma omp distribute\n      for(int i=C-1; i>=0; i--){\n        b[i] = temp[i] * a;\n      }\n    }\n  }\n\n  int val = 0;\n\n  for(int i=0; i<N; i++){\n    val = val + 2;\n    val = val * 2;\n  }\n\n  for(int i=0; i<C; i++){\n    if(b[i]!=val){\n      printf(\"index: %d val: %d\\n\",i, b[i]);\n    }\n  }\n\n  return 0;\n}\n",
        "data_race": 1
    },
    {
        "id": 158,
        "trimmed_code": "#include <stdio.h>\n#define N 20\n#define C 8\n\nint main(){\n  int var[C];\n\n  for(int i=0; i<C; i++){\n    var[i] = 0;\n  }\n\n  #pragma omp target map(tofrom:var) device(0)\n  #pragma omp teams num_teams(1) thread_limit(1048) \n  #pragma omp distribute parallel for \n  for (int i=0; i<N; i++){\n    #pragma omp simd\n    for(int i=0; i<C; i++){\n      var[i]++;\n    }\n  }\n\n  for(int i=0; i<C; i++){\n    if(var[i]!=N) printf(\"%d\\n \",var[i]);\n  }\n\n  return 0;\n}\n",
        "data_race": 1
    },
    {
        "id": 159,
        "trimmed_code": "#include <stdio.h>\n#define N 20\n#define C 8\n\nint main(){\n  int var[C];\n\n  for(int i=0; i<C; i++){\n    var[i] = 0;\n  }\n\n  #pragma omp target map(tofrom:var) device(0)\n  #pragma omp teams num_teams(1) thread_limit(1048) \n  #pragma omp distribute parallel for reduction(+:var)\n  for (int i=0; i<N; i++){\n    #pragma omp simd\n    for(int i=0; i<C; i++){\n      var[i]++;\n    }\n  }\n\n  for(int i=0; i<C; i++){\n    if(var[i]!=N) printf(\"%d\\n \",var[i]);\n  }\n\n  return 0;\n}\n",
        "data_race": 0
    },
    {
        "id": 160,
        "trimmed_code": "#include <stdio.h>\n#include <omp.h>\n#define N 100\n#define C 64\n\nint main(){\n  int var[C];\n\n  for(int i=0; i<C; i++){\n    var[i]=0;\n  }\n\n  #pragma omp target map(tofrom:var[0:C]) device(0)\n  #pragma omp teams distribute parallel for reduction(+:var) \n  for (int i=0; i<N; i++){\n    #pragma omp simd\n    for(int i=0; i<C; i++){\n      var[i]++;\n    }\n  }\n\n  for(int i=0; i<C; i++){\n    if(var[i]!=100){\n      printf(\"%d\\n\",var[i]);\n    }\n  }\n\n  return 0;\n}\n",
        "data_race": 0
    },
    {
        "id": 161,
        "trimmed_code": "#include <stdio.h>\n#include <omp.h>\n#define N 100\n#define C 64\n\nint main(){\n\n  int var[C];\n\n  for(int i=0; i<C; i++){\n    var[i]=0;\n  }\n\n  #pragma omp target map(tofrom:var[0:C]) device(0)\n  #pragma omp teams distribute parallel for\n  for (int i=0; i<N; i++){\n    #pragma omp simd\n    for(int i=0; i<C; i++){\n      var[i]++;\n    }\n  }\n\n  printf(\"%d\\n\",var[63]);\n\n  return 0;\n}\n",
        "data_race": 1
    },
    {
        "id": 162,
        "trimmed_code": "#include <stdio.h>\n#include <omp.h>\n\nvoid foo(){\n\n  int x = 0, y = 2;\n\n  #pragma omp task depend(inout: x) shared(x)\n  x++;                                                \n\n  #pragma omp task shared(y)\n  y--;                                                \n\n  #pragma omp taskwait depend(in: x)                  \n\n  printf(\"x=%d\\n\",x);\n  printf(\"y=%d\\n\",y);\n  #pragma omp taskwait                                \n}\n\n\nint main(){\n  #pragma omp parallel\n  #pragma omp single\n  foo();\n\n  return 0;\n}\n",
        "data_race": 1
    },
    {
        "id": 163,
        "trimmed_code": "#include <stdio.h>\n#include <omp.h>\n\nvoid foo(){\n\n  int x = 0, y = 2;\n\n  #pragma omp task depend(inout: x) shared(x)\n  x++;                                                \n\n  #pragma omp task shared(y)\n  y--;                                                \n\n  #pragma omp taskwait depend(in: x)                  \n\n  printf(\"x=%d\\n\",x);\n\n  #pragma omp taskwait                                \n\n  printf(\"y=%d\\n\",y);\n}\n\n\nint main(){\n  #pragma omp parallel\n  #pragma omp single\n  foo();\n\n  return 0;\n}\n\n",
        "data_race": 0
    },
    {
        "id": 164,
        "trimmed_code": "#include <stdio.h>\n#include <omp.h>\n\nvoid foo(){\n  int x = 0, y = 2;\n\n  #pragma omp task depend(inout: x) shared(x)\n  x++;                                                                  \n\n  #pragma omp task depend(in: x) depend(inout: y) shared(x, y)\n  y = y-x;                                                              \n\n  #pragma omp taskwait depend(in: x)                                    \n\n  printf(\"x=%d\\n\",x);\n\n  #pragma omp taskwait                                                  \n\n  printf(\"y=%d\\n\",y);\n}\n\nint main(){\n  #pragma omp parallel\n  #pragma omp single\n  foo();\n\n  return 0;\n}\n\n",
        "data_race": 0
    },
    {
        "id": 165,
        "trimmed_code": "#include <stdio.h>\n#include <omp.h>\n\nvoid foo(){\n  int x = 0, y = 2;\n\n  #pragma omp task depend(inout: x) shared(x)\n  x++;                                                             \n\n  #pragma omp task depend(in: x) depend(inout: y) shared(x, y)\n  y -= x;                                                         \n\n  #pragma omp taskwait depend(in: x)                               \n\n  printf(\"x=%d\\n\",x);\n  printf(\"y=%d\\n\",y);\n\n  #pragma omp taskwait\t\t                                         \n\n}\n\nint main(){\n  #pragma omp parallel\n  #pragma omp single\n  foo();\n\n  return 0;\n}\n\n",
        "data_race": 1
    },
    {
        "id": 166,
        "trimmed_code": "#include <stdio.h>\n#include <omp.h>\n\n#define N 8\n\nint main()\n{\n  int i,j,k;\n  double r1[N], r[N][N][N];\n\n  for (i = 0; i < N; i++) {\n    for (j = 0; j < N; j++) {\n      for (k = 0; k < N; k++) {\n        r[i][j][k] = i;\n      }\n    }\n  }\n\n\n  #pragma omp parallel for default(shared) private(j,k)\n  for (i = 1; i < N-1; i++) {\n    for (j = 1; j < N-1; j++) {\n      for (k = 0; k < N; k++) {\n        r1[k] = r[i][j-1][k] + r[i][j+1][k] + r[i-1][j][k] + r[i+1][j][k];\n      }\n    }\n  }\n\n  for (k = 0; k < N; k++) printf(\"%f \",r1[k]);\n\n  printf(\"\\n\");\n\n  return 0;\n}\n\n",
        "data_race": 1
    },
    {
        "id": 167,
        "trimmed_code": "#include <stdio.h>\n#include <omp.h>\n\nint main(){\n  int i,j,k,m;\n  double tmp1;\n\n  double a[12][12][12];\n\n  m = 3.0;\n\n  #pragma omp parallel for private(j,k,tmp1)   \n  for (i = 0; i < 12; i++) {\n    for (j = 0; j < 12; j++) {\n      for (k = 0; k < 12; k++) {\n        tmp1 = 6.0/m;\n        a[i][j][k] = tmp1+4;\n      }\n    }\n  }\n\n  return 0;\n}\n\n",
        "data_race": 0
    },
    {
        "id": 168,
        "trimmed_code": "#include <omp.h>\n#include <stdio.h>\n\nstatic double x[20];\n#pragma omp threadprivate(x)\n\nint main(){\n  int i;\n  double j,k;\n\n  #pragma omp parallel for default(shared)\n  for (i = 0; i < 20; i++){\n    x[i] = -1.0;\n    if(omp_get_thread_num()==0){\n      j = x[0];\n    }\n    if(omp_get_thread_num()==0){\n      k = i+0.05;\n    }\n  }\n\n  printf (\"%f %f\\n\", j, k);\n\n  return 0;\n}\n\n",
        "data_race": 0
    },
    {
        "id": 169,
        "trimmed_code": "#include <omp.h>\n#include <stdio.h>\n\nint main(){\n  int i;\n  double q[10], qq[10];\n\n  for (i = 0; i < 10; i++) qq[i] = (double)i;\n  for (i = 0; i < 10; i++) q[i] = (double)i;\n\n  #pragma omp parallel default(shared)\n  {\n    #pragma omp for private(i)\n    for (i = 0; i < 10; i++)\n      q[i] += qq[i];\n\n    #pragma omp critical\n    {\n      q[9] += 1.0;\n    }\n    #pragma omp barrier\n    #pragma omp single\n    {\n      q[9] = q[9] - 1.0;\n    }\n\n  } \n\n  for (i = 0; i < 10; i++)printf(\"%f %f\\n\",qq[i],q[i]);\n\n  return 0;\n}\n\n",
        "data_race": 0
    },
    {
        "id": 170,
        "trimmed_code": "#include <omp.h>\n#include <stdio.h>\n\nvoid foo() {\n  int a = 0;\n\n#pragma omp parallel\n#pragma omp single\n  {\n#pragma omp task depend(inout : a) shared(a)\n    {\n#pragma omp task depend(inout : a) shared(a)\n      a++;\n    }\n\n#pragma omp task depend(inout : a) shared(a)\n    {\n#pragma omp task depend(inout : a) shared(a)\n      a++;\n    }\n  }\n\n  printf(\"a=%d\\n\", a);\n}\n\nint main() {\n  foo();\n\n  return 0;\n}\n",
        "data_race": 1
    },
    {
        "id": 171,
        "trimmed_code": "#include <omp.h>\n#include <stdio.h>\n\nvoid foo() {\n  int a = 0;\n\n#pragma omp parallel\n#pragma omp single\n  {\n#pragma omp task depend(inout : a) shared(a)\n    {\n#pragma omp task depend(inout : a) shared(a)\n      a++;\n#pragma omp taskwait\n    }\n\n#pragma omp task depend(inout : a) shared(a)\n    {\n#pragma omp task depend(inout : a) shared(a)\n      a++;\n#pragma omp taskwait\n    }\n  }\n\n  printf(\"a=%d\\n\", a);\n}\n\nint main() {\n  foo();\n\n  return 0;\n}\n",
        "data_race": 0
    },
    {
        "id": 172,
        "trimmed_code": "#include <omp.h>\n#include <stdio.h>\n\nvoid foo() {\n  int a = 0;\n\n#pragma omp parallel\n  {\n#pragma omp task depend(inout : a) shared(a)\n    a++;\n  }\n  printf(\"a=%d\\n\", a);\n}\n\nint main() {\n  foo();\n\n  return 0;\n}\n",
        "data_race": 1
    },
    {
        "id": 173,
        "trimmed_code": "#include <stdio.h>\n#include <stdlib.h>\n\nint fib(int n) {\n  int i, j, s;\n  if (n < 2)\n    return n;\n#pragma omp task shared(i) depend(out : i)\n  i = fib(n - 1);\n#pragma omp task shared(j) depend(out : j)\n  j = fib(n - 2);\n#pragma omp task shared(i, j) depend(in : i, j)\n  s = i + j;\n#pragma omp taskwait\n  return i + j;\n}\n\nint main(int argc, char **argv) {\n  int n = 10;\n  if (argc > 1)\n    n = atoi(argv[1]);\n#pragma omp parallel sections\n  { printf(\"fib(%i) = %i\\n\", n, fib(n)); }\n  return 0;\n}\n",
        "data_race": 0
    },
    {
        "id": 174,
        "trimmed_code": "#include <stdio.h>\n#include <stdlib.h>\n\nint fib(int n) {\n  int i, j, s;\n  if (n < 2)\n    return n;\n#pragma omp task shared(i) depend(out : i)\n  i = fib(n - 1);\n#pragma omp task shared(j) depend(out : j)\n  j = fib(n - 2);\n#pragma omp task shared(i, j) depend(in : j)\n  s = i + j;\n#pragma omp taskwait\n  return i + j;\n}\n\nint main(int argc, char **argv) {\n  int n = 10;\n  if (argc > 1)\n    n = atoi(argv[1]);\n#pragma omp parallel sections\n  { printf(\"fib(%i) = %i\\n\", n, fib(n)); }\n  return 0;\n}\n",
        "data_race": 1
    },
    {
        "id": 175,
        "trimmed_code": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid load_from_input(int *data, int size)\n{\n  for(int i = 0; i < size; i++) {\n    data[i] = size-i;\n  } \n}\n\n\nint main(int argc, char *argv[]) {\n\n  int *A; \n  int N = 100;\n\n  if (argc>1)\n    N = atoi(argv[1]);\n\n  A = (int*) malloc(sizeof(int) * N);\n\n  load_from_input(A, N);\n  \n#pragma omp parallel for shared(A)\n  for(int i = 0; i < N; i++) {\n    A[i] = i;\n    if (N > 10000) \n    { \n      A[0] = 1; \n    }\n  }\n\n  free(A);\n  return 0;\n}\n",
        "data_race": 1
    },
    {
        "id": 176,
        "trimmed_code": "#include <stdio.h>\n#include <stdlib.h>\n\n\nint main(int argc, char *argv[]) {\n\n  int *A; \n  int N = 100;\n\n  A = (int*) malloc(sizeof(int) * N);\n\n  \n#pragma omp parallel for shared(A)\n  for(int i = 0; i < N; i++) {\n    A[i] = i;\n    if (i == 1) \n    { \n      A[0] = 1; \n    }\n  }\n\n  free(A);\n  return 0;\n}\n",
        "data_race": 1
    },
    {
        "id": 177,
        "trimmed_code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef long long num_sz;\n\nint max_num_blocks;\nint num_refine;\nint num_vars;\nint x_block_size, y_block_size, z_block_size;\nint error_tol;\n\ndouble tol;\n\ntypedef struct {\n   num_sz number;\n   int level;\n   int refine;\n   int new_proc;\n   num_sz parent;       \n                     \n                     \n   double ****array;\n} block;\n\nblock *blocks;\n\nvoid stencil_calc(int var, int stencil_in)\n{\n   int i, j, k, in;\n   double sb, sm, sf, work[x_block_size+2][y_block_size+2][z_block_size+2];\n   block *bp;\n\n   int tid;\n\n#pragma omp parallel default(shared) private(i, j, k, bp)\n  {\n      for (in = 0; in < max_num_blocks; ++in) {\n         bp = &blocks[in];\n         for (i = 1; i <= x_block_size; i++)\n            for (j = 1; j <= y_block_size; j++)\n               for (k = 1; k <= z_block_size; k++)\n                  work[i][j][k] = (bp->array[var][i-1][j  ][k  ] +\n                                   bp->array[var][i  ][j-1][k  ] +\n                                   bp->array[var][i  ][j  ][k-1] +\n                                   bp->array[var][i  ][j  ][k  ] +\n                                   bp->array[var][i  ][j  ][k+1] +\n                                   bp->array[var][i  ][j+1][k  ] +\n                                   bp->array[var][i+1][j  ][k  ])/7.0;\n         for (i = 1; i <= x_block_size; i++)\n            for (j = 1; j <= y_block_size; j++)\n               for (k = 1; k <= z_block_size; k++)\n                  bp->array[var][i][j][k] = work[i][j][k];\n      }\n  }\n}\n\n\nvoid allocate(void)\n{\n   int i, j, k, m, n;\n\n   blocks = (block *) malloc(max_num_blocks*sizeof(block));\n\n   for (n = 0; n < max_num_blocks; n++) {\n      blocks[n].number = -1;\n      blocks[n].array = (double ****) malloc(num_vars*sizeof(double ***));\n      for (m = 0; m < num_vars; m++) {\n         blocks[n].array[m] = (double ***)\n                              malloc((x_block_size+2)*sizeof(double **));\n         for (i = 0; i < x_block_size+2; i++) {\n            blocks[n].array[m][i] = (double **)\n                                   malloc((y_block_size+2)*sizeof(double *));\n            for (j = 0; j < y_block_size+2; j++)\n               blocks[n].array[m][i][j] = (double *)\n                                     malloc((z_block_size+2)*sizeof(double));\n         }\n      }\n   }\n}\n\nvoid deallocate(void)\n{\n   int i, j, m, n;\n\n   for (n = 0; n < max_num_blocks; n++) {\n      for (m = 0; m < num_vars; m++) {\n         for (i = 0; i < x_block_size+2; i++) {\n            for (j = 0; j < y_block_size+2; j++)\n               free(blocks[n].array[m][i][j]);\n            free(blocks[n].array[m][i]);\n         }\n         free(blocks[n].array[m]);\n      }\n      free(blocks[n].array);\n   }\n   free(blocks);\n}\n\nvoid init(void)\n{\n   int n, var, i, j, k, l, m, o, size, dir, i1, i2, j1, j2, k1, k2, ib, jb, kb;\n   num_sz num;\n   block *bp;\n\n\n   \n   \n   for (o = n = k1 = k = 0; k < 1; k++)\n      for (k2 = 0; k2 < 1; k1++, k2++)\n         for (j1 = j = 0; j < 1; j++)\n            for (j2 = 0; j2 < 1; j1++, j2++)\n               for (i1 = i = 0; i < 1; i++)\n                  for (i2 = 0; i2 < 1; i1++, i2++, n++) {\n                     bp = &blocks[o];\n                     bp->level = 0;\n                     bp->number = n;\n                     \n                     for (var = 0; var < num_vars; var++)\n                        for (ib = 1; ib <= x_block_size; ib++)\n                           for (jb = 1; jb <= y_block_size; jb++)\n                              for (kb = 1; kb <= z_block_size; kb++)\n                                 bp->array[var][ib][jb][kb] =\n                                    ((double) rand())/((double) RAND_MAX);\n                    o++;\n                  }\n}\n\n\n\nvoid driver(void)\n{\n  int start, number, var;\n\n  init();\n\n  for (var = 0; var < num_vars; var ++) {\n     stencil_calc(var, 7);\n  }\n}\n\n\nint main(int argc, char* argv[])\n{   \n  max_num_blocks = 500;\n  num_refine = 5;\n  num_vars = 40;\n  x_block_size = 10;\n  y_block_size = 10;\n  z_block_size = 10;\n\n  allocate();\n \n  driver();\n\n  deallocate();\n  return 0;\n} \n",
        "data_race": 1
    },
    {
        "id": 178,
        "trimmed_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <omp.h>\n#include <time.h>\n\n\n\n#define PATH -1\n#define NONE 0\n#define UP 1\n#define LEFT 2\n#define DIAGONAL 3\n\n\n\n#define min(x, y) (((x) < (y)) ? (x) : (y))\n#define max(a,b) ((a) > (b) ? a : b)\n\n\n\n\n\n\nlong long int m ; \nlong long int n ;  \n\n\nint matchScore = 5;\nint missmatchScore = -3;\nint gapScore = -4;\n\n\nchar *a, *b;\n\n\nvoid generate() {\n    \n    srand(time(NULL));\n\n    \n    long long int i;\n    for (i = 0; i < m; i++) {\n        int aux = rand() % 4;\n        if (aux == 0)\n            a[i] = 'A';\n        else if (aux == 2)\n            a[i] = 'C';\n        else if (aux == 3)\n            a[i] = 'G';\n        else\n            a[i] = 'T';\n    }\n\n    \n    for (i = 0; i < n; i++) {\n        int aux = rand() % 4;\n        if (aux == 0)\n            b[i] = 'A';\n        else if (aux == 2)\n            b[i] = 'C';\n        else if (aux == 3)\n            b[i] = 'G';\n        else\n            b[i] = 'T';\n    }\n} \n\n\n\nlong long int nElement(long long int i) {\n    if (i < m && i < n) {\n        \n        return i;\n    }\n    else if (i < max(m, n)) {\n        \n        long long int min = min(m, n);\n        return min - 1;\n    }\n    else {\n        \n        long long int min = min(m, n);\n        return 2 * min - i + labs(m - n) - 2;\n    }\n}\n\n\nint matchMissmatchScore(long long int i, long long int j) {\n    if (a[j - 1] == b[i - 1])\n        return matchScore;\n    else\n        return missmatchScore;\n}  \n\n\nvoid similarityScore(long long int i, long long int j, int* H, int* P, long long int* maxPos) {\n\n    int up, left, diag;\n\n    \n    long long int index = m * i + j;\n\n    \n    up = H[index - m] + gapScore;\n\n    \n    left = H[index - 1] + gapScore;\n\n    \n    diag = H[index - m - 1] + matchMissmatchScore(i, j);\n\n    \n    int max = NONE;\n    int pred = NONE;\n    \n\n    if (diag > max) { \n        max = diag;\n        pred = DIAGONAL;\n    }\n\n    if (up > max) { \n        max = up;\n        pred = UP;\n    }\n\n    if (left > max) { \n        max = left;\n        pred = LEFT;\n    }\n    \n    H[index] = max;\n    P[index] = pred;\n\n    \n    if (max > H[*maxPos]) {        \n    #pragma omp critical\n        *maxPos = index;\n    }\n\n}  \n\n\nvoid calcFirstDiagElement(long long int *i, long long int *si, long long int *sj) {\n    \n    if (*i < n) {\n        *si = *i;\n        *sj = 1;\n    } else {\n        *si = n - 1;\n        *sj = *i - n + 2;\n    }\n}\n\n\nint main(int argc, char* argv[]) {\n    m = 2048;\n    n = 2048;\n\n#ifdef DEBUG\n    printf(\"\\nMatrix[%lld][%lld]\\n\", n, m);\n#endif\n\n    \n    a = malloc(m * sizeof(char));\n    b = malloc(n * sizeof(char));\n\n    \n    m++;\n    n++;\n\n    \n    int *H;\n    H = calloc(m * n, sizeof(int));\n\n    \n    int *P;\n    P = calloc(m * n, sizeof(int));\n\n\n    \n    generate();\n\n\n    \n    long long int maxPos = 0;\n    \n    long long int i, j;\n\n    \n    double initialTime = omp_get_wtime();\n\n    long long int si, sj, ai, aj;\n\n    \n    long long int nDiag = m + n - 3;\n    long long int nEle;\n\n    #pragma omp parallel \\\n    default(none) shared(H, P, maxPos, nDiag) private(nEle, i, si, sj, ai, aj)\n    {\n        for (i = 1; i <= nDiag; ++i)\n        {\n            nEle = nElement(i);\n            calcFirstDiagElement(&i, &si, &sj);\n            #pragma omp for\n            for (j = 1; j <= nEle; ++j)\n            {\n                ai = si - j + 1;\n                aj = sj + j - 1;\n                similarityScore(ai, aj, H, P, &maxPos);\n            }\n        }\n    }\n}\n",
        "data_race": 1
    },
    {
        "id": 179,
        "trimmed_code": "#include <stdio.h>\n\nint main()\n{\n  int x = 0, s = 0;\n#pragma omp parallel sections shared(x, s) num_threads(2)\n  {\n#pragma omp section\n    {\n      x = 1;\n#pragma omp atomic write seq_cst\n      s = 1;\n    }\n#pragma omp section\n    {\n      int done = 0;\n      while (!done)\n      {\n#pragma omp atomic read seq_cst\n        done = s;\n      }\n      x = 2;\n    }\n  }\n  printf(\"%d\\n\", x);\n}\n",
        "data_race": 0
    },
    {
        "id": 180,
        "trimmed_code": "#include <stdio.h>\n\nint main()\n{\n  int x = 0, s = 0;\n#pragma omp parallel sections shared(x, s) num_threads(2)\n  {\n#pragma omp section\n    {\n      x = 1;\n      s = 1;\n    }\n#pragma omp section\n    {\n      int done = 0;\n      while (!done)\n      {\n#pragma omp atomic read seq_cst\n        done = s;\n      }\n      x = 2;\n    }\n  }\n  printf(\"%d\\n\", x);\n}\n",
        "data_race": 1
    },
    {
        "id": 181,
        "trimmed_code": "#include <stdio.h>\n#include <omp.h>\n#include <assert.h>\n\ntypedef _Bool flag_t;\n\nflag_t f0, f1;\nconst int n = 100;\nint x = 1;\n\nvoid init(flag_t *f)\n{\n  *f = 0;\n}\n\nvoid raise(flag_t *f)\n{\n#pragma omp critical\n  {\n    assert(*f == 0);\n    *f = 1;\n  }\n}\n\nvoid lower(flag_t *f)\n{\n  _Bool done = 0;\n  while (!done)\n  {\n#pragma omp critical\n    if (*f == 1)\n    {\n      *f = 0;\n      done = 1;\n    }\n  }\n}\n\nvoid mybarrier(int tid)\n{\n  if (tid == 0)\n  {\n    raise(&f0);\n    lower(&f1);\n  }\n  else if (tid == 1)\n  {\n    lower(&f0);\n    raise(&f1);\n  }\n}\n\nint main()\n{\n  init(&f0);\n  init(&f1);\n#pragma omp parallel num_threads(2)\n  {\n    int tid = omp_get_thread_num();\n#pragma omp barrier\n    for (int i = 0; i < n; i++)\n    {\n      printf(\"Thread %d: phase 1, i=%d, x=%d\\n\", tid, i, x);\n      fflush(stdout);\n      assert(x == 1);\n      mybarrier(tid);\n      if (tid == 0)\n        x = 0;\n      mybarrier(tid);\n      printf(\"Thread %d: phase 3, i=%d, x=%d\\n\", tid, i, x);\n      fflush(stdout);\n      assert(x == 0);\n      mybarrier(tid);\n      if (tid == 1)\n        x = 1;\n      mybarrier(tid);\n    }\n  } \n  printf(\"Done: x=%d\\n\", x);\n}",
        "data_race": 0
    },
    {
        "id": 182,
        "trimmed_code": "#include <stdio.h>\n#include <omp.h>\n#include <assert.h>\n\ntypedef _Bool flag_t;\n\nflag_t f0, f1;\nconst int n = 2;\nint x = 1;\n\nvoid init(flag_t *f)\n{\n  *f = 0;\n}\n\nvoid raise(flag_t *f)\n{\n#pragma omp critical\n  {\n    assert(*f == 0);\n    *f = 1;\n  }\n}\n\nvoid lower(flag_t *f)\n{\n  _Bool done = 0;\n  while (!done)\n  {\n#pragma omp critical\n    if (*f == 1)\n    {\n      *f = 0;\n      done = 1;\n    }\n  }\n}\n\nvoid mybarrier(int tid)\n{\n  if (tid == 0)\n  {\n    raise(&f0);\n    lower(&f0);\n  }\n  else if (tid == 1)\n  {\n    raise(&f1);\n    lower(&f1);\n  }\n}\n\nint main()\n{\n  init(&f0);\n  init(&f1);\n#pragma omp parallel num_threads(2)\n  {\n    int tid = omp_get_thread_num();\n#pragma omp barrier\n    for (int i = 0; i < n; i++)\n    {\n      printf(\"Thread %d: phase 1, i=%d, x=%d\\n\", tid, i, x);\n      fflush(stdout);\n      \n      mybarrier(tid);\n      if (tid == 0)\n        x = 0;\n      mybarrier(tid);\n      printf(\"Thread %d: phase 3, i=%d, x=%d\\n\", tid, i, x);\n      fflush(stdout);\n      \n      mybarrier(tid);\n      if (tid == 1)\n        x = 1;\n      mybarrier(tid);\n    }\n  } \n  printf(\"Done: x=%d\\n\", x);\n}\n",
        "data_race": 1
    },
    {
        "id": 183,
        "trimmed_code": "#include <stdio.h>\n#include <omp.h>\n#include <assert.h>\n\nomp_lock_t l0, l1;\nint x = 1;\n\nint main()\n{\n  omp_init_lock(&l0);\n  omp_init_lock(&l1);\n#pragma omp parallel num_threads(2)\n  {\n    int tid = omp_get_thread_num();\n    if (tid == 0)\n      omp_set_lock(&l0);\n    else if (tid == 1)\n      omp_set_lock(&l1);\n#pragma omp barrier\n    if (tid == 0)\n      x = 0;\n    if (tid == 0)\n    {\n      omp_unset_lock(&l0);\n      omp_set_lock(&l1);\n    }\n    else if (tid == 1)\n    {\n      omp_set_lock(&l0);\n      omp_unset_lock(&l1);\n    }\n    if (tid == 1)\n      x = 1;\n#pragma omp barrier\n    if (tid == 0)\n      omp_unset_lock(&l1);\n    else if (tid == 1)\n      omp_unset_lock(&l0);\n  } \n  omp_destroy_lock(&l0);\n  omp_destroy_lock(&l1);\n  printf(\"Done: x=%d\\n\", x);\n}\n",
        "data_race": 0
    },
    {
        "id": 184,
        "trimmed_code": "#include <stdio.h>\n#include <omp.h>\n#include <assert.h>\n\nomp_lock_t l0, l1;\nint x = 1;\n\nint main()\n{\n  omp_init_lock(&l0);\n  omp_init_lock(&l1);\n#pragma omp parallel num_threads(2)\n  {\n    int tid = omp_get_thread_num();\n    if (tid == 0)\n      omp_set_lock(&l0);\n    else if (tid == 1)\n      omp_set_lock(&l1);\n#pragma omp barrier\n    if (tid == 0)\n      x = 0;\n    if (tid == 0)\n    {\n      omp_unset_lock(&l0);\n      omp_set_lock(&l0);\n    }\n    else if (tid == 1)\n    {\n      omp_unset_lock(&l1);\n      omp_set_lock(&l1);\n    }\n    if (tid == 1)\n      x = 1;\n#pragma omp barrier\n    if (tid == 0)\n      omp_unset_lock(&l1);\n    else if (tid == 1)\n      omp_unset_lock(&l0);\n  } \n  omp_destroy_lock(&l0);\n  omp_destroy_lock(&l1);\n  printf(\"Done: x=%d\\n\", x);\n}\n",
        "data_race": 1
    },
    {
        "id": 185,
        "trimmed_code": "#include <stdio.h>\n#include <omp.h>\n#include <assert.h>\n\nomp_lock_t l0, l1, l2;\nconst int n = 100;\nint x = 1;\n\nvoid barrier_init()\n{\n  omp_init_lock(&l0);\n  omp_init_lock(&l1);\n  omp_init_lock(&l2);\n}\n\nvoid barrier_destroy()\n{\n  omp_destroy_lock(&l0);\n  omp_destroy_lock(&l1);\n  omp_destroy_lock(&l2);\n}\n\nvoid barrier_start(int tid)\n{\n  if (tid == 0)\n  {\n    omp_set_lock(&l0);\n    omp_set_lock(&l2);\n  }\n  else if (tid == 1)\n  {\n    omp_set_lock(&l1);\n  }\n}\n\nvoid barrier_stop(int tid)\n{\n  if (tid == 0)\n  {\n    omp_unset_lock(&l0);\n    omp_unset_lock(&l2);\n  }\n  else if (tid == 1)\n  {\n    omp_unset_lock(&l1);\n  }\n}\n\nvoid barrier_wait(int tid)\n{\n  if (tid == 0)\n  {\n    omp_unset_lock(&l0);\n    omp_set_lock(&l1);\n    omp_unset_lock(&l2);\n    omp_set_lock(&l0);\n    omp_unset_lock(&l1);\n    omp_set_lock(&l2);\n  }\n  else if (tid == 1)\n  {\n    omp_set_lock(&l0);\n    omp_unset_lock(&l1);\n    omp_set_lock(&l2);\n    omp_unset_lock(&l0);\n    omp_set_lock(&l1);\n    omp_unset_lock(&l2);\n  }\n}\n\nint main()\n{\n  barrier_init();\n#pragma omp parallel num_threads(2)\n  {\n    int tid = omp_get_thread_num();\n    barrier_start(tid);\n#pragma omp barrier\n    for (int i = 0; i < n; i++)\n    {\n      printf(\"Thread %d: phase 1, i=%d, x=%d\\n\", tid, i, x);\n      fflush(stdout);\n      assert(x == 1);\n      barrier_wait(tid);\n      if (tid == 0)\n        x = 0;\n      barrier_wait(tid);\n      printf(\"Thread %d: phase 3, i=%d, x=%d\\n\", tid, i, x);\n      fflush(stdout);\n      assert(x == 0);\n      barrier_wait(tid);\n      if (tid == 1)\n        x = 1;\n      barrier_wait(tid);\n    }\n#pragma omp barrier\n    barrier_stop(tid);\n  } \n  barrier_destroy();\n  printf(\"Done: x=%d\\n\", x);\n}\n",
        "data_race": 0
    },
    {
        "id": 186,
        "trimmed_code": "#include <stdio.h>\n#include <omp.h>\n#include <assert.h>\n\nomp_lock_t l0, l1, l2;\nconst int n = 2;\nint x = 1;\n\nvoid barrier_init()\n{\n  omp_init_lock(&l0);\n  omp_init_lock(&l1);\n  omp_init_lock(&l2);\n}\n\nvoid barrier_destroy()\n{\n  omp_destroy_lock(&l0);\n  omp_destroy_lock(&l1);\n  omp_destroy_lock(&l2);\n}\n\nvoid barrier_start(int tid)\n{\n  if (tid == 0)\n  {\n    omp_set_lock(&l0);\n    omp_set_lock(&l2);\n  }\n  else if (tid == 1)\n  {\n    omp_set_lock(&l1);\n  }\n}\n\nvoid barrier_stop(int tid)\n{\n  if (tid == 0)\n  {\n    omp_unset_lock(&l0);\n    omp_unset_lock(&l2);\n  }\n  else if (tid == 1)\n  {\n    omp_unset_lock(&l1);\n  }\n}\n\nvoid barrier_wait(int tid)\n{\n  if (tid == 0)\n  {\n    omp_unset_lock(&l0);\n    omp_set_lock(&l1);\n    \n    omp_set_lock(&l0);\n    omp_unset_lock(&l1);\n    \n  }\n  else if (tid == 1)\n  {\n    omp_set_lock(&l0);\n    omp_unset_lock(&l1);\n    \n    omp_unset_lock(&l0);\n    omp_set_lock(&l1);\n    \n  }\n}\n\nint main()\n{\n  barrier_init();\n#pragma omp parallel num_threads(2)\n  {\n    int tid = omp_get_thread_num();\n    barrier_start(tid);\n#pragma omp barrier\n    for (int i = 0; i < n; i++)\n    {\n      printf(\"Thread %d: phase 1, i=%d, x=%d\\n\", tid, i, x);\n      fflush(stdout);\n      \n      barrier_wait(tid);\n      if (tid == 0)\n        x = 0;\n      barrier_wait(tid);\n      printf(\"Thread %d: phase 3, i=%d, x=%d\\n\", tid, i, x);\n      fflush(stdout);\n      \n      barrier_wait(tid);\n      if (tid == 1)\n        x = 1;\n      barrier_wait(tid);\n    }\n#pragma omp barrier\n    barrier_stop(tid);\n  } \n  barrier_destroy();\n  printf(\"Done: x=%d\\n\", x);\n}\n",
        "data_race": 1
    },
    {
        "id": 187,
        "trimmed_code": "#include <stdio.h>\n\nint cap = 10, size = 0;\nunsigned r = 0;\n\nint main()\n{\n#pragma omp parallel sections shared(size, cap) firstprivate(r) num_threads(2)\n  {\n#pragma omp section\n    while (1)\n    {\n#pragma omp critical\n      {\n        if (size < cap)\n        {\n          size++; \n          printf(\"Produced! size=%d\\n\", size);\n          fflush(stdout);\n        }\n      }\n      for (int i = 0; i < 1000; i++)\n        r = (r + 1) % 10;\n    }\n#pragma omp section\n    while (1)\n    {\n#pragma omp critical\n      {\n        if (size > 0)\n        {\n          size--; \n          printf(\"Consumed! size=%d\\n\", size);\n          fflush(stdout);\n        }\n      }\n      for (int i = 0; i < 1000; i++)\n        r = (r + 1) % 10;\n    }\n  }\n}\n",
        "data_race": 0
    },
    {
        "id": 188,
        "trimmed_code": "#include <stdio.h>\n\nint cap = 10, size = 0;\nunsigned r = 0;\n\nint main()\n{\n#pragma omp parallel sections shared(size, cap) firstprivate(r) num_threads(2)\n  {\n#pragma omp section\n    while (1)\n    {\n#pragma omp critical(A)\n      {\n        if (size < cap)\n        {\n          size++; \n          printf(\"Produced! size=%d\\n\", size);\n          fflush(stdout);\n        }\n      }\n      for (int i = 0; i < 1000; i++)\n        r = (r + 1) % 10;\n    }\n#pragma omp section\n    while (1)\n    {\n#pragma omp critical(B)\n      {\n        if (size > 0)\n        {\n          size--; \n          printf(\"Consumed! size=%d\\n\", size);\n          fflush(stdout);\n        }\n      }\n      for (int i = 0; i < 1000; i++)\n        r = (r + 1) % 10;\n    }\n  }\n}\n",
        "data_race": 1
    },
    {
        "id": 189,
        "trimmed_code": "#include <stdio.h>\nint main()\n{\n  int x = 0, s = 0;\n#pragma omp parallel sections shared(x, s) num_threads(2)\n  {\n#pragma omp section\n    {\n      x = 1;\n#pragma omp critical\n      {\n        s = 1;\n      }\n    }\n#pragma omp section\n    {\n      int done = 0;\n      while (!done)\n      {\n#pragma omp critical\n        {\n          if (s)\n            done = 1;\n        }\n      }\n      x = 2;\n    }\n  }\n  printf(\"%d\\n\", x);\n}\n",
        "data_race": 0
    },
    {
        "id": 190,
        "trimmed_code": "#include <stdio.h>\nint main()\n{\n  int x = 0, s = 0;\n#pragma omp parallel sections shared(x, s) num_threads(2)\n  {\n#pragma omp section\n    {\n      x = 1;\n#pragma omp critical(A)\n      {\n        s = 1;\n      }\n    }\n#pragma omp section\n    {\n      int done = 0;\n      while (!done)\n      {\n#pragma omp critical(B)\n        {\n          if (s)\n            done = 1;\n        }\n      }\n      x = 2;\n    }\n  }\n  printf(\"%d\\n\", x);\n}\n",
        "data_race": 1
    },
    {
        "id": 191,
        "trimmed_code": "#include <stdlib.h>\n#include <stdio.h>\n\ndouble *u1, *u2, c = 0.2;\nint n = 10, nsteps = 10;\n\nint main()\n{\n  u1 = malloc(n * sizeof(double));\n  u2 = malloc(n * sizeof(double));\n  for (int i = 1; i < n - 1; i++)\n    u2[i] = u1[i] = 1.0 * rand() / RAND_MAX;\n  u1[0] = u1[n - 1] = u2[0] = u2[n - 1] = 0.5;\n  for (int t = 0; t < nsteps; t++)\n  {\n#pragma omp parallel for\n    for (int i = 1; i < n - 1; i++)\n    {\n      u2[i] = u1[i] + c * (u1[i - 1] + u1[i + 1] - 2 * u1[i]);\n    }\n    double *tmp = u1;\n    u1 = u2;\n    u2 = tmp;\n  }\n  for (int i = 0; i < n; i++)\n    printf(\"%1.2lf \", u1[i]);\n  printf(\"\\n\");\n  free(u1);\n  free(u2);\n}\n",
        "data_race": 0
    },
    {
        "id": 192,
        "trimmed_code": "#include <stdlib.h>\n#include <stdio.h>\n\ndouble *u1, *u2, c = 0.2;\nint n = 10, nsteps = 10;\n\nint main()\n{\n  u1 = malloc(n * sizeof(double));\n  u2 = malloc(n * sizeof(double));\n  for (int i = 1; i < n - 1; i++)\n    u2[i] = u1[i] = 1.0 * rand() / RAND_MAX;\n  u1[0] = u1[n - 1] = u2[0] = u2[n - 1] = 0.5;\n  for (int t = 0; t < nsteps; t++)\n  {\n#pragma omp parallel for\n    for (int i = 1; i < n - 1; i++)\n    {\n      u2[i] = u1[i] + c * (u1[i - 1] + u1[i + 1] - 2 * u1[i]);\n    }\n    double *tmp = u1;\n    u1 = u2; \n  }\n  for (int i = 0; i < n; i++)\n    printf(\"%1.2lf \", u1[i]);\n  printf(\"\\n\");\n  free(u1);\n  free(u2);\n}\n",
        "data_race": 1
    },
    {
        "id": 193,
        "trimmed_code": "#include <stdlib.h>\n#include <stdio.h>\n\ndouble c = 0.2;\nint n = 20, nsteps = 100;\n\nint main()\n{\n  double *b = malloc(2 * n * sizeof(double));\n  double *u[2] = {&b[0], &b[n]};\n  for (int i = 1; i < n - 1; i++)\n    u[0][i] = u[1][i] = 1.0 * rand() / RAND_MAX;\n  u[0][0] = u[0][n - 1] = u[1][0] = u[1][n - 1] = 0.5;\n  int p = 0;\n  for (int t = 0; t < nsteps; t++)\n  {\n#pragma omp parallel for\n    for (int i = 1; i < n - 1; i++)\n    {\n      u[1 - p][i] = u[p][i] + c * (u[p][i - 1] + u[p][i + 1] - 2 * u[p][i]);\n    }\n    p = 1 - p;\n  }\n  for (int i = 0; i < n; i++)\n    printf(\"%1.2lf \", u[p][i]);\n  printf(\"\\n\");\n  free(b);\n}\n",
        "data_race": 0
    },
    {
        "id": 194,
        "trimmed_code": "#include <stdlib.h>\n#include <stdio.h>\n\ndouble c = 0.2;\nint n = 20, nsteps = 100;\n\nint main()\n{\n  double *b = malloc(2 * n * sizeof(double));\n  double *u[2] = {&b[0], &b[n - 2]}; \n  for (int i = 1; i < n - 1; i++)\n    u[0][i] = u[1][i] = 1.0 * rand() / RAND_MAX;\n  u[0][0] = u[0][n - 1] = u[1][0] = u[1][n - 1] = 0.5;\n  int p = 0;\n  for (int t = 0; t < nsteps; t++)\n  {\n#pragma omp parallel for\n    for (int i = 1; i < n - 1; i++)\n    {\n      u[1 - p][i] = u[p][i] + c * (u[p][i - 1] + u[p][i + 1] - 2 * u[p][i]);\n    }\n    p = 1 - p;\n  }\n  for (int i = 0; i < n; i++)\n    printf(\"%1.2lf \", u[p][i]);\n  printf(\"\\n\");\n  free(b);\n}",
        "data_race": 1
    },
    {
        "id": 195,
        "trimmed_code": "#include <stdio.h>\nint nprod = 4, ncons = 4;\nint cap = 5, size = 0;\nint main()\n{\n  int nthread = nprod + ncons;\n#pragma omp parallel for shared(size, cap, nprod, ncons, nthread) num_threads(nthread)\n  for (int i = 0; i < nthread; i++)\n  {\n    if (i < nprod)\n      while (1)\n      { \n#pragma omp critical\n        if (size < cap)\n        {\n          size++; \n          printf(\"Producer %d produced! size=%d\\n\", i, size);\n          fflush(stdout);\n        }\n      }\n    else\n      while (1)\n      { \n#pragma omp critical\n        if (size > 0)\n        {\n          size--; \n          printf(\"Consumer %d consumed! size=%d\\n\", i - nprod, size);\n          fflush(stdout);\n        }\n      }\n  }\n}",
        "data_race": 0
    },
    {
        "id": 196,
        "trimmed_code": "#include <stdio.h>\n#include <stdio.h>\nint nprod = 4, ncons = 4;\nint cap = 5, size = 0;\nint main()\n{\n  int nthread = nprod + ncons;\n#pragma omp parallel for shared(size, cap, nprod, ncons, nthread) num_threads(nthread)\n  for (int i = 0; i < nthread; i++)\n  {\n    if (i < nprod)\n      while (1)\n      { \n#pragma omp critical(A)\n        if (size < cap)\n        {\n          size++; \n          printf(\"Producer %d produced! size=%d\\n\", i, size);\n          fflush(stdout);\n        }\n      }\n    else\n      while (1)\n      { \n#pragma omp critical(B)\n        if (size > 0)\n        {\n          size--; \n          printf(\"Consumer %d consumed! size=%d\\n\", i - nprod, size);\n          fflush(stdout);\n        }\n      }\n  }\n}",
        "data_race": 1
    },
    {
        "id": 197,
        "trimmed_code": "#include <stdio.h>\n#include <omp.h>\n#include <assert.h>\n\nomp_lock_t l;\nint x = 1;\n\nint main()\n{\n  omp_init_lock(&l);\n#pragma omp parallel num_threads(2)\n  {\n    int tid = omp_get_thread_num();\n    if (tid == 0)\n      omp_set_lock(&l);\n#pragma omp barrier\n    if (tid == 0)\n    {\n      x = 0;\n      omp_unset_lock(&l);\n    }\n    else if (tid == 1)\n    {\n      omp_set_lock(&l);\n      omp_unset_lock(&l);\n      x = 1;\n    }\n#pragma omp barrier\n  } \n  omp_destroy_lock(&l);\n  printf(\"Done: x=%d\\n\", x);\n}",
        "data_race": 0
    },
    {
        "id": 198,
        "trimmed_code": "#include <stdio.h>\n#include <omp.h>\n#include <assert.h>\n\nomp_lock_t l;\nint x = 1;\n\nint main()\n{\n  omp_init_lock(&l);\n#pragma omp parallel num_threads(2)\n  {\n    int tid = omp_get_thread_num();\n#pragma omp barrier\n    if (tid == 0)\n    {\n      omp_set_lock(&l);\n      x = 0;\n      omp_unset_lock(&l);\n    }\n    else if (tid == 1)\n    {\n      omp_set_lock(&l);\n      omp_unset_lock(&l);\n      x = 1;\n    }\n#pragma omp barrier\n  } \n  omp_destroy_lock(&l);\n  printf(\"Done: x=%d\\n\", x);\n}",
        "data_race": 1
    }
]