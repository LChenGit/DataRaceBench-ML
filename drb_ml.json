[
    {
        "ID": "001",
        "name": "DRB001-antidep1-orig-yes.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/*\nA loop with loop-carried anti-dependence.\nData race pair: a[i+1]@64:10:R vs. a[i]@64:5:W\n*/\n#include <stdio.h>\nint main(int argc, char* argv[])\n{   \n  int i;\n  int len = 1000;\n\n  int a[1000];\n\n  for (i=0; i<len; i++)\n    a[i]= i; \n\n#pragma omp parallel for\n  for (i=0;i< len -1 ;i++)\n    a[i]=a[i+1]+1;\n\n  printf (\"a[500]=%d\\n\", a[500] );\n  return 0;\n} \n",
        "data_race": 1,
        "trimmed_code": "#include <stdio.h>\nint main(int argc, char* argv[])\n{   \n  int i;\n  int len = 1000;\n\n  int a[1000];\n\n  for (i=0; i<len; i++)\n    a[i]= i; \n\n#pragma omp parallel for\n  for (i=0;i< len -1 ;i++)\n    a[i]=a[i+1]+1;\n\n  printf (\"a[500]=%d\\n\", a[500] );\n  return 0;\n} \n",
        "code_len": 262,
        "data_race_label": "Y1",
        "var_pairs": [
            "{\"name\": [\"a[i+1]\", \"a[i]\"],\n\"line\": [64, 64],\n\"col\": [10, 5],\n\"operation\": [\"R\", \"W\"]}"
        ]
    },
    {
        "ID": "002",
        "name": "DRB002-antidep1-var-yes.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/*\nA loop with loop-carried anti-dependence.\nData race pair: a[i+1]@67:10:R vs. a[i]@67:5:W\n*/\n#include <stdlib.h>\nint main(int argc, char* argv[])\n{   \n  int i;\n  int len = 1000;\n\n  if (argc>1)\n    len = atoi(argv[1]);\n\n  int a[len];\n\n  for (i=0; i<len; i++)\n    a[i]= i; \n\n#pragma omp parallel for\n  for (i=0;i< len -1 ;i++)\n    a[i]=a[i+1]+1;\n\n  return 0;\n} \n",
        "data_race": 1,
        "trimmed_code": "#include <stdlib.h>\nint main(int argc, char* argv[])\n{   \n  int i;\n  int len = 1000;\n\n  if (argc>1)\n    len = atoi(argv[1]);\n\n  int a[len];\n\n  for (i=0; i<len; i++)\n    a[i]= i; \n\n#pragma omp parallel for\n  for (i=0;i< len -1 ;i++)\n    a[i]=a[i+1]+1;\n\n  return 0;\n} \n",
        "code_len": 267,
        "data_race_label": "Y1",
        "var_pairs": [
            "{\"name\": [\"a[i+1]\", \"a[i]\"],\n\"line\": [67, 67],\n\"col\": [10, 5],\n\"operation\": [\"R\", \"W\"]}"
        ]
    },
    {
        "ID": "003",
        "name": "DRB003-antidep2-orig-yes.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/*\nA two-level loop nest with loop carried anti-dependence on the outer level.\nData race pair: a[i][j]@67:7:W vs. a[i+1][j]@67:18:R\n*/\n#include <stdio.h>\n\nint main(int argc,char *argv[])\n{\n  int i, j;\n  int len = 20; \n\n  double a[20][20];\n\n  for (i=0; i< len; i++)\n    for (j=0; j<len; j++)\n      a[i][j] = 0.5; \n\n#pragma omp parallel for private(j)\n  for (i = 0; i < len - 1; i += 1) {\n    for (j = 0; j < len ; j += 1) {\n      a[i][j] += a[i + 1][j];\n    }\n  }\n\n  printf (\"a[10][10]=%f\\n\", a[10][10]);\n  return 0;\n}\n\n",
        "data_race": 1,
        "trimmed_code": "#include <stdio.h>\n\nint main(int argc,char *argv[])\n{\n  int i, j;\n  int len = 20; \n\n  double a[20][20];\n\n  for (i=0; i< len; i++)\n    for (j=0; j<len; j++)\n      a[i][j] = 0.5; \n\n#pragma omp parallel for private(j)\n  for (i = 0; i < len - 1; i += 1) {\n    for (j = 0; j < len ; j += 1) {\n      a[i][j] += a[i + 1][j];\n    }\n  }\n\n  printf (\"a[10][10]=%f\\n\", a[10][10]);\n  return 0;\n}\n\n",
        "code_len": 384,
        "data_race_label": "Y1",
        "var_pairs": [
            "{\"name\": [\"a[i][j]\", \"a[i+1][j]\"],\n\"line\": [67, 67],\n\"col\": [7, 18],\n\"operation\": [\"W\", \"R\"]}"
        ]
    },
    {
        "ID": "004",
        "name": "DRB004-antidep2-var-yes.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/*\nTwo nested loops with loop-carried anti-dependence on the outer level.\nThis is a variable-length array version in C99.\nData race pair: a[i][j]@70:7:W vs. a[i+1][j]@70:18:R\n*/\n#include <stdlib.h>\nint main(int argc,char *argv[])\n{\n  int i, j;\n  int len = 20; \n\n  if (argc>1)\n    len = atoi(argv[1]);\n\n  double a[len][len];\n\n  for (i=0; i< len; i++)\n    for (j=0; j<len; j++)\n      a[i][j] = 0.5; \n\n#pragma omp parallel for private(j)\n  for (i = 0; i < len - 1; i += 1) {\n    for (j = 0; j < len ; j += 1) {\n      a[i][j] += a[i + 1][j];\n    }\n  }\n  return 0;\n}\n\n",
        "data_race": 1,
        "trimmed_code": "#include <stdlib.h>\nint main(int argc,char *argv[])\n{\n  int i, j;\n  int len = 20; \n\n  if (argc>1)\n    len = atoi(argv[1]);\n\n  double a[len][len];\n\n  for (i=0; i< len; i++)\n    for (j=0; j<len; j++)\n      a[i][j] = 0.5; \n\n#pragma omp parallel for private(j)\n  for (i = 0; i < len - 1; i += 1) {\n    for (j = 0; j < len ; j += 1) {\n      a[i][j] += a[i + 1][j];\n    }\n  }\n  return 0;\n}\n\n",
        "code_len": 385,
        "data_race_label": "Y1",
        "var_pairs": [
            "{\"name\": [\"a[i][j]\", \"a[i+1][j]\"],\n\"line\": [70, 70],\n\"col\": [7, 18],\n\"operation\": [\"W\", \"R\"]}"
        ]
    },
    {
        "ID": "005",
        "name": "DRB005-indirectaccess1-orig-yes.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n/*\nThis program is extracted from a real application at LLNL.\nTwo pointers (xa1 and xa2) have a pair of values with a distance of 12.\nThey are used as start base addresses for two 1-D arrays.\nTheir index set has two indices with distance of 12: 999 +12 = 1011.\nSo there is loop carried dependence.\n\nHowever, having loop carried dependence does not mean data races will always happen.\nThe iterations with loop carried dependence must be scheduled to\ndifferent threads in order for data races to happen.\n\nIn this example, we use schedule(static,1) to increase the chance that\nthe dependent loop iterations will be scheduled to different threads.\nData race pair: xa1[idx]@128:5:W vs. xa2[idx]@129:5:W\n*/\n#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#define N 180\nint indexSet[N] = {\n521, 523, 525, 527, 529, 531,\n547, 549, 551, 553, 555, 557,\n573, 575, 577, 579, 581, 583,\n599, 601, 603, 605, 607, 609,\n625, 627, 629, 631, 633, 635,\n\n651, 653, 655, 657, 659, 661,\n859, 861, 863, 865, 867, 869,\n885, 887, 889, 891, 893, 895,\n911, 913, 915, 917, 919, 923, // change original 921 to 923 = 911+12\n937, 939, 941, 943, 945, 947,\n\n963, 965, 967, 969, 971, 973,\n989, 991, 993, 995, 997, 999, \n1197, 1199, 1201, 1203, 1205, 1207,\n1223, 1225, 1227, 1229, 1231, 1233,\n1249, 1251, 1253, 1255, 1257, 1259,\n\n1275, 1277, 1279, 1281, 1283, 1285,\n1301, 1303, 1305, 1307, 1309, 1311,\n1327, 1329, 1331, 1333, 1335, 1337,\n1535, 1537, 1539, 1541, 1543, 1545,\n1561, 1563, 1565, 1567, 1569, 1571,\n\n1587, 1589, 1591, 1593, 1595, 1597,\n1613, 1615, 1617, 1619, 1621, 1623,\n1639, 1641, 1643, 1645, 1647, 1649,\n1665, 1667, 1669, 1671, 1673, 1675,\n1873, 1875, 1877, 1879, 1881, 1883,\n\n1899, 1901, 1903, 1905, 1907, 1909,\n1925, 1927, 1929, 1931, 1933, 1935,\n1951, 1953, 1955, 1957, 1959, 1961,\n1977, 1979, 1981, 1983, 1985, 1987,\n2003, 2005, 2007, 2009, 2011, 2013};\n\nint main (int argc, char* argv[])\n{\n  // max index value is 2013. +12 to obtain a valid xa2[idx] after xa1+12.\n  // +1 to ensure a reference like base[2015] is within the bound.\n  double * base = (double*) malloc(sizeof(double)* (2013+12+1));\n  if (base == 0)\n  {\n    printf (\"Error in malloc(). Aborting ...\\n\");\n    return 1;  \n  }\n\n  double * xa1 = base;\n  double * xa2 = xa1 + 12;\n  int i;\n\n  // initialize segments touched by indexSet\n  for (i =521; i<= 2025; ++i)\n  {\n    base[i]=0.5*i;\n  }\n// default static even scheduling may not trigger data race, using static,1 instead.\n#pragma omp parallel for schedule(static,1)\n  for (i =0; i< N; ++i) \n  {\n    int idx = indexSet[i];\n    xa1[idx]+= 1.0 + i;\n    xa2[idx]+= 3.0 + i;\n  }\n\n  printf(\"x1[999]=%f xa2[1285]=%f\\n\", xa1[999], xa2[1285]);\n  free (base);\n  return  0;\n}\n\n",
        "data_race": 1,
        "trimmed_code": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#define N 180\nint indexSet[N] = {\n521, 523, 525, 527, 529, 531,\n547, 549, 551, 553, 555, 557,\n573, 575, 577, 579, 581, 583,\n599, 601, 603, 605, 607, 609,\n625, 627, 629, 631, 633, 635,\n\n651, 653, 655, 657, 659, 661,\n859, 861, 863, 865, 867, 869,\n885, 887, 889, 891, 893, 895,\n911, 913, 915, 917, 919, 923, \n937, 939, 941, 943, 945, 947,\n\n963, 965, 967, 969, 971, 973,\n989, 991, 993, 995, 997, 999, \n1197, 1199, 1201, 1203, 1205, 1207,\n1223, 1225, 1227, 1229, 1231, 1233,\n1249, 1251, 1253, 1255, 1257, 1259,\n\n1275, 1277, 1279, 1281, 1283, 1285,\n1301, 1303, 1305, 1307, 1309, 1311,\n1327, 1329, 1331, 1333, 1335, 1337,\n1535, 1537, 1539, 1541, 1543, 1545,\n1561, 1563, 1565, 1567, 1569, 1571,\n\n1587, 1589, 1591, 1593, 1595, 1597,\n1613, 1615, 1617, 1619, 1621, 1623,\n1639, 1641, 1643, 1645, 1647, 1649,\n1665, 1667, 1669, 1671, 1673, 1675,\n1873, 1875, 1877, 1879, 1881, 1883,\n\n1899, 1901, 1903, 1905, 1907, 1909,\n1925, 1927, 1929, 1931, 1933, 1935,\n1951, 1953, 1955, 1957, 1959, 1961,\n1977, 1979, 1981, 1983, 1985, 1987,\n2003, 2005, 2007, 2009, 2011, 2013};\n\nint main (int argc, char* argv[])\n{\n  \n  \n  double * base = (double*) malloc(sizeof(double)* (2013+12+1));\n  if (base == 0)\n  {\n    printf (\"Error in malloc(). Aborting ...\\n\");\n    return 1;  \n  }\n\n  double * xa1 = base;\n  double * xa2 = xa1 + 12;\n  int i;\n\n  \n  for (i =521; i<= 2025; ++i)\n  {\n    base[i]=0.5*i;\n  }\n\n#pragma omp parallel for schedule(static,1)\n  for (i =0; i< N; ++i) \n  {\n    int idx = indexSet[i];\n    xa1[idx]+= 1.0 + i;\n    xa2[idx]+= 3.0 + i;\n  }\n\n  printf(\"x1[999]=%f xa2[1285]=%f\\n\", xa1[999], xa2[1285]);\n  free (base);\n  return  0;\n}\n\n",
        "code_len": 1675,
        "data_race_label": "Y7",
        "var_pairs": [
            "{\"name\": [\"xa1[idx]\", \"xa2[idx]\"],\n\"line\": [128, 129],\n\"col\": [5, 5],\n\"operation\": [\"W\", \"W\"]}"
        ]
    },
    {
        "ID": "006",
        "name": "DRB006-indirectaccess2-orig-yes.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n/*\nTwo pointers have a distance of 12 (p1 - p2 = 12).\nThey are used as base addresses for indirect array accesses using an index set (another array).\n\nThe index set has two indices with a distance of 12 :\nindexSet[5]- indexSet[0] = 533 - 521 =  12\nSo there is loop carried dependence (e.g. between loops with index values of 0 and 5).\n\nWe use the default loop scheduling (static even) in OpenMP.\nIt is possible that two dependent iterations will be scheduled\nwithin a same chunk to a same thread. So there is no runtime data races.\n\nWhen N is 180, two iterations with N=0 and N= 5 have loop carried dependencies.\nFor static even scheduling, we must have at least 36 threads (180/36=5 iterations)\nso iteration 0 and 5 will be scheduled to two different threads.\nData race pair: xa1[idx]@128:5:W vs. xa2[idx]@129:5:W\n*/\n#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#define N 180\nint indexSet[N] = {\n521, 523, 525, 527, 529, 533, // 521+12=533\n547, 549, 551, 553, 555, 557,\n573, 575, 577, 579, 581, 583,\n599, 601, 603, 605, 607, 609,\n625, 627, 629, 631, 633, 635,\n\n651, 653, 655, 657, 659, 661,\n859, 861, 863, 865, 867, 869,\n885, 887, 889, 891, 893, 895,\n911, 913, 915, 917, 919, 921, \n937, 939, 941, 943, 945, 947,\n\n963, 965, 967, 969, 971, 973,\n989, 991, 993, 995, 997, 999, \n1197, 1199, 1201, 1203, 1205, 1207,\n1223, 1225, 1227, 1229, 1231, 1233,\n1249, 1251, 1253, 1255, 1257, 1259,\n\n1275, 1277, 1279, 1281, 1283, 1285,\n1301, 1303, 1305, 1307, 1309, 1311,\n1327, 1329, 1331, 1333, 1335, 1337,\n1535, 1537, 1539, 1541, 1543, 1545,\n1561, 1563, 1565, 1567, 1569, 1571,\n\n1587, 1589, 1591, 1593, 1595, 1597,\n1613, 1615, 1617, 1619, 1621, 1623,\n1639, 1641, 1643, 1645, 1647, 1649,\n1665, 1667, 1669, 1671, 1673, 1675,\n1873, 1875, 1877, 1879, 1881, 1883,\n\n1899, 1901, 1903, 1905, 1907, 1909,\n1925, 1927, 1929, 1931, 1933, 1935,\n1951, 1953, 1955, 1957, 1959, 1961,\n1977, 1979, 1981, 1983, 1985, 1987,\n2003, 2005, 2007, 2009, 2011, 2013};\n\nint main (int argc, char* argv[])\n{\n  double * base = (double*) malloc(sizeof(double)* (2013+12+1));\n\n  if (base == 0)\n  {\n    printf (\"Error in malloc(). Aborting ...\\n\");\n    return 1;  \n  }\n  double * xa1 = base;\n  double * xa2 = xa1 + 12;\n  int i;\n\n  // initialize segments touched by indexSet\n  for (i =521; i<= 2025; ++i)\n  {\n    base[i]=0.5*i;\n  }\n\n#pragma omp parallel for // default static even scheduling may not trigger data race!\n  for (i =0; i< N; ++i) \n  {\n    int idx = indexSet[i];\n    xa1[idx]+= 1.0;\n    xa2[idx]+= 3.0;\n  }\n  printf(\"x1[999]=%f xa2[1285]=%f\\n\", xa1[999], xa2[1285]);\n  free (base);\n  return  0;\n}\n\n",
        "data_race": 1,
        "trimmed_code": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#define N 180\nint indexSet[N] = {\n521, 523, 525, 527, 529, 533, \n547, 549, 551, 553, 555, 557,\n573, 575, 577, 579, 581, 583,\n599, 601, 603, 605, 607, 609,\n625, 627, 629, 631, 633, 635,\n\n651, 653, 655, 657, 659, 661,\n859, 861, 863, 865, 867, 869,\n885, 887, 889, 891, 893, 895,\n911, 913, 915, 917, 919, 921, \n937, 939, 941, 943, 945, 947,\n\n963, 965, 967, 969, 971, 973,\n989, 991, 993, 995, 997, 999, \n1197, 1199, 1201, 1203, 1205, 1207,\n1223, 1225, 1227, 1229, 1231, 1233,\n1249, 1251, 1253, 1255, 1257, 1259,\n\n1275, 1277, 1279, 1281, 1283, 1285,\n1301, 1303, 1305, 1307, 1309, 1311,\n1327, 1329, 1331, 1333, 1335, 1337,\n1535, 1537, 1539, 1541, 1543, 1545,\n1561, 1563, 1565, 1567, 1569, 1571,\n\n1587, 1589, 1591, 1593, 1595, 1597,\n1613, 1615, 1617, 1619, 1621, 1623,\n1639, 1641, 1643, 1645, 1647, 1649,\n1665, 1667, 1669, 1671, 1673, 1675,\n1873, 1875, 1877, 1879, 1881, 1883,\n\n1899, 1901, 1903, 1905, 1907, 1909,\n1925, 1927, 1929, 1931, 1933, 1935,\n1951, 1953, 1955, 1957, 1959, 1961,\n1977, 1979, 1981, 1983, 1985, 1987,\n2003, 2005, 2007, 2009, 2011, 2013};\n\nint main (int argc, char* argv[])\n{\n  double * base = (double*) malloc(sizeof(double)* (2013+12+1));\n\n  if (base == 0)\n  {\n    printf (\"Error in malloc(). Aborting ...\\n\");\n    return 1;  \n  }\n  double * xa1 = base;\n  double * xa2 = xa1 + 12;\n  int i;\n\n  \n  for (i =521; i<= 2025; ++i)\n  {\n    base[i]=0.5*i;\n  }\n\n#pragma omp parallel for \n  for (i =0; i< N; ++i) \n  {\n    int idx = indexSet[i];\n    xa1[idx]+= 1.0;\n    xa2[idx]+= 3.0;\n  }\n  printf(\"x1[999]=%f xa2[1285]=%f\\n\", xa1[999], xa2[1285]);\n  free (base);\n  return  0;\n}\n\n",
        "code_len": 1643,
        "data_race_label": "Y7",
        "var_pairs": [
            "{\"name\": [\"xa1[idx]\", \"xa2[idx]\"],\n\"line\": [128, 129],\n\"col\": [5, 5],\n\"operation\": [\"W\", \"W\"]}"
        ]
    },
    {
        "ID": "007",
        "name": "DRB007-indirectaccess3-orig-yes.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n/*\nTwo pointers have distance of 12 (p1 - p2 = 12).\nThey are used as base addresses for indirect array accesses using an index set (another array).\n\nAn index set has two indices with distance of 12 :\nindexSet[3]- indexSet[0] = 533 - 521 =  12\nSo there is loop carried dependence for N=0 and N=3.\n\nWe use the default loop scheduling (static even) in OpenMP.\nIt is possible that two dependent iterations will be scheduled\nwithin a same chunk to a same thread. So there is no runtime data races.\n\nN is 180, two iterations with N=0 and N= 3 have loop carried dependencies.\nFor static even scheduling, we must have at least 60 threads (180/60=3 iterations)\nso iteration 0 and 3 will be scheduled to two different threads.\nData race pair: xa1[idx]@128:5:W vs. xa2[idx]@129:5:W\n*/\n#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#define N 180\nint indexSet[N] = {\n521, 523, 525, 533, 529, 531, // 521+12=533\n547, 549, 551, 553, 555, 557,\n573, 575, 577, 579, 581, 583,\n599, 601, 603, 605, 607, 609,\n625, 627, 629, 631, 633, 635,\n\n651, 653, 655, 657, 659, 661,\n859, 861, 863, 865, 867, 869,\n885, 887, 889, 891, 893, 895,\n911, 913, 915, 917, 919, 921, \n937, 939, 941, 943, 945, 947,\n\n963, 965, 967, 969, 971, 973,\n989, 991, 993, 995, 997, 999, \n1197, 1199, 1201, 1203, 1205, 1207,\n1223, 1225, 1227, 1229, 1231, 1233,\n1249, 1251, 1253, 1255, 1257, 1259,\n\n1275, 1277, 1279, 1281, 1283, 1285,\n1301, 1303, 1305, 1307, 1309, 1311,\n1327, 1329, 1331, 1333, 1335, 1337,\n1535, 1537, 1539, 1541, 1543, 1545,\n1561, 1563, 1565, 1567, 1569, 1571,\n\n1587, 1589, 1591, 1593, 1595, 1597,\n1613, 1615, 1617, 1619, 1621, 1623,\n1639, 1641, 1643, 1645, 1647, 1649,\n1665, 1667, 1669, 1671, 1673, 1675,\n1873, 1875, 1877, 1879, 1881, 1883,\n\n1899, 1901, 1903, 1905, 1907, 1909,\n1925, 1927, 1929, 1931, 1933, 1935,\n1951, 1953, 1955, 1957, 1959, 1961,\n1977, 1979, 1981, 1983, 1985, 1987,\n2003, 2005, 2007, 2009, 2011, 2013};\n\nint main (int argc, char* argv[])\n{\n  double * base = (double*) malloc(sizeof(double)* (2013+12+1));\n  if (base == 0)\n  {\n    printf (\"Error in malloc(). Aborting ...\\n\");\n    return 1;  \n  }\n\n  double * xa1 = base;\n  double * xa2 = xa1 + 12;\n  int i;\n\n  // initialize segments touched by indexSet\n  for (i =521; i<= 2025; ++i)\n  {\n    base[i]=0.5*i;\n  }\n\n#pragma omp parallel for // default static even scheduling may not trigger data race!\n  for (i =0; i< N; ++i) \n  {\n    int idx = indexSet[i];\n    xa1[idx]+= 1.0;\n    xa2[idx]+= 3.0;\n  }\n  printf(\"x1[999]=%f xa2[1285]=%f\\n\", xa1[999], xa2[1285]);\n  free (base);\n  return  0;\n}\n\n",
        "data_race": 1,
        "trimmed_code": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#define N 180\nint indexSet[N] = {\n521, 523, 525, 533, 529, 531, \n547, 549, 551, 553, 555, 557,\n573, 575, 577, 579, 581, 583,\n599, 601, 603, 605, 607, 609,\n625, 627, 629, 631, 633, 635,\n\n651, 653, 655, 657, 659, 661,\n859, 861, 863, 865, 867, 869,\n885, 887, 889, 891, 893, 895,\n911, 913, 915, 917, 919, 921, \n937, 939, 941, 943, 945, 947,\n\n963, 965, 967, 969, 971, 973,\n989, 991, 993, 995, 997, 999, \n1197, 1199, 1201, 1203, 1205, 1207,\n1223, 1225, 1227, 1229, 1231, 1233,\n1249, 1251, 1253, 1255, 1257, 1259,\n\n1275, 1277, 1279, 1281, 1283, 1285,\n1301, 1303, 1305, 1307, 1309, 1311,\n1327, 1329, 1331, 1333, 1335, 1337,\n1535, 1537, 1539, 1541, 1543, 1545,\n1561, 1563, 1565, 1567, 1569, 1571,\n\n1587, 1589, 1591, 1593, 1595, 1597,\n1613, 1615, 1617, 1619, 1621, 1623,\n1639, 1641, 1643, 1645, 1647, 1649,\n1665, 1667, 1669, 1671, 1673, 1675,\n1873, 1875, 1877, 1879, 1881, 1883,\n\n1899, 1901, 1903, 1905, 1907, 1909,\n1925, 1927, 1929, 1931, 1933, 1935,\n1951, 1953, 1955, 1957, 1959, 1961,\n1977, 1979, 1981, 1983, 1985, 1987,\n2003, 2005, 2007, 2009, 2011, 2013};\n\nint main (int argc, char* argv[])\n{\n  double * base = (double*) malloc(sizeof(double)* (2013+12+1));\n  if (base == 0)\n  {\n    printf (\"Error in malloc(). Aborting ...\\n\");\n    return 1;  \n  }\n\n  double * xa1 = base;\n  double * xa2 = xa1 + 12;\n  int i;\n\n  \n  for (i =521; i<= 2025; ++i)\n  {\n    base[i]=0.5*i;\n  }\n\n#pragma omp parallel for \n  for (i =0; i< N; ++i) \n  {\n    int idx = indexSet[i];\n    xa1[idx]+= 1.0;\n    xa2[idx]+= 3.0;\n  }\n  printf(\"x1[999]=%f xa2[1285]=%f\\n\", xa1[999], xa2[1285]);\n  free (base);\n  return  0;\n}\n\n",
        "code_len": 1643,
        "data_race_label": "Y7",
        "var_pairs": [
            "{\"name\": [\"xa1[idx]\", \"xa2[idx]\"],\n\"line\": [128, 129],\n\"col\": [5, 5],\n\"operation\": [\"W\", \"W\"]}"
        ]
    },
    {
        "ID": "008",
        "name": "DRB008-indirectaccess4-orig-yes.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n/*\nTwo pointers have a distance of 12 (xa2 - xa1 = 12).\nThey are used as base addresses for indirect array accesses using an index set (another array).\n\nThe index set has two indices with distance of 12 :\n   indexSet[1]- indexSet[0] = 533 - 521 =  12\nSo xa1[idx] and xa2[idx] may cause loop carried dependence for N=0 and N=3.\n\nWe use the default loop scheduling (static even) in OpenMP.\nIt is possible that two dependent iterations will be scheduled\nwithin a same chunk to a same thread. So there is no runtime data races.\n\nN is 180, two iterations with N=0 and N= 1 have loop carried dependencies.\nFor static even scheduling, we must have at least 180 threads (180/180=1 iterations)\nso iteration 0 and 1 will be scheduled to two different threads.\n\nData race pair: xa1[idx]@128:5:W vs. xa2[idx]@129:5:W\n*/\n#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#define N 180\nint indexSet[N] = {\n521, 533, 525, 527, 529, 531, // 521+12=533\n547, 549, 551, 553, 555, 557,\n573, 575, 577, 579, 581, 583,\n599, 601, 603, 605, 607, 609,\n625, 627, 629, 631, 633, 635,\n\n651, 653, 655, 657, 659, 661,\n859, 861, 863, 865, 867, 869,\n885, 887, 889, 891, 893, 895,\n911, 913, 915, 917, 919, 921, \n937, 939, 941, 943, 945, 947,\n\n963, 965, 967, 969, 971, 973,\n989, 991, 993, 995, 997, 999, \n1197, 1199, 1201, 1203, 1205, 1207,\n1223, 1225, 1227, 1229, 1231, 1233,\n1249, 1251, 1253, 1255, 1257, 1259,\n\n1275, 1277, 1279, 1281, 1283, 1285,\n1301, 1303, 1305, 1307, 1309, 1311,\n1327, 1329, 1331, 1333, 1335, 1337,\n1535, 1537, 1539, 1541, 1543, 1545,\n1561, 1563, 1565, 1567, 1569, 1571,\n\n1587, 1589, 1591, 1593, 1595, 1597,\n1613, 1615, 1617, 1619, 1621, 1623,\n1639, 1641, 1643, 1645, 1647, 1649,\n1665, 1667, 1669, 1671, 1673, 1675,\n1873, 1875, 1877, 1879, 1881, 1883,\n\n1899, 1901, 1903, 1905, 1907, 1909,\n1925, 1927, 1929, 1931, 1933, 1935,\n1951, 1953, 1955, 1957, 1959, 1961,\n1977, 1979, 1981, 1983, 1985, 1987,\n2003, 2005, 2007, 2009, 2011, 2013};\n\nint main (int argc, char* argv[])\n{\n  double * base = (double*) malloc(sizeof(double)* (2013+12+1));\n  if (base == 0)\n  {\n    printf (\"Error in malloc(). Aborting ...\\n\");\n    return 1;  \n  }\n  double * xa1 = base;\n  double * xa2 = xa1 + 12;\n  int i;\n\n  // initialize segments touched by indexSet\n  for (i =521; i<= 2025; ++i)\n  {\n    base[i]=0.5*i;\n  }\n\n#pragma omp parallel for // default static even scheduling may not trigger data race!\n  for (i =0; i< N; ++i) \n  {\n    int idx = indexSet[i];\n    xa1[idx]+= 1.0;\n    xa2[idx]+= 3.0;\n  }\n  printf(\"x1[999]=%f xa2[1285]=%f\\n\", xa1[999], xa2[1285]);\n  free (base);\n  return  0;\n}\n\n",
        "data_race": 1,
        "trimmed_code": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#define N 180\nint indexSet[N] = {\n521, 533, 525, 527, 529, 531, \n547, 549, 551, 553, 555, 557,\n573, 575, 577, 579, 581, 583,\n599, 601, 603, 605, 607, 609,\n625, 627, 629, 631, 633, 635,\n\n651, 653, 655, 657, 659, 661,\n859, 861, 863, 865, 867, 869,\n885, 887, 889, 891, 893, 895,\n911, 913, 915, 917, 919, 921, \n937, 939, 941, 943, 945, 947,\n\n963, 965, 967, 969, 971, 973,\n989, 991, 993, 995, 997, 999, \n1197, 1199, 1201, 1203, 1205, 1207,\n1223, 1225, 1227, 1229, 1231, 1233,\n1249, 1251, 1253, 1255, 1257, 1259,\n\n1275, 1277, 1279, 1281, 1283, 1285,\n1301, 1303, 1305, 1307, 1309, 1311,\n1327, 1329, 1331, 1333, 1335, 1337,\n1535, 1537, 1539, 1541, 1543, 1545,\n1561, 1563, 1565, 1567, 1569, 1571,\n\n1587, 1589, 1591, 1593, 1595, 1597,\n1613, 1615, 1617, 1619, 1621, 1623,\n1639, 1641, 1643, 1645, 1647, 1649,\n1665, 1667, 1669, 1671, 1673, 1675,\n1873, 1875, 1877, 1879, 1881, 1883,\n\n1899, 1901, 1903, 1905, 1907, 1909,\n1925, 1927, 1929, 1931, 1933, 1935,\n1951, 1953, 1955, 1957, 1959, 1961,\n1977, 1979, 1981, 1983, 1985, 1987,\n2003, 2005, 2007, 2009, 2011, 2013};\n\nint main (int argc, char* argv[])\n{\n  double * base = (double*) malloc(sizeof(double)* (2013+12+1));\n  if (base == 0)\n  {\n    printf (\"Error in malloc(). Aborting ...\\n\");\n    return 1;  \n  }\n  double * xa1 = base;\n  double * xa2 = xa1 + 12;\n  int i;\n\n  \n  for (i =521; i<= 2025; ++i)\n  {\n    base[i]=0.5*i;\n  }\n\n#pragma omp parallel for \n  for (i =0; i< N; ++i) \n  {\n    int idx = indexSet[i];\n    xa1[idx]+= 1.0;\n    xa2[idx]+= 3.0;\n  }\n  printf(\"x1[999]=%f xa2[1285]=%f\\n\", xa1[999], xa2[1285]);\n  free (base);\n  return  0;\n}\n\n",
        "code_len": 1642,
        "data_race_label": "Y7",
        "var_pairs": [
            "{\"name\": [\"xa1[idx]\", \"xa2[idx]\"],\n\"line\": [128, 129],\n\"col\": [5, 5],\n\"operation\": [\"W\", \"W\"]}"
        ]
    },
    {
        "ID": "009",
        "name": "DRB009-lastprivatemissing-orig-yes.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n/*\nThis loop has loop-carried output-dependence due to x=... at line 59.\nThe problem can be solved by using lastprivate(x).\nData race pair: x@59:5:W vs. x@59:5:W\n*/\n#include <stdio.h>\nint main(int argc, char* argv[])\n{\n  int i,x;\n  int len = 10000;\n\n#pragma omp parallel for private (i) \n  for (i=0;i<len;i++)\n    x=i;\n\n  printf(\"x=%d\",x);\n  return 0;\n}\n\n",
        "data_race": 1,
        "trimmed_code": "#include <stdio.h>\nint main(int argc, char* argv[])\n{\n  int i,x;\n  int len = 10000;\n\n#pragma omp parallel for private (i) \n  for (i=0;i<len;i++)\n    x=i;\n\n  printf(\"x=%d\",x);\n  return 0;\n}\n\n",
        "code_len": 190,
        "data_race_label": "Y2",
        "var_pairs": [
            "{\"name\": [\"x\", \"x\"],\n\"line\": [59, 59],\n\"col\": [5, 5],\n\"operation\": [\"W\", \"W\"]}"
        ]
    },
    {
        "ID": "010",
        "name": "DRB010-lastprivatemissing-var-yes.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/*\nThis loop has loop-carried output-dependence due to x=... at line 63.\nThe problem can be solved by using lastprivate(x) .\nData race pair: x@63:5:W vs. x@63:5:W\n*/\n#include <stdio.h>\n#include <stdlib.h>\nint main(int argc, char* argv[])\n{\n  int i,x;\n  int len = 10000;\n  if (argc>1)\n    len = atoi(argv[1]);\n\n#pragma omp parallel for private (i) \n  for (i=0;i<len;i++)\n    x=i;\n  printf(\"x=%d\",x);\n  return 0;\n}\n\n",
        "data_race": 1,
        "trimmed_code": "#include <stdio.h>\n#include <stdlib.h>\nint main(int argc, char* argv[])\n{\n  int i,x;\n  int len = 10000;\n  if (argc>1)\n    len = atoi(argv[1]);\n\n#pragma omp parallel for private (i) \n  for (i=0;i<len;i++)\n    x=i;\n  printf(\"x=%d\",x);\n  return 0;\n}\n\n",
        "code_len": 248,
        "data_race_label": "Y2",
        "var_pairs": [
            "{\"name\": [\"x\", \"x\"],\n\"line\": [63, 63],\n\"col\": [5, 5],\n\"operation\": [\"W\", \"W\"]}"
        ]
    },
    {
        "ID": "011",
        "name": "DRB011-minusminus-orig-yes.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/* \nThe -- operation on numNodes2 is not protected, causing data race.\nData race pair: numNodes2@74:7:W vs. numNodes2@74:7:W\n*/\n\n#include <stdlib.h>  \n#include <stdio.h>\nint main(int argc, char* argv[])  \n{\n  int i;\n  int len=100;\n\n  int numNodes=len, numNodes2=0; \n  int x[100]; \n\n  // initialize x[]\n  for (i=0; i< len; i++)\n  {\n    if (i%2==0)\n      x[i]=5;\n    else\n      x[i]= -5;\n  }\n\n#pragma omp parallel for\n  for (i=numNodes-1 ; i>-1 ; --i) {\n    if (x[i]<=0) {\n      numNodes2-- ;\n    }\n  }\n  printf (\"numNodes2 = %d\\n\", numNodes2);\n  return 0;\n} \n",
        "data_race": 1,
        "trimmed_code": "#include <stdlib.h>  \n#include <stdio.h>\nint main(int argc, char* argv[])  \n{\n  int i;\n  int len=100;\n\n  int numNodes=len, numNodes2=0; \n  int x[100]; \n\n  \n  for (i=0; i< len; i++)\n  {\n    if (i%2==0)\n      x[i]=5;\n    else\n      x[i]= -5;\n  }\n\n#pragma omp parallel for\n  for (i=numNodes-1 ; i>-1 ; --i) {\n    if (x[i]<=0) {\n      numNodes2-- ;\n    }\n  }\n  printf (\"numNodes2 = %d\\n\", numNodes2);\n  return 0;\n} \n",
        "code_len": 412,
        "data_race_label": "Y3",
        "var_pairs": [
            "{\"name\": [\"numNodes2\", \"numNodes2\"],\n\"line\": [74, 74],\n\"col\": [7, 7],\n\"operation\": [\"W\", \"W\"]}"
        ]
    },
    {
        "ID": "012",
        "name": "DRB012-minusminus-var-yes.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/* \nThe -- operation is not protected, causing race condition.\nData race pair: numNodes2@74:7:W vs. numNodes2@74:7:W\n*/\n#include <stdlib.h>  \nint main(int argc, char* argv[])  \n{\n  int i;\n  int len=100;\n\n  if (argc>1)\n    len = atoi(argv[1]);\n\n  int numNodes=len, numNodes2=0; \n  int x[len]; \n\n  for (i=0; i< len; i++)\n  {\n    if (i%2==0)\n      x[i]=5;\n    else\n      x[i]= -5;\n  }\n\n#pragma omp parallel for\n  for (i=numNodes-1 ; i>-1 ; --i) {\n    if (x[i]<=0) {\n      numNodes2-- ;\n    }\n  }         \n  return 0;\n} \n",
        "data_race": 1,
        "trimmed_code": "#include <stdlib.h>  \nint main(int argc, char* argv[])  \n{\n  int i;\n  int len=100;\n\n  if (argc>1)\n    len = atoi(argv[1]);\n\n  int numNodes=len, numNodes2=0; \n  int x[len]; \n\n  for (i=0; i< len; i++)\n  {\n    if (i%2==0)\n      x[i]=5;\n    else\n      x[i]= -5;\n  }\n\n#pragma omp parallel for\n  for (i=numNodes-1 ; i>-1 ; --i) {\n    if (x[i]<=0) {\n      numNodes2-- ;\n    }\n  }         \n  return 0;\n} \n",
        "code_len": 397,
        "data_race_label": "Y3",
        "var_pairs": [
            "{\"name\": [\"numNodes2\", \"numNodes2\"],\n\"line\": [74, 74],\n\"col\": [7, 7],\n\"operation\": [\"W\", \"W\"]}"
        ]
    },
    {
        "ID": "013",
        "name": "DRB013-nowait-orig-yes.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/*\nThis example is extracted from a paper: \nMa etc. Symbolic Analysis of Concurrency Errors in OpenMP Programs, ICPP 2013\n\nSome threads may finish the for loop early and execute errors = dt[9]+1\nwhile another thread may still be simultaneously executing\nthe for worksharing region by writing to d[9], causing data races. \n\nData race pair: a[i]@72:7:W vs. a[9]@75:13:R\n*/\n\n#include <stdio.h>\nint main()\n{\n  int i,error;\n  int len = 1000;\n  int a[len], b=5;\n\n  for (i=0; i<len; i++)\n    a[i]= i;\n \n#pragma omp parallel shared(b, error) \n  {\n#pragma omp for nowait\n    for(i = 0; i < len; i++)\n      a[i] = b + a[i]*5;\n\n#pragma omp single\n    error = a[9] + 1;\n  }\n\n  printf (\"error = %d\\n\", error);\n  return 0;\n}  \n",
        "data_race": 1,
        "trimmed_code": "#include <stdio.h>\nint main()\n{\n  int i,error;\n  int len = 1000;\n  int a[len], b=5;\n\n  for (i=0; i<len; i++)\n    a[i]= i;\n \n#pragma omp parallel shared(b, error) \n  {\n#pragma omp for nowait\n    for(i = 0; i < len; i++)\n      a[i] = b + a[i]*5;\n\n#pragma omp single\n    error = a[9] + 1;\n  }\n\n  printf (\"error = %d\\n\", error);\n  return 0;\n}  \n",
        "code_len": 341,
        "data_race_label": "Y3",
        "var_pairs": [
            "{\"name\": [\"a[i]\", \"a[9]\"],\n\"line\": [72, 75],\n\"col\": [7, 13],\n\"operation\": [\"W\", \"R\"]}"
        ]
    },
    {
        "ID": "014",
        "name": "DRB014-outofbounds-orig-yes.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/* \nThe outmost loop is parallelized.\nBut the inner level loop has out of bound access for b[i][j] when j equals to 0.\nThis will case memory access of a previous row's last element.\n\nFor example, an array of 4x4: \n    j=0 1 2 3\n i=0  x x x x\n   1  x x x x\n   2  x x x x\n   3  x x x x\n  outer loop: i=2, \n  inner loop: j=0\n  array element accessed b[i][j-1] becomes b[2][-1], which in turn is b[1][3]\n  due to linearized row-major storage of the 2-D array.\n  This causes loop-carried data dependence between i=2 and i=1.\n\nData race pair: b[i][j]@75:7:W vs. b[i][j-1]@75:15:R\n*/\n#include <stdio.h>\nint main(int argc, char* argv[]) \n{\n  int i,j;\n  int n=100, m=100;\n  double b[n][m];\n#pragma omp parallel for private(j)\n  for (i=1;i<n;i++)\n    for (j=0;j<m;j++) // Note there will be out of bound access\n      b[i][j]=b[i][j-1];\n\n  printf (\"b[50][50]=%f\\n\",b[50][50]);\n\n  return 0;     \n}\n  \n",
        "data_race": 1,
        "trimmed_code": "#include <stdio.h>\nint main(int argc, char* argv[]) \n{\n  int i,j;\n  int n=100, m=100;\n  double b[n][m];\n#pragma omp parallel for private(j)\n  for (i=1;i<n;i++)\n    for (j=0;j<m;j++) \n      b[i][j]=b[i][j-1];\n\n  printf (\"b[50][50]=%f\\n\",b[50][50]);\n\n  return 0;     \n}\n  \n",
        "code_len": 271,
        "data_race_label": "Y6",
        "var_pairs": [
            "{\"name\": [\"b[i][j]\", \"b[i][j-1]\"],\n\"line\": [75, 75],\n\"col\": [7, 15],\n\"operation\": [\"W\", \"R\"]}"
        ]
    },
    {
        "ID": "015",
        "name": "DRB015-outofbounds-var-yes.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/* \nThe outmost loop is be parallelized.\nBut the inner level loop has out of bound access for b[i][j] when j equals to 0.\nThis will case memory access of a previous row's last element.\n\nFor example, an array of 4x4: \n    j=0 1 2 3\n i=0  x x x x\n   1  x x x x\n   2  x x x x\n   3  x x x x\n   \n  outer loop: i=2, \n  inner loop: j=0\n  array element accessed b[i][j-1] becomes b[2][-1], which in turn is b[1][3]\n  due to linearized row-major storage of the 2-D array.\n\nThis causes loop-carried data dependence between i=2 and i=1.\nData race pair: b[i][j]@80:7:W vs. b[i][j-1]@80:15:R\n*/\n#include <stdlib.h>\nint main(int argc, char* argv[]) \n{\n  int i,j;\n  int len=100;\n  if (argc>1)\n    len = atoi(argv[1]);\n\n  int n=len, m=len;\n  double b[n][m];\n#pragma omp parallel for private(j)\n  for (i=1;i<n;i++)\n    for (j=0;j<m;j++) // Note there will be out of bound access\n      b[i][j]=b[i][j-1];\n\n return 0;     \n}\n  \n",
        "data_race": 1,
        "trimmed_code": "#include <stdlib.h>\nint main(int argc, char* argv[]) \n{\n  int i,j;\n  int len=100;\n  if (argc>1)\n    len = atoi(argv[1]);\n\n  int n=len, m=len;\n  double b[n][m];\n#pragma omp parallel for private(j)\n  for (i=1;i<n;i++)\n    for (j=0;j<m;j++) \n      b[i][j]=b[i][j-1];\n\n return 0;     \n}\n  \n",
        "code_len": 286,
        "data_race_label": "Y6",
        "var_pairs": [
            "{\"name\": [\"b[i][j]\", \"b[i][j-1]\"],\n\"line\": [80, 80],\n\"col\": [7, 15],\n\"operation\": [\"W\", \"R\"]}"
        ]
    },
    {
        "ID": "016",
        "name": "DRB016-outputdep-orig-yes.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/* \nThe loop in this example cannot be parallelized.\n\nThis pattern has two pair of dependencies:  \n1. loop carried output dependence\n x = .. : \n\n2. loop carried true dependence due to: \n.. = x;\n x = ..; \nData race pairs: we allow two pairs to preserve the original code pattern.\n 1. x@73:12:R vs. x@74:5:W \n 2. x@74:5:W vs. x@74:5:W\n*/\n\n#include <stdio.h>\nint a[100];\n\nint main()\n{\n  int len=100; \n  int i,x=10;\n\n#pragma omp parallel for \n  for (i=0;i<len;i++)\n  {\n    a[i] = x;\n    x=i;\n  }\n  printf(\"x=%d\",x);    \n  return 0;\n} \n\n",
        "data_race": 1,
        "trimmed_code": "#include <stdio.h>\nint a[100];\n\nint main()\n{\n  int len=100; \n  int i,x=10;\n\n#pragma omp parallel for \n  for (i=0;i<len;i++)\n  {\n    a[i] = x;\n    x=i;\n  }\n  printf(\"x=%d\",x);    \n  return 0;\n} \n\n",
        "code_len": 195,
        "data_race_label": "Y1",
        "var_pairs": [
            "I apologize for the confusion. Here is the updated example:\n\nInput: ['Data race pair: a[i+1]@64:10:R vs. a[i]@64:5:W', 'Data race pair: b[j-1]@72:15:W vs. b[j]@72:20:R']\n\nOutput:\n{\n  \"name\": [\"a[i+1]\", \"a[i]\", \"b[j-1]\", \"b[j]\"],\n  \"line\": [64, 64, 72, 72],\n  \"col\": [10, 5, 15, 20],\n  \"operation\": [\"R\", \"W\", \"W\", \"R\"]\n}"
        ]
    },
    {
        "ID": "017",
        "name": "DRB017-outputdep-var-yes.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/*\nThe loop in this example cannot be parallelized.\n\nData race pairs: we allow two pairs to preserve the original code pattern.\n 1. x@71:12:R vs. x@72:5:W\n 2. x@72:5:W vs. x@72:5:W\n*/\n\n#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char* argv[])\n{\n  int len=100; \n\n  if (argc>1)\n    len = atoi(argv[1]);\n\n  int a[len];\n  int i,x=10;\n\n#pragma omp parallel for \n  for (i=0;i<len;i++)\n  {\n    a[i] = x;\n    x=i;\n  }\n  printf(\"x=%d, a[0]=%d\\n\",x,a[0]);    \n  return 0;\n} \n\n",
        "data_race": 1,
        "trimmed_code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char* argv[])\n{\n  int len=100; \n\n  if (argc>1)\n    len = atoi(argv[1]);\n\n  int a[len];\n  int i,x=10;\n\n#pragma omp parallel for \n  for (i=0;i<len;i++)\n  {\n    a[i] = x;\n    x=i;\n  }\n  printf(\"x=%d, a[0]=%d\\n\",x,a[0]);    \n  return 0;\n} \n\n",
        "code_len": 296,
        "data_race_label": "Y1",
        "var_pairs": [
            "I apologize for the confusion. Here is the updated example:\n\nInput: ['Data race pair: a[i+1]@64:10:R vs. a[i]@64:5:W', 'Data race pair: b[j-1]@72:15:W vs. b[j]@72:20:R']\n\nOutput:\n{\n  \"name\": [\"a[i+1]\", \"a[i]\", \"b[j-1]\", \"b[j]\"],\n  \"line\": [64, 64, 72, 72],\n  \"col\": [10, 5, 15, 20],\n  \"operation\": [\"R\", \"W\", \"W\", \"R\"]\n}"
        ]
    },
    {
        "ID": "018",
        "name": "DRB018-plusplus-orig-yes.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/* Data race on outLen due to ++ operation.\nAdding private (outLen) can avoid race condition. But it is wrong semantically.\nData races on outLen also cause output[outLen++] to have data races.\n\nData race pairs (we allow two pairs to preserve the original code pattern):\n1. outLen@72:12:W vs. outLen@72:12:W\n2. output[]@72:5:W vs. output[]@72:5:W\n*/\n#include <stdlib.h>\n#include <stdio.h>\nint input[1000]; \nint output[1000];\n\nint main()\n{\n  int i ;\n  int inLen=1000 ; \n  int outLen = 0;\n\n  for (i=0; i<inLen; ++i) \n    input[i]= i;  \n\n#pragma omp parallel for\n  for (i=0; i<inLen; ++i) \n  {\n    output[outLen++] = input[i] ;\n  }  \n\n  printf(\"output[500]=%d\\n\",output[500]);\n\n  return 0;\n}\n",
        "data_race": 1,
        "trimmed_code": "#include <stdlib.h>\n#include <stdio.h>\nint input[1000]; \nint output[1000];\n\nint main()\n{\n  int i ;\n  int inLen=1000 ; \n  int outLen = 0;\n\n  for (i=0; i<inLen; ++i) \n    input[i]= i;  \n\n#pragma omp parallel for\n  for (i=0; i<inLen; ++i) \n  {\n    output[outLen++] = input[i] ;\n  }  \n\n  printf(\"output[500]=%d\\n\",output[500]);\n\n  return 0;\n}\n",
        "code_len": 339,
        "data_race_label": "Y1",
        "var_pairs": [
            "Please provide the data race pairs in the format mentioned above."
        ]
    },
    {
        "ID": "019",
        "name": "DRB019-plusplus-var-yes.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n/* \nRace condition on outLen due to unprotected writes.\nAdding private (outLen) can avoid race condition. But it is wrong semantically.\n\nData race pairs: we allow two pair to preserve the original code pattern.\n1. outLen@72:12:W vs. outLen@72:12:W\n2. output[]@72:5:W vs. output[]@72:5:W\n*/\n#include <stdlib.h>\n#include <stdio.h>\nint main(int argc, char* argv[])\n{\n  int i ;\n  int inLen=1000 ; \n  int outLen = 0;\n\n  if (argc>1)\n    inLen= atoi(argv[1]);\n\n  int input[inLen]; \n  int output[inLen];\n  for (i=0; i<inLen; ++i) \n    input[i]=i; \n\n#pragma omp parallel for\n  for (i=0; i<inLen; ++i) {\n    output[outLen++] = input[i] ;\n  }  \n\n  printf(\"output[0]=%d\\n\", output[0]);\n  return 0;\n}\n",
        "data_race": 1,
        "trimmed_code": "#include <stdlib.h>\n#include <stdio.h>\nint main(int argc, char* argv[])\n{\n  int i ;\n  int inLen=1000 ; \n  int outLen = 0;\n\n  if (argc>1)\n    inLen= atoi(argv[1]);\n\n  int input[inLen]; \n  int output[inLen];\n  for (i=0; i<inLen; ++i) \n    input[i]=i; \n\n#pragma omp parallel for\n  for (i=0; i<inLen; ++i) {\n    output[outLen++] = input[i] ;\n  }  \n\n  printf(\"output[0]=%d\\n\", output[0]);\n  return 0;\n}\n",
        "code_len": 398,
        "data_race_label": "Y1",
        "var_pairs": [
            "I understand. Here is the code to parse the meta information and generate the JSON output:\n\n```python\nimport re\nimport json\n\ndef parse_meta_information(meta_info):\n    data_race_pairs = []\n    for info in meta_info:\n        match = re.search(r'(.*) vs. (.*)@(\\d+):(\\d+):(\\w)', info)\n        if match:\n            pair = {\n                \"name\": [match.group(1), match.group(2)],\n                \"line\": [int(match.group(3)), int(match.group(3))],\n                \"col\": [int(match.group(4)), int(match.group(4))],\n                \"operation\": [match.group(5), match.group(5)]\n            }\n            data_race_pairs.append(pair)\n    return json.dumps(data_race_pairs)\n\n# Example usage\nmeta_info = ['Data race pair: a[i+1]@64:10:R vs. a[i]@64:5:W']\noutput = parse_meta_information(meta_info)\nprint(output)\n```\n\nOutput:\n```\n[{\"name\": [\"a[i+1]\", \"a[i]\"], \"line\": [64, 64], \"col\": [10, 5], \"operation\": [\"R\","
        ]
    },
    {
        "ID": "020",
        "name": "DRB020-privatemissing-var-yes.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n/*\ntmp should be put as private to avoid race condition\nData race pair: tmp@65:5:W vs. tmp@66:12:R\n*/\n#include <stdlib.h>\nint main(int argc, char* argv[])\n{\n  int i;\n  int tmp;\n  int len=100;\n  if (argc>1)\n    len = atoi(argv[1]);\n  int a[len];\n  for (i=0;i<len;i++)\n    a[i]=i;\n\n#pragma omp parallel for\n  for (i=0;i<len;i++)\n  {\n    tmp =a[i]+i;\n    a[i] = tmp;\n  }\n  return 0;\n}\n",
        "data_race": 1,
        "trimmed_code": "#include <stdlib.h>\nint main(int argc, char* argv[])\n{\n  int i;\n  int tmp;\n  int len=100;\n  if (argc>1)\n    len = atoi(argv[1]);\n  int a[len];\n  for (i=0;i<len;i++)\n    a[i]=i;\n\n#pragma omp parallel for\n  for (i=0;i<len;i++)\n  {\n    tmp =a[i]+i;\n    a[i] = tmp;\n  }\n  return 0;\n}\n",
        "code_len": 280,
        "data_race_label": "Y2",
        "var_pairs": [
            "{\"name\": [\"tmp\", \"tmp\"],\n\"line\": [65, 66],\n\"col\": [5, 12],\n\"operation\": [\"W\", \"R\"]}"
        ]
    },
    {
        "ID": "021",
        "name": "DRB021-reductionmissing-orig-yes.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n/*\nA kernel with two level parallelizable loop with reduction:\nif reduction(+:sum) is missing, there is race condition.\nData race pairs: we allow multiple pairs to preserve the pattern.\n  sum@70:7:W vs. sum@70:7:W\n  sum@70:7:W vs. sum@70:13:R\n*/\n#include <stdio.h>\nint main(int argc, char* argv[])\n{\n  int i,j;\n  float temp, sum=0.0;\n  int len=100;\n\n  float u[100][100];\n  for (i = 0; i < len; i++)\n    for (j = 0; j < len; j++)\n        u[i][j] = 0.5; \n\n#pragma omp parallel for private (temp,i,j)\n  for (i = 0; i < len; i++)\n    for (j = 0; j < len; j++)\n    {\n      temp = u[i][j];\n      sum = sum + temp * temp;\n    }\n\n  printf (\"sum = %f\\n\", sum);  \n  return 0;\n}\n",
        "data_race": 1,
        "trimmed_code": "#include <stdio.h>\nint main(int argc, char* argv[])\n{\n  int i,j;\n  float temp, sum=0.0;\n  int len=100;\n\n  float u[100][100];\n  for (i = 0; i < len; i++)\n    for (j = 0; j < len; j++)\n        u[i][j] = 0.5; \n\n#pragma omp parallel for private (temp,i,j)\n  for (i = 0; i < len; i++)\n    for (j = 0; j < len; j++)\n    {\n      temp = u[i][j];\n      sum = sum + temp * temp;\n    }\n\n  printf (\"sum = %f\\n\", sum);  \n  return 0;\n}\n",
        "code_len": 422,
        "data_race_label": "Y2",
        "var_pairs": [
            "Sure, here's the updated code to handle multiple data race pairs:\n\n```python\nimport re\nimport json\n\ndef parse_data_race_pairs(data_race_pairs):\n    result = {\n        \"name\": [],\n        \"line\": [],\n        \"col\": [],\n        \"operation\": []\n    }\n    \n    for pair in data_race_pairs:\n        match = re.search(r'(.*)@(\\d+):(\\d+):(\\w)\\s+vs.\\s+(.*)@(\\d+):(\\d+):(\\w)', pair)\n        if match:\n            result[\"name\"].append(match.group(1))\n            result[\"name\"].append(match.group(5))\n            result[\"line\"].append(int(match.group(2)))\n            result[\"line\"].append(int(match.group(6)))\n            result[\"col\"].append(int(match.group(3)))\n            result[\"col\"].append(int(match.group(7)))\n            result[\"operation\"].append(match.group(4))\n            result[\"operation\"].append(match.group(8))\n    \n    return json.dumps(result)\n\ndata_race_pairs = ['Data race pair: a[i+1]@64:10:R vs. a[i]@64:5:W', 'Data race pair: b[j]@72:15"
        ]
    },
    {
        "ID": "022",
        "name": "DRB022-reductionmissing-var-yes.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n/* \nA kernel for two level parallelizable loop with reduction:\nif reduction(+:sum) is missing, there is race condition.\nData race pairs: \n  sum@72:7:W vs. sum@72:7:W \n  sum@72:7:W vs. sum@72:13:R\n*/\n#include <stdio.h>\n#include <stdlib.h>\nint main(int argc, char* argv[])\n{\n  int i,j;\n  float temp, sum=0.0;\n  int len=100;\n  if (argc>1)\n    len = atoi(argv[1]);\n  float u[len][len];\n  for (i = 0; i < len; i++)\n    for (j = 0; j < len; j++)\n        u[i][j] = 0.5;\n\n#pragma omp parallel for private (temp,i,j)\n  for (i = 0; i < len; i++)\n    for (j = 0; j < len; j++)\n    {\n      temp = u[i][j];\n      sum = sum + temp * temp;\n    }\n  printf (\"sum = %f\\n\", sum); \n  return 0;\n}\n",
        "data_race": 1,
        "trimmed_code": "#include <stdio.h>\n#include <stdlib.h>\nint main(int argc, char* argv[])\n{\n  int i,j;\n  float temp, sum=0.0;\n  int len=100;\n  if (argc>1)\n    len = atoi(argv[1]);\n  float u[len][len];\n  for (i = 0; i < len; i++)\n    for (j = 0; j < len; j++)\n        u[i][j] = 0.5;\n\n#pragma omp parallel for private (temp,i,j)\n  for (i = 0; i < len; i++)\n    for (j = 0; j < len; j++)\n    {\n      temp = u[i][j];\n      sum = sum + temp * temp;\n    }\n  printf (\"sum = %f\\n\", sum); \n  return 0;\n}\n",
        "code_len": 477,
        "data_race_label": "Y2",
        "var_pairs": [
            "Please provide the data race pairs in the format mentioned above."
        ]
    },
    {
        "ID": "023",
        "name": "DRB023-sections1-orig-yes.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/* \nTwo tasks without synchronization to protect data write, causing data races.\nData race pair: i@58:5:W vs. i@60:5:W\n*/\n#include <stdio.h> \nint main()\n{\n  int i=0;\n#pragma omp parallel sections\n  {\n#pragma omp section\n    i = 1;    \n#pragma omp section\n    i = 2;    \n  }\n  printf(\"i=%d\\n\",i);\n  return 0;\n} \n",
        "data_race": 1,
        "trimmed_code": "#include <stdio.h> \nint main()\n{\n  int i=0;\n#pragma omp parallel sections\n  {\n#pragma omp section\n    i = 1;    \n#pragma omp section\n    i = 2;    \n  }\n  printf(\"i=%d\\n\",i);\n  return 0;\n} \n",
        "code_len": 189,
        "data_race_label": "Y2",
        "var_pairs": [
            "{\"name\": [\"i\", \"i\"],\n\"line\": [58, 60],\n\"col\": [5, 5],\n\"operation\": [\"W\", \"W\"]}"
        ]
    },
    {
        "ID": "024",
        "name": "DRB024-simdtruedep-orig-yes.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n/* \nThis one has data races due to true dependence.\nBut data races happen at instruction level, not thread level. \nData race pair: a[i+1]@66:5:W vs. a[i]@66:12:R\n*/\n#include <stdio.h>\nint main(int argc, char* argv[])\n{\n  int i;\n  int len=100;\n  int a[100], b[100];\n\n  for (i=0;i<len;i++)\n  {\n    a[i]=i;\n    b[i]=i+1;\n  }\n\n#pragma omp simd \n  for (i=0;i<len-1;i++)\n    a[i+1]=a[i]+b[i];\n\n  for (i=0;i<len;i++)\n    printf(\"i=%d a[%d]=%d\\n\",i,i,a[i]);\n  return 0;\n}\n",
        "data_race": 1,
        "trimmed_code": "#include <stdio.h>\nint main(int argc, char* argv[])\n{\n  int i;\n  int len=100;\n  int a[100], b[100];\n\n  for (i=0;i<len;i++)\n  {\n    a[i]=i;\n    b[i]=i+1;\n  }\n\n#pragma omp simd \n  for (i=0;i<len-1;i++)\n    a[i+1]=a[i]+b[i];\n\n  for (i=0;i<len;i++)\n    printf(\"i=%d a[%d]=%d\\n\",i,i,a[i]);\n  return 0;\n}\n",
        "code_len": 299,
        "data_race_label": "Y3",
        "var_pairs": [
            "{\"name\": [\"a[i+1]\", \"a[i]\"],\n\"line\": [66, 66],\n\"col\": [5, 12],\n\"operation\": [\"W\", \"R\"]}"
        ]
    },
    {
        "ID": "025",
        "name": "DRB025-simdtruedep-var-yes.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n/*\nThis one has race condition due to true dependence.\nBut data races happen at instruction level, not thread level.\nData race pair: a[i+1]@68:5:W vs. a[i]@68:12:R  \n*/\n#include <stdlib.h>\nint main(int argc, char* argv[])\n{\n  int i;\n  int len=100;\n\n  if (argc>1)\n    len = atoi(argv[1]);\n\n  int a[len], b[len];\n  for (i=0;i<len;i++)\n  {\n    a[i]=i;\n    b[i]=i+1;\n  }\n#pragma omp simd\n  for (i=0;i<len-1;i++)\n    a[i+1]=a[i]*b[i];\n  return 0;\n}\n",
        "data_race": 1,
        "trimmed_code": "#include <stdlib.h>\nint main(int argc, char* argv[])\n{\n  int i;\n  int len=100;\n\n  if (argc>1)\n    len = atoi(argv[1]);\n\n  int a[len], b[len];\n  for (i=0;i<len;i++)\n  {\n    a[i]=i;\n    b[i]=i+1;\n  }\n#pragma omp simd\n  for (i=0;i<len-1;i++)\n    a[i+1]=a[i]*b[i];\n  return 0;\n}\n",
        "code_len": 275,
        "data_race_label": "Y1,Y4",
        "var_pairs": [
            "{\"name\": [\"a[i+1]\", \"a[i]\"],\n\"line\": [68, 68],\n\"col\": [5, 12],\n\"operation\": [\"W\", \"R\"]}"
        ]
    },
    {
        "ID": "026",
        "name": "DRB026-targetparallelfor-orig-yes.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/* \nRace condition due to anti-dependence within a loop offloaded to accelerators.\nData race pair: a[i]@64:5:W vs. a[i+1]@64:10:R\n*/\n\nint main(int argc, char* argv[])\n{\n  int i;\n  int len = 1000;\n  int a[1000];\n\n  for (i=0; i<len; i++)\n    a[i]= i;\n\n#pragma omp target map(a[0:len])\n#pragma omp parallel for\n  for (i=0;i< len -1 ;i++)\n    a[i]=a[i+1]+1;\n\n  return 0;\n}\n",
        "data_race": 1,
        "trimmed_code": "int main(int argc, char* argv[])\n{\n  int i;\n  int len = 1000;\n  int a[1000];\n\n  for (i=0; i<len; i++)\n    a[i]= i;\n\n#pragma omp target map(a[0:len])\n#pragma omp parallel for\n  for (i=0;i< len -1 ;i++)\n    a[i]=a[i+1]+1;\n\n  return 0;\n}\n",
        "code_len": 235,
        "data_race_label": "Y1,Y4",
        "var_pairs": [
            "{\"name\": [\"a[i]\", \"a[i+1]\"],\n\"line\": [64, 64],\n\"col\": [5, 10],\n\"operation\": [\"W\", \"R\"]}"
        ]
    },
    {
        "ID": "027",
        "name": "DRB027-taskdependmissing-orig-yes.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/*\nTwo tasks without depend clause to protect data writes. \ni is shared for two tasks based on implicit data-sharing attribute rules.\nData race pair: i@61:5:W vs. i@63:5:W  \n*/\n#include <assert.h> \n#include <stdio.h> \nint main()\n{\n  int i=0;\n#pragma omp parallel\n#pragma omp single\n  {\n#pragma omp task\n    i = 1;    \n#pragma omp task\n    i = 2;    \n  }\n\n  printf (\"i=%d\\n\",i);\n  return 0;\n} \n",
        "data_race": 1,
        "trimmed_code": "#include <assert.h> \n#include <stdio.h> \nint main()\n{\n  int i=0;\n#pragma omp parallel\n#pragma omp single\n  {\n#pragma omp task\n    i = 1;    \n#pragma omp task\n    i = 2;    \n  }\n\n  printf (\"i=%d\\n\",i);\n  return 0;\n} \n",
        "code_len": 216,
        "data_race_label": "Y1,Y5",
        "var_pairs": [
            "{\"name\": [\"i\", \"i\"],\n\"line\": [61, 63],\n\"col\": [5, 5],\n\"operation\": [\"W\", \"W\"]}"
        ]
    },
    {
        "ID": "028",
        "name": "DRB028-privatemissing-orig-yes.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n/* \ntmp should be annotated as private to avoid race condition.\nData race pairs: tmp@65:5:W vs. tmp@66:12:R\n                 tmp@65:5:W vs. tmp@65:5:W\n*/\n#include <stdlib.h>\n#include <stdio.h>\nint main(int argc, char* argv[])\n{\n  int i;\n  int tmp;\n  int len=100;\n  int a[100];\n  for (i=0;i<len;i++)\n    a[i]=i;\n\n#pragma omp parallel for\n  for (i=0;i<len;i++)\n  {\n    tmp =a[i]+i;\n    a[i] = tmp;\n  }\n\n  printf(\"a[50]=%d\\n\", a[50]);\n  return 0;\n}\n",
        "data_race": 1,
        "trimmed_code": "#include <stdlib.h>\n#include <stdio.h>\nint main(int argc, char* argv[])\n{\n  int i;\n  int tmp;\n  int len=100;\n  int a[100];\n  for (i=0;i<len;i++)\n    a[i]=i;\n\n#pragma omp parallel for\n  for (i=0;i<len;i++)\n  {\n    tmp =a[i]+i;\n    a[i] = tmp;\n  }\n\n  printf(\"a[50]=%d\\n\", a[50]);\n  return 0;\n}\n",
        "code_len": 292,
        "data_race_label": "Y3",
        "var_pairs": [
            "{\"name\": [\"tmp\", \"tmp\"],\n\"line\": [65, 66],\n\"col\": [5, 12],\n\"operation\": [\"W\", \"R\"]}"
        ]
    },
    {
        "ID": "029",
        "name": "DRB029-truedep1-orig-yes.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/* \nThis program has data races due to true dependence within the loop at 63.\nData race pair: a[i+1]@64:5:W vs. a[i]@64:12:R\n*/\n#include <stdlib.h>\n#include <stdio.h>\nint main(int argc, char* argv[])\n{\n  int i;\n  int len=100;\n  int a[100];\n\n  for (i=0;i<len;i++)\n    a[i]=i;\n\n#pragma omp parallel for\n  for (i=0;i<len-1;i++)\n    a[i+1]=a[i]+1;\n\n  printf(\"a[50]=%d\\n\", a[50]);   \n  return 0;\n}\n",
        "data_race": 1,
        "trimmed_code": "#include <stdlib.h>\n#include <stdio.h>\nint main(int argc, char* argv[])\n{\n  int i;\n  int len=100;\n  int a[100];\n\n  for (i=0;i<len;i++)\n    a[i]=i;\n\n#pragma omp parallel for\n  for (i=0;i<len-1;i++)\n    a[i+1]=a[i]+1;\n\n  printf(\"a[50]=%d\\n\", a[50]);   \n  return 0;\n}\n",
        "code_len": 265,
        "data_race_label": "Y1",
        "var_pairs": [
            "{\"name\": [\"a[i+1]\", \"a[i]\"],\n\"line\": [64, 64],\n\"col\": [5, 12],\n\"operation\": [\"W\", \"R\"]}"
        ]
    },
    {
        "ID": "030",
        "name": "DRB030-truedep1-var-yes.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/* \nThis program has data races due to true dependence within a loop.\nData race pair: a[i+1]@68:5:W vs. a[i]@68:12:R\n*/\n#include <stdlib.h>\n#include <stdio.h>\n\nint main(int argc, char* argv[])\n{\n  int i;\n  int len=100;\n\n  if (argc>1)\n    len = atoi(argv[1]);\n\n  int a[len];\n  for (i=0;i<len;i++)\n    a[i]=i;\n\n#pragma omp parallel for\n  for (i=0;i<len-1;i++)\n    a[i+1]=a[i]+1;\n\n  return 0;\n}\n",
        "data_race": 1,
        "trimmed_code": "#include <stdlib.h>\n#include <stdio.h>\n\nint main(int argc, char* argv[])\n{\n  int i;\n  int len=100;\n\n  if (argc>1)\n    len = atoi(argv[1]);\n\n  int a[len];\n  for (i=0;i<len;i++)\n    a[i]=i;\n\n#pragma omp parallel for\n  for (i=0;i<len-1;i++)\n    a[i+1]=a[i]+1;\n\n  return 0;\n}\n",
        "code_len": 272,
        "data_race_label": "Y1",
        "var_pairs": [
            "{\"name\": [\"a[i+1]\", \"a[i]\"],\n\"line\": [68, 68],\n\"col\": [5, 12],\n\"operation\": [\"W\", \"R\"]}"
        ]
    },
    {
        "ID": "031",
        "name": "DRB031-truedepfirstdimension-orig-yes.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/* \nThere is a loop-carried true dependence within the outer level loop.\nData race pair: b[i][j]@66:7:W vs. b[i-1][j-1]@66:15:R\n */\n#include <stdlib.h>\n#include <stdio.h>\nint main(int argc, char* argv[])\n{\n  int i,j;\n  int n=1000, m=1000;\n  double b[1000][1000];\n\n  for (i=0; i<n; i++)\n    for (j=0; j<m; j++)\n      b[i][j] = 0.5; \n\n#pragma omp parallel for private(j)\n  for (i=1;i<n;i++)\n    for (j=1;j<m;j++)\n      b[i][j]=b[i-1][j-1];\n\n  printf(\"b[500][500]=%f\\n\", b[500][500]);  \n  return 0;\n}\n",
        "data_race": 1,
        "trimmed_code": "#include <stdlib.h>\n#include <stdio.h>\nint main(int argc, char* argv[])\n{\n  int i,j;\n  int n=1000, m=1000;\n  double b[1000][1000];\n\n  for (i=0; i<n; i++)\n    for (j=0; j<m; j++)\n      b[i][j] = 0.5; \n\n#pragma omp parallel for private(j)\n  for (i=1;i<n;i++)\n    for (j=1;j<m;j++)\n      b[i][j]=b[i-1][j-1];\n\n  printf(\"b[500][500]=%f\\n\", b[500][500]);  \n  return 0;\n}\n",
        "code_len": 366,
        "data_race_label": "Y1",
        "var_pairs": [
            "{\"name\": [\"b[i][j]\", \"b[i-1][j-1]\"],\n\"line\": [66, 66],\n\"col\": [7, 15],\n\"operation\": [\"W\", \"R\"]}"
        ]
    },
    {
        "ID": "032",
        "name": "DRB032-truedepfirstdimension-var-yes.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/* \nThe outer loop has a loop-carried true dependence.\nData race pair: b[i][j]@69:7:W vs. b[i-1][j-1]@69:15:R\n*/\n#include <stdlib.h>\nint main(int argc, char* argv[])\n{\n  int i,j;\n  int len = 1000;\n  if (argc>1)\n    len = atoi(argv[1]);\n\n  int n=len, m=len;\n  double b[len][len];\n\n  for (i=0; i<n; i++)\n    for (j=0; j<m; j++)\n      b[i][j] = 0.5; \n\n#pragma omp parallel for private(j)\n  for (i=1;i<n;i++)\n    for (j=1;j<m;j++)\n      b[i][j]=b[i-1][j-1];\n\n  return 0;\n}\n",
        "data_race": 1,
        "trimmed_code": "#include <stdlib.h>\nint main(int argc, char* argv[])\n{\n  int i,j;\n  int len = 1000;\n  if (argc>1)\n    len = atoi(argv[1]);\n\n  int n=len, m=len;\n  double b[len][len];\n\n  for (i=0; i<n; i++)\n    for (j=0; j<m; j++)\n      b[i][j] = 0.5; \n\n#pragma omp parallel for private(j)\n  for (i=1;i<n;i++)\n    for (j=1;j<m;j++)\n      b[i][j]=b[i-1][j-1];\n\n  return 0;\n}\n",
        "code_len": 356,
        "data_race_label": "Y1",
        "var_pairs": [
            "{\"name\": [\"b[i][j]\", \"b[i-1][j-1]\"],\n\"line\": [69, 69],\n\"col\": [7, 15],\n\"operation\": [\"W\", \"R\"]}"
        ]
    },
    {
        "ID": "033",
        "name": "DRB033-truedeplinear-orig-yes.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/* \nA linear expression is used as array subscription.\nData race pair: a[2*i+1]@64:5:W vs. a[i]@64:14:R\n*/\n#include <stdlib.h>\n#include <stdio.h>\nint main(int argc, char* argv[])\n{\n  int i;\n\n  int a[2000];\n\n  for (i=0; i<2000; i++)\n    a[i]=i; \n\n#pragma omp parallel for\n  for (i=0;i<1000;i++)\n    a[2*i+1]=a[i]+1;\n\n  printf(\"a[1001]=%d\\n\", a[1001]);  \n  return 0;\n}\n\n",
        "data_race": 1,
        "trimmed_code": "#include <stdlib.h>\n#include <stdio.h>\nint main(int argc, char* argv[])\n{\n  int i;\n\n  int a[2000];\n\n  for (i=0; i<2000; i++)\n    a[i]=i; \n\n#pragma omp parallel for\n  for (i=0;i<1000;i++)\n    a[2*i+1]=a[i]+1;\n\n  printf(\"a[1001]=%d\\n\", a[1001]);  \n  return 0;\n}\n\n",
        "code_len": 261,
        "data_race_label": "Y1",
        "var_pairs": [
            "{\"name\": [\"a[2*i+1]\", \"a[i]\"],\n\"line\": [64, 64],\n\"col\": [5, 14],\n\"operation\": [\"W\", \"R\"]}"
        ]
    },
    {
        "ID": "034",
        "name": "DRB034-truedeplinear-var-yes.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/* \nA linear expression is used as array subscription.\nData race pair: a[2*i+1]@66:5:W vs. a[i]@66:14:R\n*/\n#include <stdlib.h>\nint main(int argc, char* argv[])\n{\n  int i;\n  int len=2000;\n\n  if (argc>1)\n    len = atoi(argv[1]);\n  int a[len];\n\n  for (i=0; i<len; i++)\n    a[i]=i; \n\n#pragma omp parallel for\n  for (i=0;i<len/2;i++)\n    a[2*i+1]=a[i]+1;\n\n  return 0;\n}\n\n",
        "data_race": 1,
        "trimmed_code": "#include <stdlib.h>\nint main(int argc, char* argv[])\n{\n  int i;\n  int len=2000;\n\n  if (argc>1)\n    len = atoi(argv[1]);\n  int a[len];\n\n  for (i=0; i<len; i++)\n    a[i]=i; \n\n#pragma omp parallel for\n  for (i=0;i<len/2;i++)\n    a[2*i+1]=a[i]+1;\n\n  return 0;\n}\n\n",
        "code_len": 259,
        "data_race_label": "Y1",
        "var_pairs": [
            "{\"name\": [\"a[2*i+1]\", \"a[i]\"],\n\"line\": [66, 66],\n\"col\": [5, 14],\n\"operation\": [\"W\", \"R\"]}"
        ]
    },
    {
        "ID": "035",
        "name": "DRB035-truedepscalar-orig-yes.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/* \nLoop carried true dep between tmp =..  and ..= tmp.\nData race pair: tmp@66:12:R vs. tmp@67:5:W\n*/\n#include <stdlib.h>\n#include <stdio.h>\n\nint main(int argc, char* argv[])\n{ \n  int i; \n  int tmp;\n  tmp = 10;\n  int len=100;\n\n  int a[100];\n\n#pragma omp parallel for\n  for (i=0;i<len;i++)\n  { \n    a[i] = tmp;\n    tmp =a[i]+i;\n  }\n\n  printf(\"a[50]=%d\\n\", a[50]);\n  return 0;      \n}\n\n",
        "data_race": 1,
        "trimmed_code": "#include <stdlib.h>\n#include <stdio.h>\n\nint main(int argc, char* argv[])\n{ \n  int i; \n  int tmp;\n  tmp = 10;\n  int len=100;\n\n  int a[100];\n\n#pragma omp parallel for\n  for (i=0;i<len;i++)\n  { \n    a[i] = tmp;\n    tmp =a[i]+i;\n  }\n\n  printf(\"a[50]=%d\\n\", a[50]);\n  return 0;      \n}\n\n",
        "code_len": 282,
        "data_race_label": "Y1",
        "var_pairs": [
            "{\"name\": [\"tmp\", \"tmp\"],\n\"line\": [66, 67],\n\"col\": [12, 5],\n\"operation\": [\"R\", \"W\"]}"
        ]
    },
    {
        "ID": "036",
        "name": "DRB036-truedepscalar-var-yes.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/*  \nLoop carried true dep between tmp =..  and ..= tmp.\nData race pairs: tmp@66:12:R vs. tmp@67:5:W\n                 tmp@67:5:W vs. tmp@67:5:W\n*/\n#include <stdlib.h>\nint main(int argc, char* argv[])\n{ \n  int i; \n  int tmp;\n  tmp = 10;\n  int len=100;\n\n  if (argc>1)\n    len = atoi(argv[1]);\n\n  int a[len];\n#pragma omp parallel for\n  for (i=0;i<len;i++)\n  { \n    a[i] = tmp;\n    tmp =a[i]+i;\n  }     \n  return 0;      \n}\n\n",
        "data_race": 1,
        "trimmed_code": "#include <stdlib.h>\nint main(int argc, char* argv[])\n{ \n  int i; \n  int tmp;\n  tmp = 10;\n  int len=100;\n\n  if (argc>1)\n    len = atoi(argv[1]);\n\n  int a[len];\n#pragma omp parallel for\n  for (i=0;i<len;i++)\n  { \n    a[i] = tmp;\n    tmp =a[i]+i;\n  }     \n  return 0;      \n}\n\n",
        "code_len": 274,
        "data_race_label": "Y1",
        "var_pairs": [
            "{\"name\": [\"tmp\", \"tmp\"],\n\"line\": [66, 67],\n\"col\": [12, 5],\n\"operation\": [\"R\", \"W\"]}"
        ]
    },
    {
        "ID": "037",
        "name": "DRB037-truedepseconddimension-orig-yes.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/* \nOnly the outmost loop can be parallelized in this program.\nThe inner loop has true dependence.\nData race pair: b[i][j]@63:7:W vs. b[i][j-1]@63:15:R\n*/\n#include <stdlib.h>\n#include <stdio.h>\ndouble b[1000][1000];\n\nint main(int argc, char* argv[]) \n{\n  int i,j;\n  int n=1000, m=1000;\n  for (i=0;i<n;i++)\n#pragma omp parallel for\n    for (j=1;j<m;j++)\n      b[i][j]=b[i][j-1];\n\n  printf(\"b[500][500]=%f\\n\", b[500][500]);\n  return 0;\n}\n\n",
        "data_race": 1,
        "trimmed_code": "#include <stdlib.h>\n#include <stdio.h>\ndouble b[1000][1000];\n\nint main(int argc, char* argv[]) \n{\n  int i,j;\n  int n=1000, m=1000;\n  for (i=0;i<n;i++)\n#pragma omp parallel for\n    for (j=1;j<m;j++)\n      b[i][j]=b[i][j-1];\n\n  printf(\"b[500][500]=%f\\n\", b[500][500]);\n  return 0;\n}\n\n",
        "code_len": 282,
        "data_race_label": "Y1",
        "var_pairs": [
            "{\"name\": [\"b[i][j]\", \"b[i][j-1]\"],\n\"line\": [63, 63],\n\"col\": [7, 15],\n\"operation\": [\"W\", \"R\"]}"
        ]
    },
    {
        "ID": "038",
        "name": "DRB038-truedepseconddimension-var-yes.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/* \nOnly the outmost loop can be parallelized in this program.\nData race pair: b[i][j]@65:7:W vs. b[i][j-1]@65:15:R\n*/\n#include <stdlib.h>\nint main(int argc, char* argv[]) \n{\n  int i,j;\n  int len = 1000;\n  if (argc>1)\n    len = atoi(argv[1]);\n\n  int n=len, m=len;\n  double b[n][m];\n\n  for (i=0;i<n;i++)\n#pragma omp parallel for\n    for (j=1;j<m;j++)\n      b[i][j]=b[i][j-1];\n\n  return 0;\n}\n\n",
        "data_race": 1,
        "trimmed_code": "#include <stdlib.h>\nint main(int argc, char* argv[]) \n{\n  int i,j;\n  int len = 1000;\n  if (argc>1)\n    len = atoi(argv[1]);\n\n  int n=len, m=len;\n  double b[n][m];\n\n  for (i=0;i<n;i++)\n#pragma omp parallel for\n    for (j=1;j<m;j++)\n      b[i][j]=b[i][j-1];\n\n  return 0;\n}\n\n",
        "code_len": 272,
        "data_race_label": "Y1",
        "var_pairs": [
            "{\"name\": [\"b[i][j]\", \"b[i][j-1]\"],\n\"line\": [65, 65],\n\"col\": [7, 15],\n\"operation\": [\"W\", \"R\"]}"
        ]
    },
    {
        "ID": "039",
        "name": "DRB039-truedepsingleelement-orig-yes.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/*\nData race pair: a[i]@62:5:W vs. a[0]@62:15:R\n*/\n#include <stdlib.h>\n#include <stdio.h>\nint main (int argc, char* argv[])\n{\n  int len=1000;\n  int i; \n\n  int a[1000];\n  a[0] = 2;\n\n#pragma omp parallel for\n  for (i=0;i<len;i++)\n    a[i]=a[i]+a[0];\n\n  printf(\"a[500]=%d\\n\", a[500]);\n  return 0;\n}\n",
        "data_race": 1,
        "trimmed_code": "#include <stdlib.h>\n#include <stdio.h>\nint main (int argc, char* argv[])\n{\n  int len=1000;\n  int i; \n\n  int a[1000];\n  a[0] = 2;\n\n#pragma omp parallel for\n  for (i=0;i<len;i++)\n    a[i]=a[i]+a[0];\n\n  printf(\"a[500]=%d\\n\", a[500]);\n  return 0;\n}\n",
        "code_len": 245,
        "data_race_label": "Y1",
        "var_pairs": [
            "{\"name\": [\"a[i]\", \"a[0]\"],\n\"line\": [62, 62],\n\"col\": [5, 15],\n\"operation\": [\"W\", \"R\"]}"
        ]
    },
    {
        "ID": "040",
        "name": "DRB040-truedepsingleelement-var-yes.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/*\nData race pair: a[i]@63:5:W vs. a[0]@63:15:R\n*/\n#include <stdlib.h>\nint main (int argc, char* argv[])\n{\n  int len=1000;\n  int i; \n\n  if (argc>1)\n    len = atoi(argv[1]);\n  int a[len];\n  a[0] = 2;\n\n#pragma omp parallel for\n  for (i=0;i<len;i++)\n    a[i]=a[i]+a[0];\n\n  return 0;\n}\n",
        "data_race": 1,
        "trimmed_code": "#include <stdlib.h>\nint main (int argc, char* argv[])\n{\n  int len=1000;\n  int i; \n\n  if (argc>1)\n    len = atoi(argv[1]);\n  int a[len];\n  a[0] = 2;\n\n#pragma omp parallel for\n  for (i=0;i<len;i++)\n    a[i]=a[i]+a[0];\n\n  return 0;\n}\n",
        "code_len": 231,
        "data_race_label": "Y1",
        "var_pairs": [
            "{\"name\": [\"a[i]\", \"a[0]\"],\n\"line\": [63, 63],\n\"col\": [5, 15],\n\"operation\": [\"W\", \"R\"]}"
        ]
    },
    {
        "ID": "041",
        "name": "DRB041-3mm-parallel-no.c",
        "DRB_code": "/**\n * 3mm.c: This file is part of the PolyBench/C 3.2 test suite.\n * three steps of matrix multiplication to multiply four matrices. \n *\n * Contact: Louis-Noel Pouchet <pouchet@cse.ohio-state.edu>\n * Web address: http://polybench.sourceforge.net\n * License: /LICENSE.OSU.txt\n */\n#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <math.h>\n/* Include polybench common header. */\n#include \"polybench/polybench.h\"\n/* Include benchmark-specific header. */\n/* Default data type is double, default size is 4000. */\n#include \"polybench/3mm.h\"\n/* Array initialization. */\n\nstatic void init_array(int ni,int nj,int nk,int nl,int nm,double A[128 + 0][128 + 0],double B[128 + 0][128 + 0],double C[128 + 0][128 + 0],double D[128 + 0][128 + 0])\n{\n  //int i;\n  //int j;\n{\n    int c2;\n    int c1;\n    if (nl >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = 0; c1 <= ((((((ni + -1 < nj + -1?ni + -1 : nj + -1)) < nk + -1?((ni + -1 < nj + -1?ni + -1 : nj + -1)) : nk + -1)) < nm + -1?((((ni + -1 < nj + -1?ni + -1 : nj + -1)) < nk + -1?((ni + -1 < nj + -1?ni + -1 : nj + -1)) : nk + -1)) : nm + -1)); c1++) {\n        for (c2 = 0; c2 <= ((((((nj + -1 < nk + -1?nj + -1 : nk + -1)) < nl + -1?((nj + -1 < nk + -1?nj + -1 : nk + -1)) : nl + -1)) < nm + -1?((((nj + -1 < nk + -1?nj + -1 : nk + -1)) < nl + -1?((nj + -1 < nk + -1?nj + -1 : nk + -1)) : nl + -1)) : nm + -1)); c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n        for (c2 = nl; c2 <= ((((nj + -1 < nk + -1?nj + -1 : nk + -1)) < nm + -1?((nj + -1 < nk + -1?nj + -1 : nk + -1)) : nm + -1)); c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n        for (c2 = nm; c2 <= ((((nj + -1 < nk + -1?nj + -1 : nk + -1)) < nl + -1?((nj + -1 < nk + -1?nj + -1 : nk + -1)) : nl + -1)); c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n        for (c2 = (nl > nm?nl : nm); c2 <= ((nj + -1 < nk + -1?nj + -1 : nk + -1)); c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n        }\n        for (c2 = nj; c2 <= ((((nk + -1 < nl + -1?nk + -1 : nl + -1)) < nm + -1?((nk + -1 < nl + -1?nk + -1 : nl + -1)) : nm + -1)); c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n        for (c2 = (nj > nl?nj : nl); c2 <= ((nk + -1 < nm + -1?nk + -1 : nm + -1)); c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n        for (c2 = (nj > nm?nj : nm); c2 <= ((nk + -1 < nl + -1?nk + -1 : nl + -1)); c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n        for (c2 = (((nj > nl?nj : nl)) > nm?((nj > nl?nj : nl)) : nm); c2 <= nk + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n        }\n        for (c2 = nk; c2 <= ((((nj + -1 < nl + -1?nj + -1 : nl + -1)) < nm + -1?((nj + -1 < nl + -1?nj + -1 : nl + -1)) : nm + -1)); c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n        for (c2 = (nk > nl?nk : nl); c2 <= ((nj + -1 < nm + -1?nj + -1 : nm + -1)); c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n        for (c2 = (nk > nm?nk : nm); c2 <= ((nj + -1 < nl + -1?nj + -1 : nl + -1)); c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n        for (c2 = (((nk > nl?nk : nl)) > nm?((nk > nl?nk : nl)) : nm); c2 <= nj + -1; c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n        }\n        for (c2 = (nj > nk?nj : nk); c2 <= ((nl + -1 < nm + -1?nl + -1 : nm + -1)); c2++) {\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n        for (c2 = (((nj > nk?nj : nk)) > nl?((nj > nk?nj : nk)) : nl); c2 <= nm + -1; c2++) {\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n        for (c2 = (((nj > nk?nj : nk)) > nm?((nj > nk?nj : nk)) : nm); c2 <= nl + -1; c2++) {\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n      }\n    }\n    if (nl <= 0) {\n#pragma omp parallel for private(c2)\n      for (c1 = 0; c1 <= ((((((ni + -1 < nj + -1?ni + -1 : nj + -1)) < nk + -1?((ni + -1 < nj + -1?ni + -1 : nj + -1)) : nk + -1)) < nm + -1?((((ni + -1 < nj + -1?ni + -1 : nj + -1)) < nk + -1?((ni + -1 < nj + -1?ni + -1 : nj + -1)) : nk + -1)) : nm + -1)); c1++) {\n        for (c2 = 0; c2 <= ((((nj + -1 < nk + -1?nj + -1 : nk + -1)) < nm + -1?((nj + -1 < nk + -1?nj + -1 : nk + -1)) : nm + -1)); c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n        for (c2 = nm; c2 <= ((nj + -1 < nk + -1?nj + -1 : nk + -1)); c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n        }\n        for (c2 = nj; c2 <= ((nk + -1 < nm + -1?nk + -1 : nm + -1)); c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n        for (c2 = (nj > nm?nj : nm); c2 <= nk + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n        }\n        for (c2 = nk; c2 <= ((nj + -1 < nm + -1?nj + -1 : nm + -1)); c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n        for (c2 = (nk > nm?nk : nm); c2 <= nj + -1; c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n        }\n        for (c2 = (nj > nk?nj : nk); c2 <= nm + -1; c2++) {\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n      }\n    }\n    if (nm >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = nm; c1 <= ((((ni + -1 < nj + -1?ni + -1 : nj + -1)) < nk + -1?((ni + -1 < nj + -1?ni + -1 : nj + -1)) : nk + -1)); c1++) {\n        for (c2 = 0; c2 <= nm + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n        for (c2 = nm; c2 <= ((nj + -1 < nk + -1?nj + -1 : nk + -1)); c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n        }\n        for (c2 = nj; c2 <= nk + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n        }\n        for (c2 = nk; c2 <= nj + -1; c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n        }\n      }\n    }\n    if (nm <= 0) {\n#pragma omp parallel for private(c2)\n      for (c1 = 0; c1 <= ((((ni + -1 < nj + -1?ni + -1 : nj + -1)) < nk + -1?((ni + -1 < nj + -1?ni + -1 : nj + -1)) : nk + -1)); c1++) {\n        for (c2 = 0; c2 <= ((nj + -1 < nk + -1?nj + -1 : nk + -1)); c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n        }\n        for (c2 = nj; c2 <= nk + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n        }\n        for (c2 = nk; c2 <= nj + -1; c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n        }\n      }\n    }\n    if (nj >= 1 && nl >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = nj; c1 <= ((((ni + -1 < nk + -1?ni + -1 : nk + -1)) < nm + -1?((ni + -1 < nk + -1?ni + -1 : nk + -1)) : nm + -1)); c1++) {\n        for (c2 = 0; c2 <= ((nj + -1 < nl + -1?nj + -1 : nl + -1)); c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n        for (c2 = nl; c2 <= nj + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n        }\n        for (c2 = nj; c2 <= ((nk + -1 < nl + -1?nk + -1 : nl + -1)); c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n        for (c2 = (nj > nl?nj : nl); c2 <= nk + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n        }\n        for (c2 = nk; c2 <= nl + -1; c2++) {\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n      }\n    }\n    if (nj >= 1 && nl <= 0) {\n#pragma omp parallel for private(c2)\n      for (c1 = nj; c1 <= ((((ni + -1 < nk + -1?ni + -1 : nk + -1)) < nm + -1?((ni + -1 < nk + -1?ni + -1 : nk + -1)) : nm + -1)); c1++) {\n        for (c2 = 0; c2 <= nj + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n        }\n        for (c2 = nj; c2 <= nk + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n        }\n      }\n    }\n    if (nj >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = (nj > nm?nj : nm); c1 <= ((ni + -1 < nk + -1?ni + -1 : nk + -1)); c1++) {\n        for (c2 = 0; c2 <= nj + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n        }\n        for (c2 = nj; c2 <= nk + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n        }\n      }\n    }\n    if (nj <= 0 && nl >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = 0; c1 <= ((((ni + -1 < nk + -1?ni + -1 : nk + -1)) < nm + -1?((ni + -1 < nk + -1?ni + -1 : nk + -1)) : nm + -1)); c1++) {\n        for (c2 = 0; c2 <= ((nk + -1 < nl + -1?nk + -1 : nl + -1)); c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n        for (c2 = nl; c2 <= nk + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n        }\n        for (c2 = nk; c2 <= nl + -1; c2++) {\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n      }\n    }\n    if (nj <= 0 && nl <= 0) {\n#pragma omp parallel for private(c2)\n      for (c1 = 0; c1 <= ((((ni + -1 < nk + -1?ni + -1 : nk + -1)) < nm + -1?((ni + -1 < nk + -1?ni + -1 : nk + -1)) : nm + -1)); c1++) {\n        for (c2 = 0; c2 <= nk + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n        }\n      }\n    }\n    if (nj <= 0) {\n#pragma omp parallel for private(c2)\n      for (c1 = (0 > nm?0 : nm); c1 <= ((ni + -1 < nk + -1?ni + -1 : nk + -1)); c1++) {\n        for (c2 = 0; c2 <= nk + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n        }\n      }\n    }\n    if (nk >= 1 && nl >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = nk; c1 <= ((((ni + -1 < nj + -1?ni + -1 : nj + -1)) < nm + -1?((ni + -1 < nj + -1?ni + -1 : nj + -1)) : nm + -1)); c1++) {\n        for (c2 = 0; c2 <= ((nk + -1 < nl + -1?nk + -1 : nl + -1)); c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n        for (c2 = nl; c2 <= nk + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n        for (c2 = nk; c2 <= ((nl + -1 < nm + -1?nl + -1 : nm + -1)); c2++) {\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n        for (c2 = (nk > nl?nk : nl); c2 <= nm + -1; c2++) {\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n        for (c2 = nm; c2 <= nl + -1; c2++) {\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n      }\n    }\n    if (nk >= 1 && nl <= 0) {\n#pragma omp parallel for private(c2)\n      for (c1 = nk; c1 <= ((((ni + -1 < nj + -1?ni + -1 : nj + -1)) < nm + -1?((ni + -1 < nj + -1?ni + -1 : nj + -1)) : nm + -1)); c1++) {\n        for (c2 = 0; c2 <= nk + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n        for (c2 = nk; c2 <= nm + -1; c2++) {\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n      }\n    }\n    if (nk >= 1 && nm >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = (nk > nm?nk : nm); c1 <= ((ni + -1 < nj + -1?ni + -1 : nj + -1)); c1++) {\n        for (c2 = 0; c2 <= ((nk + -1 < nm + -1?nk + -1 : nm + -1)); c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n        for (c2 = nm; c2 <= nk + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n        }\n        for (c2 = nk; c2 <= nm + -1; c2++) {\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n      }\n    }\n    if (nk >= 1 && nm <= 0) {\n#pragma omp parallel for private(c2)\n      for (c1 = nk; c1 <= ((ni + -1 < nj + -1?ni + -1 : nj + -1)); c1++) {\n        for (c2 = 0; c2 <= nk + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n        }\n      }\n    }\n    if (nk >= 1 && nl >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = (nj > nk?nj : nk); c1 <= ((ni + -1 < nm + -1?ni + -1 : nm + -1)); c1++) {\n        for (c2 = 0; c2 <= ((nk + -1 < nl + -1?nk + -1 : nl + -1)); c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n        for (c2 = nl; c2 <= nk + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n        }\n        for (c2 = nk; c2 <= nl + -1; c2++) {\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n      }\n    }\n    if (nk >= 1 && nl <= 0) {\n#pragma omp parallel for private(c2)\n      for (c1 = (nj > nk?nj : nk); c1 <= ((ni + -1 < nm + -1?ni + -1 : nm + -1)); c1++) {\n        for (c2 = 0; c2 <= nk + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n        }\n      }\n    }\n    if (nk >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = (((nj > nk?nj : nk)) > nm?((nj > nk?nj : nk)) : nm); c1 <= ni + -1; c1++) {\n        for (c2 = 0; c2 <= nk + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n        }\n      }\n    }\n    if (nl >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = (0 > ni?0 : ni); c1 <= ((((nj + -1 < nk + -1?nj + -1 : nk + -1)) < nm + -1?((nj + -1 < nk + -1?nj + -1 : nk + -1)) : nm + -1)); c1++) {\n        for (c2 = 0; c2 <= ((((nj + -1 < nl + -1?nj + -1 : nl + -1)) < nm + -1?((nj + -1 < nl + -1?nj + -1 : nl + -1)) : nm + -1)); c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n        for (c2 = nl; c2 <= ((nj + -1 < nm + -1?nj + -1 : nm + -1)); c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n        for (c2 = nm; c2 <= ((nj + -1 < nl + -1?nj + -1 : nl + -1)); c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n        for (c2 = (nl > nm?nl : nm); c2 <= nj + -1; c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n        }\n        for (c2 = nj; c2 <= ((nl + -1 < nm + -1?nl + -1 : nm + -1)); c2++) {\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n        for (c2 = (nj > nl?nj : nl); c2 <= nm + -1; c2++) {\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n        for (c2 = (nj > nm?nj : nm); c2 <= nl + -1; c2++) {\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n      }\n    }\n    if (nl <= 0) {\n#pragma omp parallel for private(c2)\n      for (c1 = (0 > ni?0 : ni); c1 <= ((((nj + -1 < nk + -1?nj + -1 : nk + -1)) < nm + -1?((nj + -1 < nk + -1?nj + -1 : nk + -1)) : nm + -1)); c1++) {\n        for (c2 = 0; c2 <= ((nj + -1 < nm + -1?nj + -1 : nm + -1)); c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n        for (c2 = nm; c2 <= nj + -1; c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n        }\n        for (c2 = nj; c2 <= nm + -1; c2++) {\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n      }\n    }\n    if (nm >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = (ni > nm?ni : nm); c1 <= ((nj + -1 < nk + -1?nj + -1 : nk + -1)); c1++) {\n        for (c2 = 0; c2 <= nm + -1; c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n        for (c2 = nm; c2 <= nj + -1; c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n        }\n      }\n    }\n    if (nm <= 0) {\n#pragma omp parallel for private(c2)\n      for (c1 = (0 > ni?0 : ni); c1 <= ((nj + -1 < nk + -1?nj + -1 : nk + -1)); c1++) {\n        for (c2 = 0; c2 <= nj + -1; c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n        }\n      }\n    }\n    if (nj >= 1 && nl >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = (ni > nj?ni : nj); c1 <= ((nk + -1 < nm + -1?nk + -1 : nm + -1)); c1++) {\n        for (c2 = 0; c2 <= ((nj + -1 < nl + -1?nj + -1 : nl + -1)); c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n        for (c2 = nl; c2 <= nj + -1; c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n        }\n        for (c2 = nj; c2 <= nl + -1; c2++) {\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n      }\n    }\n    if (nj >= 1 && nl <= 0) {\n#pragma omp parallel for private(c2)\n      for (c1 = (ni > nj?ni : nj); c1 <= ((nk + -1 < nm + -1?nk + -1 : nm + -1)); c1++) {\n        for (c2 = 0; c2 <= nj + -1; c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n        }\n      }\n    }\n    if (nj >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = (((ni > nj?ni : nj)) > nm?((ni > nj?ni : nj)) : nm); c1 <= nk + -1; c1++) {\n        for (c2 = 0; c2 <= nj + -1; c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n        }\n      }\n    }\n    if (nk >= 1 && nl >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = (ni > nk?ni : nk); c1 <= ((nj + -1 < nm + -1?nj + -1 : nm + -1)); c1++) {\n        for (c2 = 0; c2 <= ((nl + -1 < nm + -1?nl + -1 : nm + -1)); c2++) {\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n        for (c2 = nl; c2 <= nm + -1; c2++) {\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n        for (c2 = nm; c2 <= nl + -1; c2++) {\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n      }\n    }\n    if (nk >= 1 && nl <= 0) {\n#pragma omp parallel for private(c2)\n      for (c1 = (ni > nk?ni : nk); c1 <= ((nj + -1 < nm + -1?nj + -1 : nm + -1)); c1++) {\n        for (c2 = 0; c2 <= nm + -1; c2++) {\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n      }\n    }\n    if (nk >= 1 && nm >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = (((ni > nk?ni : nk)) > nm?((ni > nk?ni : nk)) : nm); c1 <= nj + -1; c1++) {\n        for (c2 = 0; c2 <= nm + -1; c2++) {\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n      }\n    }\n    if (nk <= 0 && nl >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = 0; c1 <= ((nj + -1 < nm + -1?nj + -1 : nm + -1)); c1++) {\n        for (c2 = 0; c2 <= ((nl + -1 < nm + -1?nl + -1 : nm + -1)); c2++) {\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n        for (c2 = nl; c2 <= nm + -1; c2++) {\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n        for (c2 = nm; c2 <= nl + -1; c2++) {\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n      }\n    }\n    if (nk <= 0 && nl <= 0) {\n#pragma omp parallel for private(c2)\n      for (c1 = 0; c1 <= ((nj + -1 < nm + -1?nj + -1 : nm + -1)); c1++) {\n        for (c2 = 0; c2 <= nm + -1; c2++) {\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n      }\n    }\n    if (nk <= 0 && nm >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = nm; c1 <= nj + -1; c1++) {\n        for (c2 = 0; c2 <= nm + -1; c2++) {\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n      }\n    }\n    if (nj <= 0 && nl >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = (0 > ni?0 : ni); c1 <= ((nk + -1 < nm + -1?nk + -1 : nm + -1)); c1++) {\n        for (c2 = 0; c2 <= nl + -1; c2++) {\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n      }\n    }\n    if (nk >= 1 && nl >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = (((ni > nj?ni : nj)) > nk?((ni > nj?ni : nj)) : nk); c1 <= nm + -1; c1++) {\n        for (c2 = 0; c2 <= nl + -1; c2++) {\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n      }\n    }\n    if (nk <= 0 && nl >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = (0 > nj?0 : nj); c1 <= nm + -1; c1++) {\n        for (c2 = 0; c2 <= nl + -1; c2++) {\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n      }\n    }\n  }\n}\n/* DCE code. Must scan the entire live-out data.\n   Can be used also to check the correctness of the output. */\n\nstatic void print_array(int ni,int nl,double G[128 + 0][128 + 0])\n{\n  int i;\n  int j;\n  for (i = 0; i < ni; i++) \n    for (j = 0; j < nl; j++) {\n      fprintf(stderr,\"%0.2lf \",G[i][j]);\n      if ((i * ni + j) % 20 == 0) \n        fprintf(stderr,\"\\n\");\n    }\n  fprintf(stderr,\"\\n\");\n}\n/* Main computational kernel. The whole function will be timed,\n   including the call and return. */\n\nstatic void kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[128 + 0][128 + 0],double A[128 + 0][128 + 0],double B[128 + 0][128 + 0],double F[128 + 0][128 + 0],double C[128 + 0][128 + 0],double D[128 + 0][128 + 0],double G[128 + 0][128 + 0])\n{\n  //int i;\n  //int j;\n  //int k;\n  \n  //#pragma scop\n{\n    int c1;\n    int c2;\n    int c5;\n#pragma omp parallel for private(c2)\n    for (c1 = 0; c1 <= 127; c1++) {\n      for (c2 = 0; c2 <= 127; c2++) {\n        G[c1][c2] = 0;\n        F[c1][c2] = 0;\n      }\n    }\n#pragma omp parallel for private(c5, c2)\n    for (c1 = 0; c1 <= 127; c1++) {\n      for (c2 = 0; c2 <= 127; c2++) {\n        for (c5 = 0; c5 <= 127; c5++) {\n          F[c1][c2] += C[c1][c5] * D[c5][c2];\n        }\n      }\n    }\n#pragma omp parallel for private(c2)\n    for (c1 = 0; c1 <= 127; c1++) {\n      for (c2 = 0; c2 <= 127; c2++) {\n        E[c1][c2] = 0;\n      }\n    }\n#pragma omp parallel for private(c5, c2)\n    for (c1 = 0; c1 <= 127; c1++) {\n      for (c2 = 0; c2 <= 127; c2++) {\n        for (c5 = 0; c5 <= 127; c5++) {\n          E[c1][c2] += A[c1][c5] * B[c5][c2];\n        }\n        for (c5 = 0; c5 <= 127; c5++) {\n          G[c1][c5] += E[c1][c2] * F[c2][c5];\n        }\n      }\n    }\n  }\n  \n//#pragma endscop\n}\n\nint main(int argc,char **argv)\n{\n/* Retrieve problem size. */\n  int ni = 128;\n  int nj = 128;\n  int nk = 128;\n  int nl = 128;\n  int nm = 128;\n/* Variable declaration/allocation. */\n  double (*E)[128 + 0][128 + 0];\n  E = ((double (*)[128 + 0][128 + 0])(polybench_alloc_data(((128 + 0) * (128 + 0)),(sizeof(double )))));\n  ;\n  double (*A)[128 + 0][128 + 0];\n  A = ((double (*)[128 + 0][128 + 0])(polybench_alloc_data(((128 + 0) * (128 + 0)),(sizeof(double )))));\n  ;\n  double (*B)[128 + 0][128 + 0];\n  B = ((double (*)[128 + 0][128 + 0])(polybench_alloc_data(((128 + 0) * (128 + 0)),(sizeof(double )))));\n  ;\n  double (*F)[128 + 0][128 + 0];\n  F = ((double (*)[128 + 0][128 + 0])(polybench_alloc_data(((128 + 0) * (128 + 0)),(sizeof(double )))));\n  ;\n  double (*C)[128 + 0][128 + 0];\n  C = ((double (*)[128 + 0][128 + 0])(polybench_alloc_data(((128 + 0) * (128 + 0)),(sizeof(double )))));\n  ;\n  double (*D)[128 + 0][128 + 0];\n  D = ((double (*)[128 + 0][128 + 0])(polybench_alloc_data(((128 + 0) * (128 + 0)),(sizeof(double )))));\n  ;\n  double (*G)[128 + 0][128 + 0];\n  G = ((double (*)[128 + 0][128 + 0])(polybench_alloc_data(((128 + 0) * (128 + 0)),(sizeof(double )))));\n  ;\n/* Initialize array(s). */\n  init_array(ni,nj,nk,nl,nm, *A, *B, *C, *D);\n/* Start timer. */\n  polybench_timer_start();\n  ;\n/* Run kernel. */\n  kernel_3mm(ni,nj,nk,nl,nm, *E, *A, *B, *F, *C, *D, *G);\n/* Stop and print timer. */\n  polybench_timer_stop();\n  ;\n  polybench_timer_print();\n  ;\n/* Prevent dead-code elimination. All live-out data must be printed\n     by the function call in argument. */\n  if (argc > 42 && !strcmp(argv[0],\"\")) \n    print_array(ni,nl, *G);\n/* Be clean. */\n  free(((void *)E));\n  ;\n  free(((void *)A));\n  ;\n  free(((void *)B));\n  ;\n  free(((void *)F));\n  ;\n  free(((void *)C));\n  ;\n  free(((void *)D));\n  ;\n  free(((void *)G));\n  ;\n  return 0;\n}\n",
        "data_race": 0,
        "trimmed_code": "#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <math.h>\n\n#include \"polybench/polybench.h\"\n\n\n#include \"polybench/3mm.h\"\n\n\nstatic void init_array(int ni,int nj,int nk,int nl,int nm,double A[128 + 0][128 + 0],double B[128 + 0][128 + 0],double C[128 + 0][128 + 0],double D[128 + 0][128 + 0])\n{\n  \n  \n{\n    int c2;\n    int c1;\n    if (nl >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = 0; c1 <= ((((((ni + -1 < nj + -1?ni + -1 : nj + -1)) < nk + -1?((ni + -1 < nj + -1?ni + -1 : nj + -1)) : nk + -1)) < nm + -1?((((ni + -1 < nj + -1?ni + -1 : nj + -1)) < nk + -1?((ni + -1 < nj + -1?ni + -1 : nj + -1)) : nk + -1)) : nm + -1)); c1++) {\n        for (c2 = 0; c2 <= ((((((nj + -1 < nk + -1?nj + -1 : nk + -1)) < nl + -1?((nj + -1 < nk + -1?nj + -1 : nk + -1)) : nl + -1)) < nm + -1?((((nj + -1 < nk + -1?nj + -1 : nk + -1)) < nl + -1?((nj + -1 < nk + -1?nj + -1 : nk + -1)) : nl + -1)) : nm + -1)); c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n        for (c2 = nl; c2 <= ((((nj + -1 < nk + -1?nj + -1 : nk + -1)) < nm + -1?((nj + -1 < nk + -1?nj + -1 : nk + -1)) : nm + -1)); c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n        for (c2 = nm; c2 <= ((((nj + -1 < nk + -1?nj + -1 : nk + -1)) < nl + -1?((nj + -1 < nk + -1?nj + -1 : nk + -1)) : nl + -1)); c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n        for (c2 = (nl > nm?nl : nm); c2 <= ((nj + -1 < nk + -1?nj + -1 : nk + -1)); c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n        }\n        for (c2 = nj; c2 <= ((((nk + -1 < nl + -1?nk + -1 : nl + -1)) < nm + -1?((nk + -1 < nl + -1?nk + -1 : nl + -1)) : nm + -1)); c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n        for (c2 = (nj > nl?nj : nl); c2 <= ((nk + -1 < nm + -1?nk + -1 : nm + -1)); c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n        for (c2 = (nj > nm?nj : nm); c2 <= ((nk + -1 < nl + -1?nk + -1 : nl + -1)); c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n        for (c2 = (((nj > nl?nj : nl)) > nm?((nj > nl?nj : nl)) : nm); c2 <= nk + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n        }\n        for (c2 = nk; c2 <= ((((nj + -1 < nl + -1?nj + -1 : nl + -1)) < nm + -1?((nj + -1 < nl + -1?nj + -1 : nl + -1)) : nm + -1)); c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n        for (c2 = (nk > nl?nk : nl); c2 <= ((nj + -1 < nm + -1?nj + -1 : nm + -1)); c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n        for (c2 = (nk > nm?nk : nm); c2 <= ((nj + -1 < nl + -1?nj + -1 : nl + -1)); c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n        for (c2 = (((nk > nl?nk : nl)) > nm?((nk > nl?nk : nl)) : nm); c2 <= nj + -1; c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n        }\n        for (c2 = (nj > nk?nj : nk); c2 <= ((nl + -1 < nm + -1?nl + -1 : nm + -1)); c2++) {\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n        for (c2 = (((nj > nk?nj : nk)) > nl?((nj > nk?nj : nk)) : nl); c2 <= nm + -1; c2++) {\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n        for (c2 = (((nj > nk?nj : nk)) > nm?((nj > nk?nj : nk)) : nm); c2 <= nl + -1; c2++) {\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n      }\n    }\n    if (nl <= 0) {\n#pragma omp parallel for private(c2)\n      for (c1 = 0; c1 <= ((((((ni + -1 < nj + -1?ni + -1 : nj + -1)) < nk + -1?((ni + -1 < nj + -1?ni + -1 : nj + -1)) : nk + -1)) < nm + -1?((((ni + -1 < nj + -1?ni + -1 : nj + -1)) < nk + -1?((ni + -1 < nj + -1?ni + -1 : nj + -1)) : nk + -1)) : nm + -1)); c1++) {\n        for (c2 = 0; c2 <= ((((nj + -1 < nk + -1?nj + -1 : nk + -1)) < nm + -1?((nj + -1 < nk + -1?nj + -1 : nk + -1)) : nm + -1)); c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n        for (c2 = nm; c2 <= ((nj + -1 < nk + -1?nj + -1 : nk + -1)); c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n        }\n        for (c2 = nj; c2 <= ((nk + -1 < nm + -1?nk + -1 : nm + -1)); c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n        for (c2 = (nj > nm?nj : nm); c2 <= nk + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n        }\n        for (c2 = nk; c2 <= ((nj + -1 < nm + -1?nj + -1 : nm + -1)); c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n        for (c2 = (nk > nm?nk : nm); c2 <= nj + -1; c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n        }\n        for (c2 = (nj > nk?nj : nk); c2 <= nm + -1; c2++) {\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n      }\n    }\n    if (nm >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = nm; c1 <= ((((ni + -1 < nj + -1?ni + -1 : nj + -1)) < nk + -1?((ni + -1 < nj + -1?ni + -1 : nj + -1)) : nk + -1)); c1++) {\n        for (c2 = 0; c2 <= nm + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n        for (c2 = nm; c2 <= ((nj + -1 < nk + -1?nj + -1 : nk + -1)); c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n        }\n        for (c2 = nj; c2 <= nk + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n        }\n        for (c2 = nk; c2 <= nj + -1; c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n        }\n      }\n    }\n    if (nm <= 0) {\n#pragma omp parallel for private(c2)\n      for (c1 = 0; c1 <= ((((ni + -1 < nj + -1?ni + -1 : nj + -1)) < nk + -1?((ni + -1 < nj + -1?ni + -1 : nj + -1)) : nk + -1)); c1++) {\n        for (c2 = 0; c2 <= ((nj + -1 < nk + -1?nj + -1 : nk + -1)); c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n        }\n        for (c2 = nj; c2 <= nk + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n        }\n        for (c2 = nk; c2 <= nj + -1; c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n        }\n      }\n    }\n    if (nj >= 1 && nl >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = nj; c1 <= ((((ni + -1 < nk + -1?ni + -1 : nk + -1)) < nm + -1?((ni + -1 < nk + -1?ni + -1 : nk + -1)) : nm + -1)); c1++) {\n        for (c2 = 0; c2 <= ((nj + -1 < nl + -1?nj + -1 : nl + -1)); c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n        for (c2 = nl; c2 <= nj + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n        }\n        for (c2 = nj; c2 <= ((nk + -1 < nl + -1?nk + -1 : nl + -1)); c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n        for (c2 = (nj > nl?nj : nl); c2 <= nk + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n        }\n        for (c2 = nk; c2 <= nl + -1; c2++) {\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n      }\n    }\n    if (nj >= 1 && nl <= 0) {\n#pragma omp parallel for private(c2)\n      for (c1 = nj; c1 <= ((((ni + -1 < nk + -1?ni + -1 : nk + -1)) < nm + -1?((ni + -1 < nk + -1?ni + -1 : nk + -1)) : nm + -1)); c1++) {\n        for (c2 = 0; c2 <= nj + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n        }\n        for (c2 = nj; c2 <= nk + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n        }\n      }\n    }\n    if (nj >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = (nj > nm?nj : nm); c1 <= ((ni + -1 < nk + -1?ni + -1 : nk + -1)); c1++) {\n        for (c2 = 0; c2 <= nj + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n        }\n        for (c2 = nj; c2 <= nk + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n        }\n      }\n    }\n    if (nj <= 0 && nl >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = 0; c1 <= ((((ni + -1 < nk + -1?ni + -1 : nk + -1)) < nm + -1?((ni + -1 < nk + -1?ni + -1 : nk + -1)) : nm + -1)); c1++) {\n        for (c2 = 0; c2 <= ((nk + -1 < nl + -1?nk + -1 : nl + -1)); c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n        for (c2 = nl; c2 <= nk + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n        }\n        for (c2 = nk; c2 <= nl + -1; c2++) {\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n      }\n    }\n    if (nj <= 0 && nl <= 0) {\n#pragma omp parallel for private(c2)\n      for (c1 = 0; c1 <= ((((ni + -1 < nk + -1?ni + -1 : nk + -1)) < nm + -1?((ni + -1 < nk + -1?ni + -1 : nk + -1)) : nm + -1)); c1++) {\n        for (c2 = 0; c2 <= nk + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n        }\n      }\n    }\n    if (nj <= 0) {\n#pragma omp parallel for private(c2)\n      for (c1 = (0 > nm?0 : nm); c1 <= ((ni + -1 < nk + -1?ni + -1 : nk + -1)); c1++) {\n        for (c2 = 0; c2 <= nk + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n        }\n      }\n    }\n    if (nk >= 1 && nl >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = nk; c1 <= ((((ni + -1 < nj + -1?ni + -1 : nj + -1)) < nm + -1?((ni + -1 < nj + -1?ni + -1 : nj + -1)) : nm + -1)); c1++) {\n        for (c2 = 0; c2 <= ((nk + -1 < nl + -1?nk + -1 : nl + -1)); c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n        for (c2 = nl; c2 <= nk + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n        for (c2 = nk; c2 <= ((nl + -1 < nm + -1?nl + -1 : nm + -1)); c2++) {\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n        for (c2 = (nk > nl?nk : nl); c2 <= nm + -1; c2++) {\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n        for (c2 = nm; c2 <= nl + -1; c2++) {\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n      }\n    }\n    if (nk >= 1 && nl <= 0) {\n#pragma omp parallel for private(c2)\n      for (c1 = nk; c1 <= ((((ni + -1 < nj + -1?ni + -1 : nj + -1)) < nm + -1?((ni + -1 < nj + -1?ni + -1 : nj + -1)) : nm + -1)); c1++) {\n        for (c2 = 0; c2 <= nk + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n        for (c2 = nk; c2 <= nm + -1; c2++) {\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n      }\n    }\n    if (nk >= 1 && nm >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = (nk > nm?nk : nm); c1 <= ((ni + -1 < nj + -1?ni + -1 : nj + -1)); c1++) {\n        for (c2 = 0; c2 <= ((nk + -1 < nm + -1?nk + -1 : nm + -1)); c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n        for (c2 = nm; c2 <= nk + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n        }\n        for (c2 = nk; c2 <= nm + -1; c2++) {\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n      }\n    }\n    if (nk >= 1 && nm <= 0) {\n#pragma omp parallel for private(c2)\n      for (c1 = nk; c1 <= ((ni + -1 < nj + -1?ni + -1 : nj + -1)); c1++) {\n        for (c2 = 0; c2 <= nk + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n        }\n      }\n    }\n    if (nk >= 1 && nl >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = (nj > nk?nj : nk); c1 <= ((ni + -1 < nm + -1?ni + -1 : nm + -1)); c1++) {\n        for (c2 = 0; c2 <= ((nk + -1 < nl + -1?nk + -1 : nl + -1)); c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n        for (c2 = nl; c2 <= nk + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n        }\n        for (c2 = nk; c2 <= nl + -1; c2++) {\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n      }\n    }\n    if (nk >= 1 && nl <= 0) {\n#pragma omp parallel for private(c2)\n      for (c1 = (nj > nk?nj : nk); c1 <= ((ni + -1 < nm + -1?ni + -1 : nm + -1)); c1++) {\n        for (c2 = 0; c2 <= nk + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n        }\n      }\n    }\n    if (nk >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = (((nj > nk?nj : nk)) > nm?((nj > nk?nj : nk)) : nm); c1 <= ni + -1; c1++) {\n        for (c2 = 0; c2 <= nk + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n        }\n      }\n    }\n    if (nl >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = (0 > ni?0 : ni); c1 <= ((((nj + -1 < nk + -1?nj + -1 : nk + -1)) < nm + -1?((nj + -1 < nk + -1?nj + -1 : nk + -1)) : nm + -1)); c1++) {\n        for (c2 = 0; c2 <= ((((nj + -1 < nl + -1?nj + -1 : nl + -1)) < nm + -1?((nj + -1 < nl + -1?nj + -1 : nl + -1)) : nm + -1)); c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n        for (c2 = nl; c2 <= ((nj + -1 < nm + -1?nj + -1 : nm + -1)); c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n        for (c2 = nm; c2 <= ((nj + -1 < nl + -1?nj + -1 : nl + -1)); c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n        for (c2 = (nl > nm?nl : nm); c2 <= nj + -1; c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n        }\n        for (c2 = nj; c2 <= ((nl + -1 < nm + -1?nl + -1 : nm + -1)); c2++) {\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n        for (c2 = (nj > nl?nj : nl); c2 <= nm + -1; c2++) {\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n        for (c2 = (nj > nm?nj : nm); c2 <= nl + -1; c2++) {\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n      }\n    }\n    if (nl <= 0) {\n#pragma omp parallel for private(c2)\n      for (c1 = (0 > ni?0 : ni); c1 <= ((((nj + -1 < nk + -1?nj + -1 : nk + -1)) < nm + -1?((nj + -1 < nk + -1?nj + -1 : nk + -1)) : nm + -1)); c1++) {\n        for (c2 = 0; c2 <= ((nj + -1 < nm + -1?nj + -1 : nm + -1)); c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n        for (c2 = nm; c2 <= nj + -1; c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n        }\n        for (c2 = nj; c2 <= nm + -1; c2++) {\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n      }\n    }\n    if (nm >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = (ni > nm?ni : nm); c1 <= ((nj + -1 < nk + -1?nj + -1 : nk + -1)); c1++) {\n        for (c2 = 0; c2 <= nm + -1; c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n        for (c2 = nm; c2 <= nj + -1; c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n        }\n      }\n    }\n    if (nm <= 0) {\n#pragma omp parallel for private(c2)\n      for (c1 = (0 > ni?0 : ni); c1 <= ((nj + -1 < nk + -1?nj + -1 : nk + -1)); c1++) {\n        for (c2 = 0; c2 <= nj + -1; c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n        }\n      }\n    }\n    if (nj >= 1 && nl >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = (ni > nj?ni : nj); c1 <= ((nk + -1 < nm + -1?nk + -1 : nm + -1)); c1++) {\n        for (c2 = 0; c2 <= ((nj + -1 < nl + -1?nj + -1 : nl + -1)); c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n        for (c2 = nl; c2 <= nj + -1; c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n        }\n        for (c2 = nj; c2 <= nl + -1; c2++) {\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n      }\n    }\n    if (nj >= 1 && nl <= 0) {\n#pragma omp parallel for private(c2)\n      for (c1 = (ni > nj?ni : nj); c1 <= ((nk + -1 < nm + -1?nk + -1 : nm + -1)); c1++) {\n        for (c2 = 0; c2 <= nj + -1; c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n        }\n      }\n    }\n    if (nj >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = (((ni > nj?ni : nj)) > nm?((ni > nj?ni : nj)) : nm); c1 <= nk + -1; c1++) {\n        for (c2 = 0; c2 <= nj + -1; c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n        }\n      }\n    }\n    if (nk >= 1 && nl >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = (ni > nk?ni : nk); c1 <= ((nj + -1 < nm + -1?nj + -1 : nm + -1)); c1++) {\n        for (c2 = 0; c2 <= ((nl + -1 < nm + -1?nl + -1 : nm + -1)); c2++) {\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n        for (c2 = nl; c2 <= nm + -1; c2++) {\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n        for (c2 = nm; c2 <= nl + -1; c2++) {\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n      }\n    }\n    if (nk >= 1 && nl <= 0) {\n#pragma omp parallel for private(c2)\n      for (c1 = (ni > nk?ni : nk); c1 <= ((nj + -1 < nm + -1?nj + -1 : nm + -1)); c1++) {\n        for (c2 = 0; c2 <= nm + -1; c2++) {\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n      }\n    }\n    if (nk >= 1 && nm >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = (((ni > nk?ni : nk)) > nm?((ni > nk?ni : nk)) : nm); c1 <= nj + -1; c1++) {\n        for (c2 = 0; c2 <= nm + -1; c2++) {\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n      }\n    }\n    if (nk <= 0 && nl >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = 0; c1 <= ((nj + -1 < nm + -1?nj + -1 : nm + -1)); c1++) {\n        for (c2 = 0; c2 <= ((nl + -1 < nm + -1?nl + -1 : nm + -1)); c2++) {\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n        for (c2 = nl; c2 <= nm + -1; c2++) {\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n        for (c2 = nm; c2 <= nl + -1; c2++) {\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n      }\n    }\n    if (nk <= 0 && nl <= 0) {\n#pragma omp parallel for private(c2)\n      for (c1 = 0; c1 <= ((nj + -1 < nm + -1?nj + -1 : nm + -1)); c1++) {\n        for (c2 = 0; c2 <= nm + -1; c2++) {\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n      }\n    }\n    if (nk <= 0 && nm >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = nm; c1 <= nj + -1; c1++) {\n        for (c2 = 0; c2 <= nm + -1; c2++) {\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n      }\n    }\n    if (nj <= 0 && nl >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = (0 > ni?0 : ni); c1 <= ((nk + -1 < nm + -1?nk + -1 : nm + -1)); c1++) {\n        for (c2 = 0; c2 <= nl + -1; c2++) {\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n      }\n    }\n    if (nk >= 1 && nl >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = (((ni > nj?ni : nj)) > nk?((ni > nj?ni : nj)) : nk); c1 <= nm + -1; c1++) {\n        for (c2 = 0; c2 <= nl + -1; c2++) {\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n      }\n    }\n    if (nk <= 0 && nl >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = (0 > nj?0 : nj); c1 <= nm + -1; c1++) {\n        for (c2 = 0; c2 <= nl + -1; c2++) {\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n      }\n    }\n  }\n}\n\n\nstatic void print_array(int ni,int nl,double G[128 + 0][128 + 0])\n{\n  int i;\n  int j;\n  for (i = 0; i < ni; i++) \n    for (j = 0; j < nl; j++) {\n      fprintf(stderr,\"%0.2lf \",G[i][j]);\n      if ((i * ni + j) % 20 == 0) \n        fprintf(stderr,\"\\n\");\n    }\n  fprintf(stderr,\"\\n\");\n}\n\n\nstatic void kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[128 + 0][128 + 0],double A[128 + 0][128 + 0],double B[128 + 0][128 + 0],double F[128 + 0][128 + 0],double C[128 + 0][128 + 0],double D[128 + 0][128 + 0],double G[128 + 0][128 + 0])\n{\n  \n  \n  \n  \n  \n{\n    int c1;\n    int c2;\n    int c5;\n#pragma omp parallel for private(c2)\n    for (c1 = 0; c1 <= 127; c1++) {\n      for (c2 = 0; c2 <= 127; c2++) {\n        G[c1][c2] = 0;\n        F[c1][c2] = 0;\n      }\n    }\n#pragma omp parallel for private(c5, c2)\n    for (c1 = 0; c1 <= 127; c1++) {\n      for (c2 = 0; c2 <= 127; c2++) {\n        for (c5 = 0; c5 <= 127; c5++) {\n          F[c1][c2] += C[c1][c5] * D[c5][c2];\n        }\n      }\n    }\n#pragma omp parallel for private(c2)\n    for (c1 = 0; c1 <= 127; c1++) {\n      for (c2 = 0; c2 <= 127; c2++) {\n        E[c1][c2] = 0;\n      }\n    }\n#pragma omp parallel for private(c5, c2)\n    for (c1 = 0; c1 <= 127; c1++) {\n      for (c2 = 0; c2 <= 127; c2++) {\n        for (c5 = 0; c5 <= 127; c5++) {\n          E[c1][c2] += A[c1][c5] * B[c5][c2];\n        }\n        for (c5 = 0; c5 <= 127; c5++) {\n          G[c1][c5] += E[c1][c2] * F[c2][c5];\n        }\n      }\n    }\n  }\n  \n\n}\n\nint main(int argc,char **argv)\n{\n\n  int ni = 128;\n  int nj = 128;\n  int nk = 128;\n  int nl = 128;\n  int nm = 128;\n\n  double (*E)[128 + 0][128 + 0];\n  E = ((double (*)[128 + 0][128 + 0])(polybench_alloc_data(((128 + 0) * (128 + 0)),(sizeof(double )))));\n  ;\n  double (*A)[128 + 0][128 + 0];\n  A = ((double (*)[128 + 0][128 + 0])(polybench_alloc_data(((128 + 0) * (128 + 0)),(sizeof(double )))));\n  ;\n  double (*B)[128 + 0][128 + 0];\n  B = ((double (*)[128 + 0][128 + 0])(polybench_alloc_data(((128 + 0) * (128 + 0)),(sizeof(double )))));\n  ;\n  double (*F)[128 + 0][128 + 0];\n  F = ((double (*)[128 + 0][128 + 0])(polybench_alloc_data(((128 + 0) * (128 + 0)),(sizeof(double )))));\n  ;\n  double (*C)[128 + 0][128 + 0];\n  C = ((double (*)[128 + 0][128 + 0])(polybench_alloc_data(((128 + 0) * (128 + 0)),(sizeof(double )))));\n  ;\n  double (*D)[128 + 0][128 + 0];\n  D = ((double (*)[128 + 0][128 + 0])(polybench_alloc_data(((128 + 0) * (128 + 0)),(sizeof(double )))));\n  ;\n  double (*G)[128 + 0][128 + 0];\n  G = ((double (*)[128 + 0][128 + 0])(polybench_alloc_data(((128 + 0) * (128 + 0)),(sizeof(double )))));\n  ;\n\n  init_array(ni,nj,nk,nl,nm, *A, *B, *C, *D);\n\n  polybench_timer_start();\n  ;\n\n  kernel_3mm(ni,nj,nk,nl,nm, *E, *A, *B, *F, *C, *D, *G);\n\n  polybench_timer_stop();\n  ;\n  polybench_timer_print();\n  ;\n\n  if (argc > 42 && !strcmp(argv[0],\"\")) \n    print_array(ni,nl, *G);\n\n  free(((void *)E));\n  ;\n  free(((void *)A));\n  ;\n  free(((void *)B));\n  ;\n  free(((void *)F));\n  ;\n  free(((void *)C));\n  ;\n  free(((void *)D));\n  ;\n  free(((void *)G));\n  ;\n  return 0;\n}\n",
        "code_len": 23743,
        "data_race_label": "N2",
        "var_pairs": []
    },
    {
        "ID": "042",
        "name": "DRB042-3mm-tile-no.c",
        "DRB_code": "/**\n * 3mm.c: This file is part of the PolyBench/C 3.2 test suite.\n * with tiling 16x16 and nested SIMD \n *\n * Contact: Louis-Noel Pouchet <pouchet@cse.ohio-state.edu>\n * Web address: http://polybench.sourceforge.net\n * License: /LICENSE.OSU.txt\n */\n#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <math.h>\n/* Include polybench common header. */\n#include \"polybench/polybench.h\"\n/* Include benchmark-specific header. */\n/* Default data type is double, default size is 4000. */\n#include \"polybench/3mm.h\"\n/* Array initialization. */\n\nstatic void init_array(int ni,int nj,int nk,int nl,int nm,double A[128 + 0][128 + 0],double B[128 + 0][128 + 0],double C[128 + 0][128 + 0],double D[128 + 0][128 + 0])\n{\n  //int i;\n  //int j;\n{\n    int c3;\n    int c4;\n    int c1;\n    int c2;\n    if (ni >= ((0 > -1 * nj + -1 * nm + 1?0 : -1 * nj + -1 * nm + 1)) && nj >= 0 && nk >= ((0 > -1 * nm + 1?0 : -1 * nm + 1)) && nm >= 0) {\n#pragma omp parallel for private(c2, c4, c3)\n      for (c1 = 0; c1 <= (((((nk + ni + nj + nm + -1) * 16 < 0?((16 < 0?-((-(nk + ni + nj + nm + -1) + 16 + 1) / 16) : -((-(nk + ni + nj + nm + -1) + 16 - 1) / 16))) : (nk + ni + nj + nm + -1) / 16)) < (((nk + ni + nj + 2 * nm + -2) * 16 < 0?((16 < 0?-((-(nk + ni + nj + 2 * nm + -2) + 16 + 1) / 16) : -((-(nk + ni + nj + 2 * nm + -2) + 16 - 1) / 16))) : (nk + ni + nj + 2 * nm + -2) / 16))?(((nk + ni + nj + nm + -1) * 16 < 0?((16 < 0?-((-(nk + ni + nj + nm + -1) + 16 + 1) / 16) : -((-(nk + ni + nj + nm + -1) + 16 - 1) / 16))) : (nk + ni + nj + nm + -1) / 16)) : (((nk + ni + nj + 2 * nm + -2) * 16 < 0?((16 < 0?-((-(nk + ni + nj + 2 * nm + -2) + 16 + 1) / 16) : -((-(nk + ni + nj + 2 * nm + -2) + 16 - 1) / 16))) : (nk + ni + nj + 2 * nm + -2) / 16)))); c1++) {\n        if (c1 <= (((((((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)))) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)))) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)))) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)))) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))))) {\n          for (c2 = 0; c2 <= (((((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)) < nk + -1?((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)) : nk + -1)) < nm + -1?((((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)) < nk + -1?((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)) : nk + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)) < nl + -1?((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)) : nl + -1)) < nm + -1?((((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)) < nl + -1?((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)) : nl + -1)) : nm + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)) < nm + -1?((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)) : nm + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)) < nl + -1?((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)) : nl + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (nl > nm?nl : nm); c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)) < nm + -1?((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)) : nm + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (nj > nl?nj : nl); c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nm + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nm + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = (nj > nm?nj : nm); c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (((nj > nl?nj : nl)) > nm?((nj > nl?nj : nl)) : nm); c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n#pragma omp simd\n              for (c4 = nk; c4 <= ((((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)) < nm + -1?((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)) : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (nk > nl?nk : nl); c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nm + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = (nk > nm?nk : nm); c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (((nk > nl?nk : nl)) > nm?((nk > nl?nk : nl)) : nm); c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = (nj > nk?nj : nk); c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (((nj > nk?nj : nk)) > nl?((nj > nk?nj : nk)) : nl); c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = (((nj > nk?nj : nk)) > nm?((nj > nk?nj : nk)) : nm); c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nm; c3 <= ((((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)) < nk + -1?((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nm; c4 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)); c4++) {\n                  A[c3][c4] = ((double )c3) * c4 / ni;\n                  B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                }\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nj; c4 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c4++) {\n                  A[c3][c4] = ((double )c3) * c4 / ni;\n                }\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nk; c4 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c4++) {\n                  B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                }\n              }\n            }\n            for (c3 = nj; c3 <= ((((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nk + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nk + -1)) < nm + -1?((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nk + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nk + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nj; c4 <= ((((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) < nl + -1?((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) : nl + -1)); c4++) {\n                  A[c3][c4] = ((double )c3) * c4 / ni;\n                  D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n                }\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = (nj > nl?nj : nl); c4 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c4++) {\n                  A[c3][c4] = ((double )c3) * c4 / ni;\n                }\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nk; c4 <= ((16 * c1 + 15 < nl + -1?16 * c1 + 15 : nl + -1)); c4++) {\n                  D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n                }\n              }\n            }\n            for (c3 = (nj > nm?nj : nm); c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nk + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nj; c4 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c4++) {\n                  A[c3][c4] = ((double )c3) * c4 / ni;\n                }\n              }\n            }\n            for (c3 = nk; c3 <= ((((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)) < nm + -1?((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nk; c4 <= ((((16 * c1 + 15 < nl + -1?16 * c1 + 15 : nl + -1)) < nm + -1?((16 * c1 + 15 < nl + -1?16 * c1 + 15 : nl + -1)) : nm + -1)); c4++) {\n                  C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                  D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n                }\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = (nk > nl?nk : nl); c4 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c4++) {\n                  C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                }\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nm; c4 <= ((16 * c1 + 15 < nl + -1?16 * c1 + 15 : nl + -1)); c4++) {\n                  D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n                }\n              }\n            }\n            for (c3 = (nk > nm?nk : nm); c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nm + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nm + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nm; c4 <= nk + -1; c4++) {\n                  A[c3][c4] = ((double )c3) * c4 / ni;\n                }\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nk; c4 <= nm + -1; c4++) {\n                  C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                }\n              }\n            }\n            for (c3 = (nj > nk?nj : nk); c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nm + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nk; c4 <= ((16 * c1 + 15 < nl + -1?16 * c1 + 15 : nl + -1)); c4++) {\n                  D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n                }\n              }\n            }\n            for (c3 = (((nj > nk?nj : nk)) > nm?((nj > nk?nj : nk)) : nm); c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = ni; c3 <= ((((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)) < nm + -1?((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)) < nm + -1?((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)) : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nm + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (nl > nm?nl : nm); c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (nj > nl?nj : nl); c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = (nj > nm?nj : nm); c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = (ni > nm?ni : nm); c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nm; c4 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c4++) {\n                  B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                }\n              }\n            }\n            for (c3 = (ni > nj?ni : nj); c3 <= ((((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) < nm + -1?((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nj; c4 <= ((16 * c1 + 15 < nl + -1?16 * c1 + 15 : nl + -1)); c4++) {\n                  D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n                }\n              }\n            }\n            for (c3 = (((ni > nj?ni : nj)) > nm?((ni > nj?ni : nj)) : nm); c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = (ni > nk?ni : nk); c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nm + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nm; c4 <= ((16 * c1 + 15 < nl + -1?16 * c1 + 15 : nl + -1)); c4++) {\n                  D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n                }\n              }\n            }\n            for (c3 = (((ni > nk?ni : nk)) > nm?((ni > nk?ni : nk)) : nm); c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = (((ni > nj?ni : nj)) > nk?((ni > nj?ni : nj)) : nk); c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)))) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)))) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) && c1 >= ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))) {\n          for (c2 = 0; c2 <= (((((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)) < nk + -1?((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= 16 * c2 + 15; c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = nj; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nk + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= 16 * c2 + 15; c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = nk; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= 16 * c2 + 15; c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = (nj > nk?nj : nk); c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= 16 * c2 + 15; c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = ni; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= 16 * c2 + 15; c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = (ni > nj?ni : nj); c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= 16 * c2 + 15; c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = (ni > nk?ni : nk); c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)))) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)))) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))))) {\n          for (c2 = (0 > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?0 : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)) < nk + -1?((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)) < nm + -1?((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)) : nm + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nm + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nm + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = (nj > nm?nj : nm); c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n#pragma omp simd\n              for (c4 = nk; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nm + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = (nk > nm?nk : nm); c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = (nj > nk?nj : nk); c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = nj; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nk + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nj; c4 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c4++) {\n                  A[c3][c4] = ((double )c3) * c4 / ni;\n                }\n              }\n            }\n            for (c3 = nk; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nm + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nm + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nk; c4 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c4++) {\n                  C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                }\n              }\n            }\n            for (c3 = (nj > nk?nj : nk); c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = ni; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nm + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = (ni > nj?ni : nj); c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = (ni > nk?ni : nk); c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))) && c1 >= ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))) {\n          for (c2 = 0; c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nk + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nk + -1)) < nm + -1?((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nk + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nk + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (nj > nl?nj : nl); c4 <= 16 * c2 + 15; c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = nm; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nk + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= 16 * c2 + 15; c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = nk; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nm + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= 16 * c2 + 15; c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = (nk > nm?nk : nm); c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= 16 * c2 + 15; c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = ni; c3 <= ((((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) < nm + -1?((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = (ni > nm?ni : nm); c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = (ni > nk?ni : nk); c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) && c1 >= ((((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))))) {\n          for (c2 = 0; c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nk + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= 16 * c2 + 15; c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = nk; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= 16 * c2 + 15; c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = ni; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) && c1 >= ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))) {\n          for (c2 = (0 > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?0 : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nk + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= 16 * c2 + 15; c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = nk; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= 16 * c2 + 15; c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = ni; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))))) {\n          for (c2 = (nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))); c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nm + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)) < nl + -1?((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)) : nl + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (nj > nl?nj : nl); c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n#pragma omp simd\n              for (c4 = nk; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (nk > nl?nk : nl); c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = (nj > nk?nj : nk); c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nm; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n#pragma omp simd\n              for (c4 = nk; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = ni; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = (ni > nm?ni : nm); c3 <= 16 * c1 + 15; c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) && c1 >= ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))) {\n          for (c2 = (nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))); c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nk + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n#pragma omp simd\n              for (c4 = nk; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = nk; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = ni; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))))) {\n          for (c2 = (((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16)))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16)))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nk + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n#pragma omp simd\n              for (c4 = nk; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = nk; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = ni; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))) && c1 >= ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))) {\n          for (c2 = 0; c2 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)) < nm + -1?((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nk; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (nk > nl?nk : nl); c4 <= 16 * c2 + 15; c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = nm; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nk; c4 <= 16 * c2 + 15; c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = nj; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nm + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n#pragma omp simd\n              for (c4 = nk; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = (nj > nm?nj : nm); c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = ni; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nm + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= 16 * c2 + 15; c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = (ni > nm?ni : nm); c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= 16 * c2 + 15; c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = (ni > nj?ni : nj); c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)))) && c1 >= ((((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))))) {\n          for (c2 = 0; c2 <= (((((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nm + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nm + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n#pragma omp simd\n              for (c4 = nk; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = nj; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = ni; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)))) && c1 >= ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))) {\n          for (c2 = (0 > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?0 : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nm + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nm + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n#pragma omp simd\n              for (c4 = nk; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = nj; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = ni; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))) && c1 >= ((((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))))) {\n          for (c2 = 0; c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nm + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n#pragma omp simd\n              for (c4 = nk; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nm; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = ni; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) && c1 >= ((((((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))))) {\n          for (c2 = 0; c2 <= (((((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n          }\n        }\n        if (c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) && c1 >= ((((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))))) {\n          for (c2 = (0 > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?0 : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n          }\n        }\n        if (c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) && c1 >= ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))) {\n          for (c2 = (nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))))) {\n          for (c2 = (nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))); c2 <= (((((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)) < nm + -1?((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)) : nm + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nm + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nm + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (nl > nm?nl : nm); c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n#pragma omp simd\n              for (c4 = nk; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (nk > nl?nk : nl); c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = (nk > nm?nk : nm); c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nj; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n#pragma omp simd\n              for (c4 = nk; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = ni; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = (ni > nj?ni : nj); c3 <= 16 * c1 + 15; c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))))) {\n          for (c2 = (((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nm + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nm + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n#pragma omp simd\n              for (c4 = nk; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = nj; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = ni; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))) && c1 >= ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))) {\n          for (c2 = (nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))); c2 <= (((((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nm + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n#pragma omp simd\n              for (c4 = nk; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nm; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = ni; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) && c1 >= ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))) {\n          for (c2 = (nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))); c2 <= (((((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n          }\n        }\n        if (c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) && c1 >= ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))) {\n          for (c2 = (((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))))) {\n          for (c2 = (((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))); c2 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nm + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n#pragma omp simd\n              for (c4 = nk; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nm; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = ni; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) && c1 >= ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))) {\n          for (c2 = (((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))); c2 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n          }\n        }\n        if (c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16))) {\n          for (c2 = (((((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16)))))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16)))))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))); c2 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))) && c1 >= ((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16))))) {\n          for (c2 = 0; c2 <= (((((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)) < nm + -1?((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)) < nm + -1?((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)) : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nm + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (nl > nm?nl : nm); c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (nj > nl?nj : nl); c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = (nj > nm?nj : nm); c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nm; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nm; c4 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c4++) {\n                  B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                }\n              }\n            }\n            for (c3 = nj; c3 <= ((((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) < nm + -1?((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nj; c4 <= ((16 * c1 + 15 < nl + -1?16 * c1 + 15 : nl + -1)); c4++) {\n                  D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n                }\n              }\n            }\n            for (c3 = (nj > nm?nj : nm); c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = nk; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nm + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nm; c4 <= ((16 * c1 + 15 < nl + -1?16 * c1 + 15 : nl + -1)); c4++) {\n                  D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n                }\n              }\n            }\n            for (c3 = (nk > nm?nk : nm); c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = (nj > nk?nj : nk); c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) && c1 >= ((((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))))) {\n          for (c2 = 0; c2 <= (((((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= 16 * c2 + 15; c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = nj; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= 16 * c2 + 15; c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = nk; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) && c1 >= ((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16))))) {\n          for (c2 = (0 > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?0 : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nm + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = nj; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = nk; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))) && c1 >= ((((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) > ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))?((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) : ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))))) {\n          for (c2 = 0; c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) < nm + -1?((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nm; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = nk; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) && c1 >= ((((((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) > ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))?((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) : ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) > ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))?((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) : ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))))) {\n          for (c2 = 0; c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) && c1 >= ((((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) > ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))?((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) : ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))))) {\n          for (c2 = (0 > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?0 : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)) && c1 >= ((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16))))) {\n          for (c2 = (nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))); c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nm; c3 <= 16 * c1 + 15; c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) && c1 >= ((((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))))) {\n          for (c2 = (nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))); c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) && c1 >= ((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16))))) {\n          for (c2 = (((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16)))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16)))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))) {\n          for (c2 = (nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))); c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)) < nm + -1?((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)) : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nm + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (nl > nm?nl : nm); c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (nj > nl?nj : nl); c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = (nj > nm?nj : nm); c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nk; c3 <= 16 * c1 + 15; c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))) {\n          for (c2 = (((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))) > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))) : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nm + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = nk; c3 <= 16 * c1 + 15; c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))))) {\n          for (c2 = (((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) < nm + -1?((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nm; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = nk; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) && c1 >= ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))) {\n          for (c2 = (nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))) {\n          for (c2 = (((((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))) > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))) : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16)))))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))) > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))) : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16)))))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))); c2 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))) && c1 >= ((((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) > ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))?((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) : ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))))) {\n          for (c2 = 0; c2 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nm + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= 16 * c2 + 15; c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = nm; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= 16 * c2 + 15; c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = nj; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) && c1 >= ((((((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) > ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))?((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) : ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) > ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))?((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) : ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))))) {\n          for (c2 = 0; c2 <= (((((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) && c1 >= ((((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) > ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))?((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) : ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))))) {\n          for (c2 = (0 > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?0 : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) && c1 >= ((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16))))) {\n          for (c2 = (nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))); c2 <= (((((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nj; c3 <= 16 * c1 + 15; c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) && c1 >= ((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16))))) {\n          for (c2 = (((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))) && c1 >= ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))) {\n          for (c2 = (nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))); c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nm + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nm; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = nj; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) && c1 >= ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))) {\n          for (c2 = (nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))); c2 <= (((((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) && c1 >= ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))) {\n          for (c2 = (((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))) > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))) : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))) {\n          for (c2 = (((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))); c2 <= (((((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nj; c3 <= 16 * c1 + 15; c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))) {\n          for (c2 = (((((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))))) > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?((((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))))) : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)) && c1 >= ((((((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) > ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))?((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) : ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))))) > ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))?((((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) > ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))?((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) : ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))))) : ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))))) {\n          for (c2 = 0; c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)) && c1 >= ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))) {\n          for (c2 = (nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)) && c1 >= ((((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) > ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))?((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) : ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))))) {\n          for (c2 = (nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))); c2 <= (((((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)) && c1 >= ((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16))))) {\n          for (c2 = (((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))); c2 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)) && c1 >= ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))) {\n          for (c2 = (nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))); c2 <= (((((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))) {\n          for (c2 = (((((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))); c2 <= (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n      }\n    }\n    if (ni >= ((0 > -1 * nj + 1?0 : -1 * nj + 1)) && nj >= 0 && nk >= 1 && nm <= -1) {\n#pragma omp parallel for private(c2, c4, c3)\n      for (c1 = 0; c1 <= (((((nk + ni + -1) * 16 < 0?((16 < 0?-((-(nk + ni + -1) + 16 + 1) / 16) : -((-(nk + ni + -1) + 16 - 1) / 16))) : (nk + ni + -1) / 16)) < (((nk + ni + nj + -2) * 16 < 0?((16 < 0?-((-(nk + ni + nj + -2) + 16 + 1) / 16) : -((-(nk + ni + nj + -2) + 16 - 1) / 16))) : (nk + ni + nj + -2) / 16))?(((nk + ni + -1) * 16 < 0?((16 < 0?-((-(nk + ni + -1) + 16 + 1) / 16) : -((-(nk + ni + -1) + 16 - 1) / 16))) : (nk + ni + -1) / 16)) : (((nk + ni + nj + -2) * 16 < 0?((16 < 0?-((-(nk + ni + nj + -2) + 16 + 1) / 16) : -((-(nk + ni + nj + -2) + 16 - 1) / 16))) : (nk + ni + nj + -2) / 16)))); c1++) {\n        if (c1 <= (((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))))) {\n          for (c2 = 0; c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nk + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n#pragma omp simd\n              for (c4 = nk; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = nk; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = ni; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n          }\n        }\n        if (c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) && c1 >= ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))) {\n          for (c2 = 0; c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n          }\n        }\n        if (c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16))) {\n          for (c2 = (nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))); c2 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) && c1 >= ((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16))))) {\n          for (c2 = 0; c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))) {\n          for (c2 = (nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))); c2 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n          }\n        }\n      }\n    }\n    if (ni >= 0 && nj <= -1 && nk >= ((0 > -1 * nm + 1?0 : -1 * nm + 1)) && nm >= 0) {\n#pragma omp parallel for private(c2, c4, c3)\n      for (c1 = 0; c1 <= (((ni + nm + -1) * 16 < 0?((16 < 0?-((-(ni + nm + -1) + 16 + 1) / 16) : -((-(ni + nm + -1) + 16 - 1) / 16))) : (ni + nm + -1) / 16)); c1++) {\n        if (c1 <= (((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))))) {\n          for (c2 = 0; c2 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nm + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n#pragma omp simd\n              for (c4 = nk; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nm; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = ni; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) && c1 >= ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))) {\n          for (c2 = 0; c2 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n          }\n        }\n        if (c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16))) {\n          for (c2 = (0 > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?0 : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)) && c1 >= ((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16))))) {\n          for (c2 = 0; c2 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))) {\n          for (c2 = (nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))); c2 <= (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n      }\n    }\n    if (nj <= -1 && nk >= 1 && nm <= -1) {\n#pragma omp parallel for private(c2, c4, c3)\n      for (c1 = 0; c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)); c1++) {\n        for (c2 = 0; c2 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)); c2++) {\n          for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n            for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n              A[c3][c4] = ((double )c3) * c4 / ni;\n            }\n          }\n        }\n      }\n    }\n    if (ni >= 0 && nj >= 0 && nk <= -1 && nm >= 1) {\n#pragma omp parallel for private(c2, c4, c3)\n      for (c1 = 0; c1 <= (((nj + nm + -1) * 16 < 0?((16 < 0?-((-(nj + nm + -1) + 16 + 1) / 16) : -((-(nj + nm + -1) + 16 - 1) / 16))) : (nj + nm + -1) / 16)); c1++) {\n        if (c1 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))))) {\n          for (c2 = 0; c2 <= (((((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nm + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nm; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = nj; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) && c1 >= ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))) {\n          for (c2 = 0; c2 <= (((((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))) {\n          for (c2 = (0 > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?0 : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)) && c1 >= ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))) {\n          for (c2 = 0; c2 <= (((((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))) {\n          for (c2 = (nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))); c2 <= (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n      }\n    }\n    if (ni >= 0 && nj <= -1 && nk <= -1 && nl >= 1) {\n#pragma omp parallel for private(c2, c4, c3)\n      for (c1 = 0; c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)); c1++) {\n        for (c2 = 0; c2 <= (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)); c2++) {\n          for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n            for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n              D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n            }\n          }\n        }\n      }\n    }\n    if (ni <= -1 && nj >= ((0 > -1 * nm + 1?0 : -1 * nm + 1)) && nk >= ((0 > -1 * nm + 1?0 : -1 * nm + 1)) && nm >= 0) {\n#pragma omp parallel for private(c2, c4, c3)\n      for (c1 = 0; c1 <= (((((nk + nj + nm + -1) * 16 < 0?((16 < 0?-((-(nk + nj + nm + -1) + 16 + 1) / 16) : -((-(nk + nj + nm + -1) + 16 - 1) / 16))) : (nk + nj + nm + -1) / 16)) < (((nk + nj + 2 * nm + -2) * 16 < 0?((16 < 0?-((-(nk + nj + 2 * nm + -2) + 16 + 1) / 16) : -((-(nk + nj + 2 * nm + -2) + 16 - 1) / 16))) : (nk + nj + 2 * nm + -2) / 16))?(((nk + nj + nm + -1) * 16 < 0?((16 < 0?-((-(nk + nj + nm + -1) + 16 + 1) / 16) : -((-(nk + nj + nm + -1) + 16 - 1) / 16))) : (nk + nj + nm + -1) / 16)) : (((nk + nj + 2 * nm + -2) * 16 < 0?((16 < 0?-((-(nk + nj + 2 * nm + -2) + 16 + 1) / 16) : -((-(nk + nj + 2 * nm + -2) + 16 - 1) / 16))) : (nk + nj + 2 * nm + -2) / 16)))); c1++) {\n        if (c1 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))))) {\n          for (c2 = 0; c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)) < nm + -1?((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)) < nm + -1?((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)) : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nm + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (nl > nm?nl : nm); c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (nj > nl?nj : nl); c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = (nj > nm?nj : nm); c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nm; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nm; c4 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c4++) {\n                  B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                }\n              }\n            }\n            for (c3 = nj; c3 <= ((((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) < nm + -1?((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nj; c4 <= ((16 * c1 + 15 < nl + -1?16 * c1 + 15 : nl + -1)); c4++) {\n                  D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n                }\n              }\n            }\n            for (c3 = (nj > nm?nj : nm); c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = nk; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nm + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = (nk > nm?nk : nm); c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = (nj > nk?nj : nk); c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) && c1 >= ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))) {\n          for (c2 = 0; c2 <= (((((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= 16 * c2 + 15; c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = nj; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= 16 * c2 + 15; c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = nk; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))))) {\n          for (c2 = (0 > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?0 : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nm + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = nj; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = nk; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))) && c1 >= ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))) {\n          for (c2 = 0; c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) < nm + -1?((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nm; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = nk; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) && c1 >= ((((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))))) {\n          for (c2 = 0; c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) && c1 >= ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))) {\n          for (c2 = (0 > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?0 : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))))) {\n          for (c2 = (nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) < nm + -1?((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nm; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = nk; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) && c1 >= ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))) {\n          for (c2 = (nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))) {\n          for (c2 = (((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16)))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16)))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))); c2 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))) && c1 >= ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))) {\n          for (c2 = 0; c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nm + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nm; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = nj; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) && c1 >= ((((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))))) {\n          for (c2 = 0; c2 <= (((((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) && c1 >= ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))) {\n          for (c2 = (0 > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?0 : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))) {\n          for (c2 = (nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))); c2 <= (((((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nj; c3 <= 16 * c1 + 15; c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))) {\n          for (c2 = (((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)) && c1 >= ((((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))))) {\n          for (c2 = 0; c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)) && c1 >= ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))) {\n          for (c2 = (nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)) && c1 >= ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))) {\n          for (c2 = (nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))); c2 <= (((((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))) {\n          for (c2 = (((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))); c2 <= (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n      }\n    }\n    if (ni <= -1 && nj >= 1 && nm <= -1) {\n#pragma omp parallel for private(c2, c4, c3)\n      for (c1 = 0; c1 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)); c1++) {\n        for (c2 = 0; c2 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)); c2++) {\n          for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n            for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n              B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n            }\n          }\n        }\n      }\n    }\n    if (ni <= -1 && nj <= -1 && nk >= 0 && nl >= 1) {\n#pragma omp parallel for private(c2, c4, c3)\n      for (c1 = 0; c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)); c1++) {\n        for (c2 = 0; c2 <= (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)); c2++) {\n          for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n            for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n              D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n            }\n          }\n        }\n      }\n    }\n    if (ni <= -1 && nj >= 0 && nk <= -1 && nm >= 1) {\n#pragma omp parallel for private(c2, c4, c3)\n      for (c1 = 0; c1 <= (((nj + nm + -1) * 16 < 0?((16 < 0?-((-(nj + nm + -1) + 16 + 1) / 16) : -((-(nj + nm + -1) + 16 - 1) / 16))) : (nj + nm + -1) / 16)); c1++) {\n        if (c1 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))))) {\n          for (c2 = 0; c2 <= (((((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nm + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nm; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = nj; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) && c1 >= ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))) {\n          for (c2 = 0; c2 <= (((((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))) {\n          for (c2 = (0 > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?0 : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)) && c1 >= ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))) {\n          for (c2 = 0; c2 <= (((((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))) {\n          for (c2 = (nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))); c2 <= (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n      }\n    }\n    if (ni <= -1 && nj <= -1 && nk <= -1 && nl >= 1) {\n#pragma omp parallel for private(c2, c4, c3)\n      for (c1 = 0; c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)); c1++) {\n        for (c2 = 0; c2 <= (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)); c2++) {\n          for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n            for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n              D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n            }\n          }\n        }\n      }\n    }\n  }\n}\n/* DCE code. Must scan the entire live-out data.\n   Can be used also to check the correctness of the output. */\n\nstatic void print_array(int ni,int nl,double G[128 + 0][128 + 0])\n{\n  int i;\n  int j;\n  for (i = 0; i < ni; i++) \n    for (j = 0; j < nl; j++) {\n      fprintf(stderr,\"%0.2lf \",G[i][j]);\n      if ((i * ni + j) % 20 == 0) \n        fprintf(stderr,\"\\n\");\n    }\n  fprintf(stderr,\"\\n\");\n}\n/* Main computational kernel. The whole function will be timed,\n   including the call and return. */\n\nstatic void kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[128 + 0][128 + 0],double A[128 + 0][128 + 0],double B[128 + 0][128 + 0],double F[128 + 0][128 + 0],double C[128 + 0][128 + 0],double D[128 + 0][128 + 0],double G[128 + 0][128 + 0])\n{\n  // int i;\n  // int j;\n  // int k;\n  \n  //#pragma scop\n{\n    int c5;\n    int c10;\n    int c2;\n    int c1;\n    int c6;\n    int c7;\n    if (ni >= 0 && nj >= 0 && nl >= 1) {\n#pragma omp parallel for private(c7, c2, c10)\n      for (c1 = 0; c1 <= (((nj + ni + -1) * 16 < 0?((16 < 0?-((-(nj + ni + -1) + 16 + 1) / 16) : -((-(nj + ni + -1) + 16 - 1) / 16))) : (nj + ni + -1) / 16)); c1++) {\n        for (c2 = 0; c2 <= (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)); c2++) {\n          if (c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16))) {\n            for (c7 = 16 * c2; c7 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c7++) {\n#pragma omp simd\n              for (c10 = 16 * c1; c10 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c10++) {\n                G[c10][c7] = 0;\n              }\n            }\n          }\n          if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))) {\n            for (c7 = 16 * c2; c7 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c7++) {\n#pragma omp simd\n              for (c10 = 16 * c1; c10 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c10++) {\n                F[c10][c7] = 0;\n              }\n            }\n          }\n        }\n      }\n    }\n    if (ni <= -1 && nl >= 1) {\n#pragma omp parallel for private(c7, c2, c10)\n      for (c1 = 0; c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)); c1++) {\n        for (c2 = 0; c2 <= (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)); c2++) {\n          for (c7 = 16 * c2; c7 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c7++) {\n#pragma omp simd\n            for (c10 = 16 * c1; c10 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c10++) {\n              F[c10][c7] = 0;\n            }\n          }\n        }\n      }\n    }\n    if (nj <= -1 && nl >= 1) {\n#pragma omp parallel for private(c7, c2, c10)\n      for (c1 = 0; c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)); c1++) {\n        for (c2 = 0; c2 <= (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)); c2++) {\n          for (c7 = 16 * c2; c7 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c7++) {\n#pragma omp simd\n            for (c10 = 16 * c1; c10 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c10++) {\n              G[c10][c7] = 0;\n            }\n          }\n        }\n      }\n    }\n    if (nl >= 1 && nm >= 1) {\n#pragma omp parallel for private(c7, c6, c2, c10, c5)\n      for (c1 = 0; c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)); c1++) {\n        for (c2 = 0; c2 <= (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)); c2++) {\n          for (c5 = 0; c5 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)); c5++) {\n            for (c6 = 16 * c5; c6 <= ((16 * c5 + 15 < nm + -1?16 * c5 + 15 : nm + -1)); c6++) {\n              for (c7 = 16 * c2; c7 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c7++) {\n#pragma omp simd\n                for (c10 = 16 * c1; c10 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c10++) {\n                  F[c10][c7] += C[c10][c6] * D[c6][c7];\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    if (nj >= 1) {\n#pragma omp parallel for private(c7, c2, c10)\n      for (c1 = 0; c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)); c1++) {\n        for (c2 = 0; c2 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)); c2++) {\n          for (c7 = 16 * c2; c7 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c7++) {\n#pragma omp simd\n            for (c10 = 16 * c1; c10 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c10++) {\n              E[c10][c7] = 0;\n            }\n          }\n        }\n      }\n    }\n    if (nj >= 1) {\n#pragma omp parallel for private(c7, c6, c2, c10, c5)\n      for (c1 = 0; c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)); c1++) {\n        for (c2 = 0; c2 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)); c2++) {\n          for (c5 = 0; c5 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)); c5++) {\n            for (c6 = 16 * c5; c6 <= ((16 * c5 + 15 < nk + -1?16 * c5 + 15 : nk + -1)); c6++) {\n              for (c7 = 16 * c2; c7 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c7++) {\n#pragma omp simd\n                for (c10 = 16 * c1; c10 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c10++) {\n                  E[c10][c7] += A[c10][c6] * B[c6][c7];\n                }\n              }\n            }\n          }\n          for (c5 = 0; c5 <= (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)); c5++) {\n            for (c6 = 16 * c5; c6 <= ((16 * c5 + 15 < nl + -1?16 * c5 + 15 : nl + -1)); c6++) {\n              for (c7 = 16 * c2; c7 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c7++) {\n#pragma omp simd\n                for (c10 = 16 * c1; c10 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c10++) {\n                  G[c10][c6] += E[c10][c7] * F[c7][c6];\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  \n  //#pragma endscop\n}\n\nint main(int argc,char **argv)\n{\n/* Retrieve problem size. */\n  int ni = 128;\n  int nj = 128;\n  int nk = 128;\n  int nl = 128;\n  int nm = 128;\n/* Variable declaration/allocation. */\n  double (*E)[128 + 0][128 + 0];\n  E = ((double (*)[128 + 0][128 + 0])(polybench_alloc_data(((128 + 0) * (128 + 0)),(sizeof(double )))));\n  ;\n  double (*A)[128 + 0][128 + 0];\n  A = ((double (*)[128 + 0][128 + 0])(polybench_alloc_data(((128 + 0) * (128 + 0)),(sizeof(double )))));\n  ;\n  double (*B)[128 + 0][128 + 0];\n  B = ((double (*)[128 + 0][128 + 0])(polybench_alloc_data(((128 + 0) * (128 + 0)),(sizeof(double )))));\n  ;\n  double (*F)[128 + 0][128 + 0];\n  F = ((double (*)[128 + 0][128 + 0])(polybench_alloc_data(((128 + 0) * (128 + 0)),(sizeof(double )))));\n  ;\n  double (*C)[128 + 0][128 + 0];\n  C = ((double (*)[128 + 0][128 + 0])(polybench_alloc_data(((128 + 0) * (128 + 0)),(sizeof(double )))));\n  ;\n  double (*D)[128 + 0][128 + 0];\n  D = ((double (*)[128 + 0][128 + 0])(polybench_alloc_data(((128 + 0) * (128 + 0)),(sizeof(double )))));\n  ;\n  double (*G)[128 + 0][128 + 0];\n  G = ((double (*)[128 + 0][128 + 0])(polybench_alloc_data(((128 + 0) * (128 + 0)),(sizeof(double )))));\n  ;\n/* Initialize array(s). */\n  init_array(ni,nj,nk,nl,nm, *A, *B, *C, *D);\n/* Start timer. */\n  polybench_timer_start();\n  ;\n/* Run kernel. */\n  kernel_3mm(ni,nj,nk,nl,nm, *E, *A, *B, *F, *C, *D, *G);\n/* Stop and print timer. */\n  polybench_timer_stop();\n  ;\n  polybench_timer_print();\n  ;\n/* Prevent dead-code elimination. All live-out data must be printed\n     by the function call in argument. */\n  if (argc > 42 && !strcmp(argv[0],\"\")) \n    print_array(ni,nl, *G);\n/* Be clean. */\n  free(((void *)E));\n  ;\n  free(((void *)A));\n  ;\n  free(((void *)B));\n  ;\n  free(((void *)F));\n  ;\n  free(((void *)C));\n  ;\n  free(((void *)D));\n  ;\n  free(((void *)G));\n  ;\n  return 0;\n}\n",
        "data_race": 0,
        "trimmed_code": "#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <math.h>\n\n#include \"polybench/polybench.h\"\n\n\n#include \"polybench/3mm.h\"\n\n\nstatic void init_array(int ni,int nj,int nk,int nl,int nm,double A[128 + 0][128 + 0],double B[128 + 0][128 + 0],double C[128 + 0][128 + 0],double D[128 + 0][128 + 0])\n{\n  \n  \n{\n    int c3;\n    int c4;\n    int c1;\n    int c2;\n    if (ni >= ((0 > -1 * nj + -1 * nm + 1?0 : -1 * nj + -1 * nm + 1)) && nj >= 0 && nk >= ((0 > -1 * nm + 1?0 : -1 * nm + 1)) && nm >= 0) {\n#pragma omp parallel for private(c2, c4, c3)\n      for (c1 = 0; c1 <= (((((nk + ni + nj + nm + -1) * 16 < 0?((16 < 0?-((-(nk + ni + nj + nm + -1) + 16 + 1) / 16) : -((-(nk + ni + nj + nm + -1) + 16 - 1) / 16))) : (nk + ni + nj + nm + -1) / 16)) < (((nk + ni + nj + 2 * nm + -2) * 16 < 0?((16 < 0?-((-(nk + ni + nj + 2 * nm + -2) + 16 + 1) / 16) : -((-(nk + ni + nj + 2 * nm + -2) + 16 - 1) / 16))) : (nk + ni + nj + 2 * nm + -2) / 16))?(((nk + ni + nj + nm + -1) * 16 < 0?((16 < 0?-((-(nk + ni + nj + nm + -1) + 16 + 1) / 16) : -((-(nk + ni + nj + nm + -1) + 16 - 1) / 16))) : (nk + ni + nj + nm + -1) / 16)) : (((nk + ni + nj + 2 * nm + -2) * 16 < 0?((16 < 0?-((-(nk + ni + nj + 2 * nm + -2) + 16 + 1) / 16) : -((-(nk + ni + nj + 2 * nm + -2) + 16 - 1) / 16))) : (nk + ni + nj + 2 * nm + -2) / 16)))); c1++) {\n        if (c1 <= (((((((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)))) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)))) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)))) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)))) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))))) {\n          for (c2 = 0; c2 <= (((((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)) < nk + -1?((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)) : nk + -1)) < nm + -1?((((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)) < nk + -1?((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)) : nk + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)) < nl + -1?((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)) : nl + -1)) < nm + -1?((((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)) < nl + -1?((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)) : nl + -1)) : nm + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)) < nm + -1?((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)) : nm + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)) < nl + -1?((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)) : nl + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (nl > nm?nl : nm); c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)) < nm + -1?((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)) : nm + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (nj > nl?nj : nl); c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nm + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nm + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = (nj > nm?nj : nm); c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (((nj > nl?nj : nl)) > nm?((nj > nl?nj : nl)) : nm); c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n#pragma omp simd\n              for (c4 = nk; c4 <= ((((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)) < nm + -1?((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)) : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (nk > nl?nk : nl); c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nm + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = (nk > nm?nk : nm); c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (((nk > nl?nk : nl)) > nm?((nk > nl?nk : nl)) : nm); c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = (nj > nk?nj : nk); c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (((nj > nk?nj : nk)) > nl?((nj > nk?nj : nk)) : nl); c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = (((nj > nk?nj : nk)) > nm?((nj > nk?nj : nk)) : nm); c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nm; c3 <= ((((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)) < nk + -1?((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nm; c4 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)); c4++) {\n                  A[c3][c4] = ((double )c3) * c4 / ni;\n                  B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                }\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nj; c4 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c4++) {\n                  A[c3][c4] = ((double )c3) * c4 / ni;\n                }\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nk; c4 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c4++) {\n                  B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                }\n              }\n            }\n            for (c3 = nj; c3 <= ((((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nk + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nk + -1)) < nm + -1?((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nk + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nk + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nj; c4 <= ((((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) < nl + -1?((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) : nl + -1)); c4++) {\n                  A[c3][c4] = ((double )c3) * c4 / ni;\n                  D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n                }\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = (nj > nl?nj : nl); c4 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c4++) {\n                  A[c3][c4] = ((double )c3) * c4 / ni;\n                }\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nk; c4 <= ((16 * c1 + 15 < nl + -1?16 * c1 + 15 : nl + -1)); c4++) {\n                  D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n                }\n              }\n            }\n            for (c3 = (nj > nm?nj : nm); c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nk + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nj; c4 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c4++) {\n                  A[c3][c4] = ((double )c3) * c4 / ni;\n                }\n              }\n            }\n            for (c3 = nk; c3 <= ((((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)) < nm + -1?((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nk; c4 <= ((((16 * c1 + 15 < nl + -1?16 * c1 + 15 : nl + -1)) < nm + -1?((16 * c1 + 15 < nl + -1?16 * c1 + 15 : nl + -1)) : nm + -1)); c4++) {\n                  C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                  D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n                }\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = (nk > nl?nk : nl); c4 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c4++) {\n                  C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                }\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nm; c4 <= ((16 * c1 + 15 < nl + -1?16 * c1 + 15 : nl + -1)); c4++) {\n                  D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n                }\n              }\n            }\n            for (c3 = (nk > nm?nk : nm); c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nm + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nm + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nm; c4 <= nk + -1; c4++) {\n                  A[c3][c4] = ((double )c3) * c4 / ni;\n                }\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nk; c4 <= nm + -1; c4++) {\n                  C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                }\n              }\n            }\n            for (c3 = (nj > nk?nj : nk); c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nm + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nk; c4 <= ((16 * c1 + 15 < nl + -1?16 * c1 + 15 : nl + -1)); c4++) {\n                  D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n                }\n              }\n            }\n            for (c3 = (((nj > nk?nj : nk)) > nm?((nj > nk?nj : nk)) : nm); c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = ni; c3 <= ((((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)) < nm + -1?((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)) < nm + -1?((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)) : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nm + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (nl > nm?nl : nm); c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (nj > nl?nj : nl); c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = (nj > nm?nj : nm); c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = (ni > nm?ni : nm); c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nm; c4 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c4++) {\n                  B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                }\n              }\n            }\n            for (c3 = (ni > nj?ni : nj); c3 <= ((((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) < nm + -1?((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nj; c4 <= ((16 * c1 + 15 < nl + -1?16 * c1 + 15 : nl + -1)); c4++) {\n                  D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n                }\n              }\n            }\n            for (c3 = (((ni > nj?ni : nj)) > nm?((ni > nj?ni : nj)) : nm); c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = (ni > nk?ni : nk); c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nm + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nm; c4 <= ((16 * c1 + 15 < nl + -1?16 * c1 + 15 : nl + -1)); c4++) {\n                  D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n                }\n              }\n            }\n            for (c3 = (((ni > nk?ni : nk)) > nm?((ni > nk?ni : nk)) : nm); c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = (((ni > nj?ni : nj)) > nk?((ni > nj?ni : nj)) : nk); c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)))) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)))) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) && c1 >= ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))) {\n          for (c2 = 0; c2 <= (((((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)) < nk + -1?((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= 16 * c2 + 15; c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = nj; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nk + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= 16 * c2 + 15; c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = nk; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= 16 * c2 + 15; c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = (nj > nk?nj : nk); c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= 16 * c2 + 15; c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = ni; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= 16 * c2 + 15; c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = (ni > nj?ni : nj); c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= 16 * c2 + 15; c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = (ni > nk?ni : nk); c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)))) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)))) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))))) {\n          for (c2 = (0 > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?0 : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)) < nk + -1?((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)) < nm + -1?((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)) : nm + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nm + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nm + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = (nj > nm?nj : nm); c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n#pragma omp simd\n              for (c4 = nk; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nm + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = (nk > nm?nk : nm); c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = (nj > nk?nj : nk); c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = nj; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nk + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nj; c4 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c4++) {\n                  A[c3][c4] = ((double )c3) * c4 / ni;\n                }\n              }\n            }\n            for (c3 = nk; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nm + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nm + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nk; c4 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c4++) {\n                  C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                }\n              }\n            }\n            for (c3 = (nj > nk?nj : nk); c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = ni; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nm + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = (ni > nj?ni : nj); c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = (ni > nk?ni : nk); c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))) && c1 >= ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))) {\n          for (c2 = 0; c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nk + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nk + -1)) < nm + -1?((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nk + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nk + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (nj > nl?nj : nl); c4 <= 16 * c2 + 15; c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = nm; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nk + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= 16 * c2 + 15; c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = nk; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nm + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= 16 * c2 + 15; c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = (nk > nm?nk : nm); c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= 16 * c2 + 15; c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = ni; c3 <= ((((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) < nm + -1?((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = (ni > nm?ni : nm); c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = (ni > nk?ni : nk); c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) && c1 >= ((((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))))) {\n          for (c2 = 0; c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nk + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= 16 * c2 + 15; c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = nk; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= 16 * c2 + 15; c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = ni; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) && c1 >= ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))) {\n          for (c2 = (0 > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?0 : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nk + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= 16 * c2 + 15; c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = nk; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= 16 * c2 + 15; c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = ni; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))))) {\n          for (c2 = (nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))); c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nm + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)) < nl + -1?((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)) : nl + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (nj > nl?nj : nl); c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n#pragma omp simd\n              for (c4 = nk; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (nk > nl?nk : nl); c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = (nj > nk?nj : nk); c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nm; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n#pragma omp simd\n              for (c4 = nk; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = ni; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = (ni > nm?ni : nm); c3 <= 16 * c1 + 15; c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) && c1 >= ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))) {\n          for (c2 = (nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))); c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nk + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n#pragma omp simd\n              for (c4 = nk; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = nk; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = ni; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))))) {\n          for (c2 = (((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16)))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16)))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nk + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n#pragma omp simd\n              for (c4 = nk; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = nk; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = ni; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))) && c1 >= ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))) {\n          for (c2 = 0; c2 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)) < nm + -1?((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nk; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (nk > nl?nk : nl); c4 <= 16 * c2 + 15; c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = nm; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nk; c4 <= 16 * c2 + 15; c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = nj; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nm + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n#pragma omp simd\n              for (c4 = nk; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = (nj > nm?nj : nm); c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = ni; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nm + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= 16 * c2 + 15; c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = (ni > nm?ni : nm); c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= 16 * c2 + 15; c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = (ni > nj?ni : nj); c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)))) && c1 >= ((((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))))) {\n          for (c2 = 0; c2 <= (((((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nm + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nm + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n#pragma omp simd\n              for (c4 = nk; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = nj; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = ni; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)))) && c1 >= ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))) {\n          for (c2 = (0 > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?0 : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nm + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nm + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n#pragma omp simd\n              for (c4 = nk; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = nj; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = ni; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))) && c1 >= ((((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))))) {\n          for (c2 = 0; c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nm + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n#pragma omp simd\n              for (c4 = nk; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nm; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = ni; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) && c1 >= ((((((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))))) {\n          for (c2 = 0; c2 <= (((((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n          }\n        }\n        if (c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) && c1 >= ((((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))))) {\n          for (c2 = (0 > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?0 : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n          }\n        }\n        if (c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) && c1 >= ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))) {\n          for (c2 = (nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))))) {\n          for (c2 = (nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))); c2 <= (((((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)) < nm + -1?((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)) : nm + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nm + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nm + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (nl > nm?nl : nm); c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n#pragma omp simd\n              for (c4 = nk; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (nk > nl?nk : nl); c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = (nk > nm?nk : nm); c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nj; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n#pragma omp simd\n              for (c4 = nk; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = ni; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = (ni > nj?ni : nj); c3 <= 16 * c1 + 15; c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))))) {\n          for (c2 = (((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nm + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nm + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n#pragma omp simd\n              for (c4 = nk; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = nj; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = ni; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))) && c1 >= ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))) {\n          for (c2 = (nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))); c2 <= (((((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nm + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n#pragma omp simd\n              for (c4 = nk; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nm; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = ni; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) && c1 >= ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))) {\n          for (c2 = (nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))); c2 <= (((((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n          }\n        }\n        if (c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) && c1 >= ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))) {\n          for (c2 = (((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))))) {\n          for (c2 = (((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))); c2 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nm + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n#pragma omp simd\n              for (c4 = nk; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nm; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = ni; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) && c1 >= ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))) {\n          for (c2 = (((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))); c2 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n          }\n        }\n        if (c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16))) {\n          for (c2 = (((((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16)))))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16)))))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))); c2 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))) && c1 >= ((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16))))) {\n          for (c2 = 0; c2 <= (((((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)) < nm + -1?((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)) < nm + -1?((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)) : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nm + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (nl > nm?nl : nm); c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (nj > nl?nj : nl); c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = (nj > nm?nj : nm); c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nm; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nm; c4 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c4++) {\n                  B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                }\n              }\n            }\n            for (c3 = nj; c3 <= ((((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) < nm + -1?((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nj; c4 <= ((16 * c1 + 15 < nl + -1?16 * c1 + 15 : nl + -1)); c4++) {\n                  D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n                }\n              }\n            }\n            for (c3 = (nj > nm?nj : nm); c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = nk; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nm + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nm; c4 <= ((16 * c1 + 15 < nl + -1?16 * c1 + 15 : nl + -1)); c4++) {\n                  D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n                }\n              }\n            }\n            for (c3 = (nk > nm?nk : nm); c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = (nj > nk?nj : nk); c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) && c1 >= ((((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))))) {\n          for (c2 = 0; c2 <= (((((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= 16 * c2 + 15; c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = nj; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= 16 * c2 + 15; c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = nk; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) && c1 >= ((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16))))) {\n          for (c2 = (0 > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?0 : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nm + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = nj; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = nk; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))) && c1 >= ((((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) > ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))?((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) : ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))))) {\n          for (c2 = 0; c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) < nm + -1?((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nm; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = nk; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) && c1 >= ((((((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) > ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))?((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) : ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) > ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))?((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) : ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))))) {\n          for (c2 = 0; c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) && c1 >= ((((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) > ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))?((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) : ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))))) {\n          for (c2 = (0 > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?0 : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)) && c1 >= ((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16))))) {\n          for (c2 = (nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))); c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nm; c3 <= 16 * c1 + 15; c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) && c1 >= ((((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))))) {\n          for (c2 = (nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))); c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) && c1 >= ((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16))))) {\n          for (c2 = (((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16)))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16)))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))) {\n          for (c2 = (nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))); c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)) < nm + -1?((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)) : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nm + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (nl > nm?nl : nm); c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (nj > nl?nj : nl); c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = (nj > nm?nj : nm); c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nk; c3 <= 16 * c1 + 15; c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))) {\n          for (c2 = (((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))) > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))) : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nm + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = nk; c3 <= 16 * c1 + 15; c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))))) {\n          for (c2 = (((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) < nm + -1?((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nm; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = nk; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) && c1 >= ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))) {\n          for (c2 = (nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))) {\n          for (c2 = (((((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))) > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))) : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16)))))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))) > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))) : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16)))))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))); c2 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))) && c1 >= ((((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) > ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))?((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) : ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))))) {\n          for (c2 = 0; c2 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nm + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= 16 * c2 + 15; c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = nm; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= 16 * c2 + 15; c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = nj; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) && c1 >= ((((((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) > ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))?((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) : ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) > ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))?((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) : ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))))) {\n          for (c2 = 0; c2 <= (((((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) && c1 >= ((((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) > ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))?((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) : ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))))) {\n          for (c2 = (0 > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?0 : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) && c1 >= ((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16))))) {\n          for (c2 = (nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))); c2 <= (((((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nj; c3 <= 16 * c1 + 15; c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) && c1 >= ((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16))))) {\n          for (c2 = (((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))) && c1 >= ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))) {\n          for (c2 = (nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))); c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nm + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nm; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = nj; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) && c1 >= ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))) {\n          for (c2 = (nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))); c2 <= (((((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) && c1 >= ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))) {\n          for (c2 = (((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))) > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))) : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))) {\n          for (c2 = (((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))); c2 <= (((((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nj; c3 <= 16 * c1 + 15; c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))) {\n          for (c2 = (((((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))))) > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?((((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))))) : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)) && c1 >= ((((((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) > ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))?((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) : ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))))) > ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))?((((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) > ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))?((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) : ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))))) : ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))))) {\n          for (c2 = 0; c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)) && c1 >= ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))) {\n          for (c2 = (nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)) && c1 >= ((((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) > ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))?((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) : ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))))) {\n          for (c2 = (nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))); c2 <= (((((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)) && c1 >= ((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16))))) {\n          for (c2 = (((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))); c2 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)) && c1 >= ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))) {\n          for (c2 = (nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))); c2 <= (((((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))) {\n          for (c2 = (((((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))); c2 <= (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n      }\n    }\n    if (ni >= ((0 > -1 * nj + 1?0 : -1 * nj + 1)) && nj >= 0 && nk >= 1 && nm <= -1) {\n#pragma omp parallel for private(c2, c4, c3)\n      for (c1 = 0; c1 <= (((((nk + ni + -1) * 16 < 0?((16 < 0?-((-(nk + ni + -1) + 16 + 1) / 16) : -((-(nk + ni + -1) + 16 - 1) / 16))) : (nk + ni + -1) / 16)) < (((nk + ni + nj + -2) * 16 < 0?((16 < 0?-((-(nk + ni + nj + -2) + 16 + 1) / 16) : -((-(nk + ni + nj + -2) + 16 - 1) / 16))) : (nk + ni + nj + -2) / 16))?(((nk + ni + -1) * 16 < 0?((16 < 0?-((-(nk + ni + -1) + 16 + 1) / 16) : -((-(nk + ni + -1) + 16 - 1) / 16))) : (nk + ni + -1) / 16)) : (((nk + ni + nj + -2) * 16 < 0?((16 < 0?-((-(nk + ni + nj + -2) + 16 + 1) / 16) : -((-(nk + ni + nj + -2) + 16 - 1) / 16))) : (nk + ni + nj + -2) / 16)))); c1++) {\n        if (c1 <= (((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))))) {\n          for (c2 = 0; c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nk + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n#pragma omp simd\n              for (c4 = nk; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = nk; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = ni; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n          }\n        }\n        if (c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) && c1 >= ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))) {\n          for (c2 = 0; c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n          }\n        }\n        if (c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16))) {\n          for (c2 = (nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))); c2 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) && c1 >= ((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16))))) {\n          for (c2 = 0; c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))) {\n          for (c2 = (nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))); c2 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n          }\n        }\n      }\n    }\n    if (ni >= 0 && nj <= -1 && nk >= ((0 > -1 * nm + 1?0 : -1 * nm + 1)) && nm >= 0) {\n#pragma omp parallel for private(c2, c4, c3)\n      for (c1 = 0; c1 <= (((ni + nm + -1) * 16 < 0?((16 < 0?-((-(ni + nm + -1) + 16 + 1) / 16) : -((-(ni + nm + -1) + 16 - 1) / 16))) : (ni + nm + -1) / 16)); c1++) {\n        if (c1 <= (((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))))) {\n          for (c2 = 0; c2 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nm + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n#pragma omp simd\n              for (c4 = nk; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nm; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = ni; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) && c1 >= ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))) {\n          for (c2 = 0; c2 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n          }\n        }\n        if (c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16))) {\n          for (c2 = (0 > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?0 : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)) && c1 >= ((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16))))) {\n          for (c2 = 0; c2 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))) {\n          for (c2 = (nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))); c2 <= (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n      }\n    }\n    if (nj <= -1 && nk >= 1 && nm <= -1) {\n#pragma omp parallel for private(c2, c4, c3)\n      for (c1 = 0; c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)); c1++) {\n        for (c2 = 0; c2 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)); c2++) {\n          for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n            for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n              A[c3][c4] = ((double )c3) * c4 / ni;\n            }\n          }\n        }\n      }\n    }\n    if (ni >= 0 && nj >= 0 && nk <= -1 && nm >= 1) {\n#pragma omp parallel for private(c2, c4, c3)\n      for (c1 = 0; c1 <= (((nj + nm + -1) * 16 < 0?((16 < 0?-((-(nj + nm + -1) + 16 + 1) / 16) : -((-(nj + nm + -1) + 16 - 1) / 16))) : (nj + nm + -1) / 16)); c1++) {\n        if (c1 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))))) {\n          for (c2 = 0; c2 <= (((((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nm + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nm; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = nj; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) && c1 >= ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))) {\n          for (c2 = 0; c2 <= (((((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))) {\n          for (c2 = (0 > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?0 : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)) && c1 >= ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))) {\n          for (c2 = 0; c2 <= (((((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))) {\n          for (c2 = (nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))); c2 <= (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n      }\n    }\n    if (ni >= 0 && nj <= -1 && nk <= -1 && nl >= 1) {\n#pragma omp parallel for private(c2, c4, c3)\n      for (c1 = 0; c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)); c1++) {\n        for (c2 = 0; c2 <= (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)); c2++) {\n          for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n            for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n              D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n            }\n          }\n        }\n      }\n    }\n    if (ni <= -1 && nj >= ((0 > -1 * nm + 1?0 : -1 * nm + 1)) && nk >= ((0 > -1 * nm + 1?0 : -1 * nm + 1)) && nm >= 0) {\n#pragma omp parallel for private(c2, c4, c3)\n      for (c1 = 0; c1 <= (((((nk + nj + nm + -1) * 16 < 0?((16 < 0?-((-(nk + nj + nm + -1) + 16 + 1) / 16) : -((-(nk + nj + nm + -1) + 16 - 1) / 16))) : (nk + nj + nm + -1) / 16)) < (((nk + nj + 2 * nm + -2) * 16 < 0?((16 < 0?-((-(nk + nj + 2 * nm + -2) + 16 + 1) / 16) : -((-(nk + nj + 2 * nm + -2) + 16 - 1) / 16))) : (nk + nj + 2 * nm + -2) / 16))?(((nk + nj + nm + -1) * 16 < 0?((16 < 0?-((-(nk + nj + nm + -1) + 16 + 1) / 16) : -((-(nk + nj + nm + -1) + 16 - 1) / 16))) : (nk + nj + nm + -1) / 16)) : (((nk + nj + 2 * nm + -2) * 16 < 0?((16 < 0?-((-(nk + nj + 2 * nm + -2) + 16 + 1) / 16) : -((-(nk + nj + 2 * nm + -2) + 16 - 1) / 16))) : (nk + nj + 2 * nm + -2) / 16)))); c1++) {\n        if (c1 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))))) {\n          for (c2 = 0; c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)) < nm + -1?((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)) < nm + -1?((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)) : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nm + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (nl > nm?nl : nm); c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (nj > nl?nj : nl); c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = (nj > nm?nj : nm); c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nm; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nm; c4 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c4++) {\n                  B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                }\n              }\n            }\n            for (c3 = nj; c3 <= ((((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) < nm + -1?((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nj; c4 <= ((16 * c1 + 15 < nl + -1?16 * c1 + 15 : nl + -1)); c4++) {\n                  D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n                }\n              }\n            }\n            for (c3 = (nj > nm?nj : nm); c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = nk; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nm + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = (nk > nm?nk : nm); c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = (nj > nk?nj : nk); c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) && c1 >= ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))) {\n          for (c2 = 0; c2 <= (((((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= 16 * c2 + 15; c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = nj; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= 16 * c2 + 15; c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = nk; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))))) {\n          for (c2 = (0 > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?0 : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nm + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = nj; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = nk; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))) && c1 >= ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))) {\n          for (c2 = 0; c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) < nm + -1?((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nm; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = nk; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) && c1 >= ((((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))))) {\n          for (c2 = 0; c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) && c1 >= ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))) {\n          for (c2 = (0 > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?0 : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))))) {\n          for (c2 = (nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) < nm + -1?((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nm; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = nk; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) && c1 >= ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))) {\n          for (c2 = (nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))) {\n          for (c2 = (((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16)))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16)))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))); c2 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))) && c1 >= ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))) {\n          for (c2 = 0; c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nm + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nm; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = nj; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) && c1 >= ((((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))))) {\n          for (c2 = 0; c2 <= (((((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) && c1 >= ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))) {\n          for (c2 = (0 > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?0 : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))) {\n          for (c2 = (nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))); c2 <= (((((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nj; c3 <= 16 * c1 + 15; c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))) {\n          for (c2 = (((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)) && c1 >= ((((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))))) {\n          for (c2 = 0; c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)) && c1 >= ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))) {\n          for (c2 = (nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)) && c1 >= ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))) {\n          for (c2 = (nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))); c2 <= (((((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))) {\n          for (c2 = (((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))); c2 <= (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n      }\n    }\n    if (ni <= -1 && nj >= 1 && nm <= -1) {\n#pragma omp parallel for private(c2, c4, c3)\n      for (c1 = 0; c1 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)); c1++) {\n        for (c2 = 0; c2 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)); c2++) {\n          for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n            for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n              B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n            }\n          }\n        }\n      }\n    }\n    if (ni <= -1 && nj <= -1 && nk >= 0 && nl >= 1) {\n#pragma omp parallel for private(c2, c4, c3)\n      for (c1 = 0; c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)); c1++) {\n        for (c2 = 0; c2 <= (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)); c2++) {\n          for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n            for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n              D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n            }\n          }\n        }\n      }\n    }\n    if (ni <= -1 && nj >= 0 && nk <= -1 && nm >= 1) {\n#pragma omp parallel for private(c2, c4, c3)\n      for (c1 = 0; c1 <= (((nj + nm + -1) * 16 < 0?((16 < 0?-((-(nj + nm + -1) + 16 + 1) / 16) : -((-(nj + nm + -1) + 16 - 1) / 16))) : (nj + nm + -1) / 16)); c1++) {\n        if (c1 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))))) {\n          for (c2 = 0; c2 <= (((((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nm + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nm; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = nj; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) && c1 >= ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))) {\n          for (c2 = 0; c2 <= (((((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))) {\n          for (c2 = (0 > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?0 : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)) && c1 >= ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))) {\n          for (c2 = 0; c2 <= (((((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))) {\n          for (c2 = (nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))); c2 <= (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n      }\n    }\n    if (ni <= -1 && nj <= -1 && nk <= -1 && nl >= 1) {\n#pragma omp parallel for private(c2, c4, c3)\n      for (c1 = 0; c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)); c1++) {\n        for (c2 = 0; c2 <= (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)); c2++) {\n          for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n            for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n              D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\n\nstatic void print_array(int ni,int nl,double G[128 + 0][128 + 0])\n{\n  int i;\n  int j;\n  for (i = 0; i < ni; i++) \n    for (j = 0; j < nl; j++) {\n      fprintf(stderr,\"%0.2lf \",G[i][j]);\n      if ((i * ni + j) % 20 == 0) \n        fprintf(stderr,\"\\n\");\n    }\n  fprintf(stderr,\"\\n\");\n}\n\n\nstatic void kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[128 + 0][128 + 0],double A[128 + 0][128 + 0],double B[128 + 0][128 + 0],double F[128 + 0][128 + 0],double C[128 + 0][128 + 0],double D[128 + 0][128 + 0],double G[128 + 0][128 + 0])\n{\n  \n  \n  \n  \n  \n{\n    int c5;\n    int c10;\n    int c2;\n    int c1;\n    int c6;\n    int c7;\n    if (ni >= 0 && nj >= 0 && nl >= 1) {\n#pragma omp parallel for private(c7, c2, c10)\n      for (c1 = 0; c1 <= (((nj + ni + -1) * 16 < 0?((16 < 0?-((-(nj + ni + -1) + 16 + 1) / 16) : -((-(nj + ni + -1) + 16 - 1) / 16))) : (nj + ni + -1) / 16)); c1++) {\n        for (c2 = 0; c2 <= (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)); c2++) {\n          if (c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16))) {\n            for (c7 = 16 * c2; c7 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c7++) {\n#pragma omp simd\n              for (c10 = 16 * c1; c10 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c10++) {\n                G[c10][c7] = 0;\n              }\n            }\n          }\n          if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))) {\n            for (c7 = 16 * c2; c7 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c7++) {\n#pragma omp simd\n              for (c10 = 16 * c1; c10 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c10++) {\n                F[c10][c7] = 0;\n              }\n            }\n          }\n        }\n      }\n    }\n    if (ni <= -1 && nl >= 1) {\n#pragma omp parallel for private(c7, c2, c10)\n      for (c1 = 0; c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)); c1++) {\n        for (c2 = 0; c2 <= (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)); c2++) {\n          for (c7 = 16 * c2; c7 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c7++) {\n#pragma omp simd\n            for (c10 = 16 * c1; c10 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c10++) {\n              F[c10][c7] = 0;\n            }\n          }\n        }\n      }\n    }\n    if (nj <= -1 && nl >= 1) {\n#pragma omp parallel for private(c7, c2, c10)\n      for (c1 = 0; c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)); c1++) {\n        for (c2 = 0; c2 <= (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)); c2++) {\n          for (c7 = 16 * c2; c7 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c7++) {\n#pragma omp simd\n            for (c10 = 16 * c1; c10 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c10++) {\n              G[c10][c7] = 0;\n            }\n          }\n        }\n      }\n    }\n    if (nl >= 1 && nm >= 1) {\n#pragma omp parallel for private(c7, c6, c2, c10, c5)\n      for (c1 = 0; c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)); c1++) {\n        for (c2 = 0; c2 <= (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)); c2++) {\n          for (c5 = 0; c5 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)); c5++) {\n            for (c6 = 16 * c5; c6 <= ((16 * c5 + 15 < nm + -1?16 * c5 + 15 : nm + -1)); c6++) {\n              for (c7 = 16 * c2; c7 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c7++) {\n#pragma omp simd\n                for (c10 = 16 * c1; c10 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c10++) {\n                  F[c10][c7] += C[c10][c6] * D[c6][c7];\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    if (nj >= 1) {\n#pragma omp parallel for private(c7, c2, c10)\n      for (c1 = 0; c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)); c1++) {\n        for (c2 = 0; c2 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)); c2++) {\n          for (c7 = 16 * c2; c7 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c7++) {\n#pragma omp simd\n            for (c10 = 16 * c1; c10 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c10++) {\n              E[c10][c7] = 0;\n            }\n          }\n        }\n      }\n    }\n    if (nj >= 1) {\n#pragma omp parallel for private(c7, c6, c2, c10, c5)\n      for (c1 = 0; c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)); c1++) {\n        for (c2 = 0; c2 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)); c2++) {\n          for (c5 = 0; c5 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)); c5++) {\n            for (c6 = 16 * c5; c6 <= ((16 * c5 + 15 < nk + -1?16 * c5 + 15 : nk + -1)); c6++) {\n              for (c7 = 16 * c2; c7 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c7++) {\n#pragma omp simd\n                for (c10 = 16 * c1; c10 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c10++) {\n                  E[c10][c7] += A[c10][c6] * B[c6][c7];\n                }\n              }\n            }\n          }\n          for (c5 = 0; c5 <= (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)); c5++) {\n            for (c6 = 16 * c5; c6 <= ((16 * c5 + 15 < nl + -1?16 * c5 + 15 : nl + -1)); c6++) {\n              for (c7 = 16 * c2; c7 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c7++) {\n#pragma omp simd\n                for (c10 = 16 * c1; c10 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c10++) {\n                  G[c10][c6] += E[c10][c7] * F[c7][c6];\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  \n  \n}\n\nint main(int argc,char **argv)\n{\n\n  int ni = 128;\n  int nj = 128;\n  int nk = 128;\n  int nl = 128;\n  int nm = 128;\n\n  double (*E)[128 + 0][128 + 0];\n  E = ((double (*)[128 + 0][128 + 0])(polybench_alloc_data(((128 + 0) * (128 + 0)),(sizeof(double )))));\n  ;\n  double (*A)[128 + 0][128 + 0];\n  A = ((double (*)[128 + 0][128 + 0])(polybench_alloc_data(((128 + 0) * (128 + 0)),(sizeof(double )))));\n  ;\n  double (*B)[128 + 0][128 + 0];\n  B = ((double (*)[128 + 0][128 + 0])(polybench_alloc_data(((128 + 0) * (128 + 0)),(sizeof(double )))));\n  ;\n  double (*F)[128 + 0][128 + 0];\n  F = ((double (*)[128 + 0][128 + 0])(polybench_alloc_data(((128 + 0) * (128 + 0)),(sizeof(double )))));\n  ;\n  double (*C)[128 + 0][128 + 0];\n  C = ((double (*)[128 + 0][128 + 0])(polybench_alloc_data(((128 + 0) * (128 + 0)),(sizeof(double )))));\n  ;\n  double (*D)[128 + 0][128 + 0];\n  D = ((double (*)[128 + 0][128 + 0])(polybench_alloc_data(((128 + 0) * (128 + 0)),(sizeof(double )))));\n  ;\n  double (*G)[128 + 0][128 + 0];\n  G = ((double (*)[128 + 0][128 + 0])(polybench_alloc_data(((128 + 0) * (128 + 0)),(sizeof(double )))));\n  ;\n\n  init_array(ni,nj,nk,nl,nm, *A, *B, *C, *D);\n\n  polybench_timer_start();\n  ;\n\n  kernel_3mm(ni,nj,nk,nl,nm, *E, *A, *B, *F, *C, *D, *G);\n\n  polybench_timer_stop();\n  ;\n  polybench_timer_print();\n  ;\n\n  if (argc > 42 && !strcmp(argv[0],\"\")) \n    print_array(ni,nl, *G);\n\n  free(((void *)E));\n  ;\n  free(((void *)A));\n  ;\n  free(((void *)B));\n  ;\n  free(((void *)F));\n  ;\n  free(((void *)C));\n  ;\n  free(((void *)D));\n  ;\n  free(((void *)G));\n  ;\n  return 0;\n}\n",
        "code_len": 252484,
        "data_race_label": "N2,N4",
        "var_pairs": []
    },
    {
        "ID": "043",
        "name": "DRB043-adi-parallel-no.c",
        "DRB_code": "/**\n * adi.c: This file is part of the PolyBench/C 3.2 test suite.\n *\n * Alternating Direction Implicit solver: \n *\n * Contact: Louis-Noel Pouchet <pouchet@cse.ohio-state.edu>\n * Web address: http://polybench.sourceforge.net\n * License: /LICENSE.OSU.txt\n */\n#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <math.h>\n/* Include polybench common header. */\n#include \"polybench/polybench.h\"\n/* Include benchmark-specific header. */\n/* Default data type is double, default size is 10x1024x1024. */\n#include \"polybench/adi.h\"\n/* Array initialization. */\n\nstatic void init_array(int n,double X[500 + 0][500 + 0],double A[500 + 0][500 + 0],double B[500 + 0][500 + 0])\n{\n  //int i;\n  //int j;\n{\n    int c1;\n    int c2;\n    if (n >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = 0; c1 <= n + -1; c1++) {\n        for (c2 = 0; c2 <= n + -1; c2++) {\n          X[c1][c2] = (((double )c1) * (c2 + 1) + 1) / n;\n          A[c1][c2] = (((double )c1) * (c2 + 2) + 2) / n;\n          B[c1][c2] = (((double )c1) * (c2 + 3) + 3) / n;\n        }\n      }\n    }\n  }\n}\n/* DCE code. Must scan the entire live-out data.\n   Can be used also to check the correctness of the output. */\n\nstatic void print_array(int n,double X[500 + 0][500 + 0])\n{\n  int i;\n  int j;\n  for (i = 0; i < n; i++) \n    for (j = 0; j < n; j++) {\n      fprintf(stderr,\"%0.2lf \",X[i][j]);\n      if ((i * 500 + j) % 20 == 0) \n        fprintf(stderr,\"\\n\");\n    }\n  fprintf(stderr,\"\\n\");\n}\n/* Main computational kernel. The whole function will be timed,\n   including the call and return. */\n\nstatic void kernel_adi(int tsteps,int n,double X[500 + 0][500 + 0],double A[500 + 0][500 + 0],double B[500 + 0][500 + 0])\n{\n  //int t;\n  //int i1;\n  //int i2;\n  \n  //#pragma scop\n{\n    int c0;\n    int c2;\n    int c8;\n    for (c0 = 0; c0 <= 9; c0++) {\n#pragma omp parallel for private(c8)\n      for (c2 = 0; c2 <= 499; c2++) {\n        for (c8 = 1; c8 <= 499; c8++) {\n          B[c2][c8] = B[c2][c8] - A[c2][c8] * A[c2][c8] / B[c2][c8 - 1];\n        }\n        for (c8 = 1; c8 <= 499; c8++) {\n          X[c2][c8] = X[c2][c8] - X[c2][c8 - 1] * A[c2][c8] / B[c2][c8 - 1];\n        }\n        for (c8 = 0; c8 <= 497; c8++) {\n          X[c2][500 - c8 - 2] = (X[c2][500 - 2 - c8] - X[c2][500 - 2 - c8 - 1] * A[c2][500 - c8 - 3]) / B[c2][500 - 3 - c8];\n        }\n      }\n#pragma omp parallel for\n      for (c2 = 0; c2 <= 499; c2++) {\n        X[c2][500 - 1] = X[c2][500 - 1] / B[c2][500 - 1];\n      }\n#pragma omp parallel for private(c8)\n      for (c2 = 0; c2 <= 499; c2++) {\n        for (c8 = 1; c8 <= 499; c8++) {\n          B[c8][c2] = B[c8][c2] - A[c8][c2] * A[c8][c2] / B[c8 - 1][c2];\n        }\n        for (c8 = 1; c8 <= 499; c8++) {\n          X[c8][c2] = X[c8][c2] - X[c8 - 1][c2] * A[c8][c2] / B[c8 - 1][c2];\n        }\n        for (c8 = 0; c8 <= 497; c8++) {\n          X[500 - 2 - c8][c2] = (X[500 - 2 - c8][c2] - X[500 - c8 - 3][c2] * A[500 - 3 - c8][c2]) / B[500 - 2 - c8][c2];\n        }\n      }\n#pragma omp parallel for\n      for (c2 = 0; c2 <= 499; c2++) {\n        X[500 - 1][c2] = X[500 - 1][c2] / B[500 - 1][c2];\n      }\n    }\n  }\n  \n//#pragma endscop\n}\n\nint main(int argc,char **argv)\n{\n/* Retrieve problem size. */\n  int n = 500;\n  int tsteps = 10;\n/* Variable declaration/allocation. */\n  double (*X)[500 + 0][500 + 0];\n  X = ((double (*)[500 + 0][500 + 0])(polybench_alloc_data(((500 + 0) * (500 + 0)),(sizeof(double )))));\n  ;\n  double (*A)[500 + 0][500 + 0];\n  A = ((double (*)[500 + 0][500 + 0])(polybench_alloc_data(((500 + 0) * (500 + 0)),(sizeof(double )))));\n  ;\n  double (*B)[500 + 0][500 + 0];\n  B = ((double (*)[500 + 0][500 + 0])(polybench_alloc_data(((500 + 0) * (500 + 0)),(sizeof(double )))));\n  ;\n/* Initialize array(s). */\n  init_array(n, *X, *A, *B);\n/* Start timer. */\n  polybench_timer_start();\n  ;\n/* Run kernel. */\n  kernel_adi(tsteps,n, *X, *A, *B);\n/* Stop and print timer. */\n  polybench_timer_stop();\n  ;\n  polybench_timer_print();\n  ;\n/* Prevent dead-code elimination. All live-out data must be printed\n     by the function call in argument. */\n  if (argc > 42 && !strcmp(argv[0],\"\")) \n    print_array(n, *X);\n/* Be clean. */\n  free(((void *)X));\n  ;\n  free(((void *)A));\n  ;\n  free(((void *)B));\n  ;\n  return 0;\n}\n",
        "data_race": 0,
        "trimmed_code": "#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <math.h>\n\n#include \"polybench/polybench.h\"\n\n\n#include \"polybench/adi.h\"\n\n\nstatic void init_array(int n,double X[500 + 0][500 + 0],double A[500 + 0][500 + 0],double B[500 + 0][500 + 0])\n{\n  \n  \n{\n    int c1;\n    int c2;\n    if (n >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = 0; c1 <= n + -1; c1++) {\n        for (c2 = 0; c2 <= n + -1; c2++) {\n          X[c1][c2] = (((double )c1) * (c2 + 1) + 1) / n;\n          A[c1][c2] = (((double )c1) * (c2 + 2) + 2) / n;\n          B[c1][c2] = (((double )c1) * (c2 + 3) + 3) / n;\n        }\n      }\n    }\n  }\n}\n\n\nstatic void print_array(int n,double X[500 + 0][500 + 0])\n{\n  int i;\n  int j;\n  for (i = 0; i < n; i++) \n    for (j = 0; j < n; j++) {\n      fprintf(stderr,\"%0.2lf \",X[i][j]);\n      if ((i * 500 + j) % 20 == 0) \n        fprintf(stderr,\"\\n\");\n    }\n  fprintf(stderr,\"\\n\");\n}\n\n\nstatic void kernel_adi(int tsteps,int n,double X[500 + 0][500 + 0],double A[500 + 0][500 + 0],double B[500 + 0][500 + 0])\n{\n  \n  \n  \n  \n  \n{\n    int c0;\n    int c2;\n    int c8;\n    for (c0 = 0; c0 <= 9; c0++) {\n#pragma omp parallel for private(c8)\n      for (c2 = 0; c2 <= 499; c2++) {\n        for (c8 = 1; c8 <= 499; c8++) {\n          B[c2][c8] = B[c2][c8] - A[c2][c8] * A[c2][c8] / B[c2][c8 - 1];\n        }\n        for (c8 = 1; c8 <= 499; c8++) {\n          X[c2][c8] = X[c2][c8] - X[c2][c8 - 1] * A[c2][c8] / B[c2][c8 - 1];\n        }\n        for (c8 = 0; c8 <= 497; c8++) {\n          X[c2][500 - c8 - 2] = (X[c2][500 - 2 - c8] - X[c2][500 - 2 - c8 - 1] * A[c2][500 - c8 - 3]) / B[c2][500 - 3 - c8];\n        }\n      }\n#pragma omp parallel for\n      for (c2 = 0; c2 <= 499; c2++) {\n        X[c2][500 - 1] = X[c2][500 - 1] / B[c2][500 - 1];\n      }\n#pragma omp parallel for private(c8)\n      for (c2 = 0; c2 <= 499; c2++) {\n        for (c8 = 1; c8 <= 499; c8++) {\n          B[c8][c2] = B[c8][c2] - A[c8][c2] * A[c8][c2] / B[c8 - 1][c2];\n        }\n        for (c8 = 1; c8 <= 499; c8++) {\n          X[c8][c2] = X[c8][c2] - X[c8 - 1][c2] * A[c8][c2] / B[c8 - 1][c2];\n        }\n        for (c8 = 0; c8 <= 497; c8++) {\n          X[500 - 2 - c8][c2] = (X[500 - 2 - c8][c2] - X[500 - c8 - 3][c2] * A[500 - 3 - c8][c2]) / B[500 - 2 - c8][c2];\n        }\n      }\n#pragma omp parallel for\n      for (c2 = 0; c2 <= 499; c2++) {\n        X[500 - 1][c2] = X[500 - 1][c2] / B[500 - 1][c2];\n      }\n    }\n  }\n  \n\n}\n\nint main(int argc,char **argv)\n{\n\n  int n = 500;\n  int tsteps = 10;\n\n  double (*X)[500 + 0][500 + 0];\n  X = ((double (*)[500 + 0][500 + 0])(polybench_alloc_data(((500 + 0) * (500 + 0)),(sizeof(double )))));\n  ;\n  double (*A)[500 + 0][500 + 0];\n  A = ((double (*)[500 + 0][500 + 0])(polybench_alloc_data(((500 + 0) * (500 + 0)),(sizeof(double )))));\n  ;\n  double (*B)[500 + 0][500 + 0];\n  B = ((double (*)[500 + 0][500 + 0])(polybench_alloc_data(((500 + 0) * (500 + 0)),(sizeof(double )))));\n  ;\n\n  init_array(n, *X, *A, *B);\n\n  polybench_timer_start();\n  ;\n\n  kernel_adi(tsteps,n, *X, *A, *B);\n\n  polybench_timer_stop();\n  ;\n  polybench_timer_print();\n  ;\n\n  if (argc > 42 && !strcmp(argv[0],\"\")) \n    print_array(n, *X);\n\n  free(((void *)X));\n  ;\n  free(((void *)A));\n  ;\n  free(((void *)B));\n  ;\n  return 0;\n}\n",
        "code_len": 3218,
        "data_race_label": "N2",
        "var_pairs": []
    },
    {
        "ID": "044",
        "name": "DRB044-adi-tile-no.c",
        "DRB_code": "/**\n * adi.c: This file is part of the PolyBench/C 3.2 test suite.\n * Alternating Direction Implicit solver with tiling and nested SIMD.\n *\n * Contact: Louis-Noel Pouchet <pouchet@cse.ohio-state.edu>\n * Web address: http://polybench.sourceforge.net\n * License: /LICENSE.OSU.txt\n */\n#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <math.h>\n/* Include polybench common header. */\n#include \"polybench/polybench.h\"\n/* Include benchmark-specific header. */\n/* Default data type is double, default size is 10x1024x1024. */\n#include \"polybench/adi.h\"\n/* Array initialization. */\n\nstatic void init_array(int n,double X[500 + 0][500 + 0],double A[500 + 0][500 + 0],double B[500 + 0][500 + 0])\n{\n  //int i;\n  //int j;\n{\n    int c1;\n    int c3;\n    int c2;\n    int c4;\n    if (n >= 1) {\n#pragma omp parallel for private(c4, c2, c3)\n      for (c1 = 0; c1 <= (((n + -1) * 16 < 0?((16 < 0?-((-(n + -1) + 16 + 1) / 16) : -((-(n + -1) + 16 - 1) / 16))) : (n + -1) / 16)); c1++) {\n        for (c2 = 0; c2 <= (((n + -1) * 16 < 0?((16 < 0?-((-(n + -1) + 16 + 1) / 16) : -((-(n + -1) + 16 - 1) / 16))) : (n + -1) / 16)); c2++) {\n          for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < n + -1?16 * c1 + 15 : n + -1)); c3++) {\n#pragma omp simd\n            for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < n + -1?16 * c2 + 15 : n + -1)); c4++) {\n              X[c3][c4] = (((double )c3) * (c4 + 1) + 1) / n;\n              A[c3][c4] = (((double )c3) * (c4 + 2) + 2) / n;\n              B[c3][c4] = (((double )c3) * (c4 + 3) + 3) / n;\n            }\n          }\n        }\n      }\n    }\n  }\n}\n/* DCE code. Must scan the entire live-out data.\n   Can be used also to check the correctness of the output. */\n\nstatic void print_array(int n,double X[500 + 0][500 + 0])\n{\n  int i;\n  int j;\n  for (i = 0; i < n; i++) \n    for (j = 0; j < n; j++) {\n      fprintf(stderr,\"%0.2lf \",X[i][j]);\n      if ((i * 500 + j) % 20 == 0) \n        fprintf(stderr,\"\\n\");\n    }\n  fprintf(stderr,\"\\n\");\n}\n/* Main computational kernel. The whole function will be timed,\n   including the call and return. */\n\nstatic void kernel_adi(int tsteps,int n,double X[500 + 0][500 + 0],double A[500 + 0][500 + 0],double B[500 + 0][500 + 0])\n{\n  //int t;\n  //int i1;\n  //int i2;\n  \n  //#pragma scop\n{\n    int c0;\n    int c2;\n    int c8;\n    int c9;\n    int c15;\n    if (n >= 1 && tsteps >= 1) {\n      for (c0 = 0; c0 <= tsteps + -1; c0++) {\n        if (n >= 2) {\n#pragma omp parallel for private(c15, c9, c8)\n          for (c2 = 0; c2 <= (((n + -1) * 16 < 0?((16 < 0?-((-(n + -1) + 16 + 1) / 16) : -((-(n + -1) + 16 - 1) / 16))) : (n + -1) / 16)); c2++) {\n            for (c8 = 0; c8 <= (((n + -1) * 16 < 0?((16 < 0?-((-(n + -1) + 16 + 1) / 16) : -((-(n + -1) + 16 - 1) / 16))) : (n + -1) / 16)); c8++) {\n              for (c9 = (1 > 16 * c8?1 : 16 * c8); c9 <= ((16 * c8 + 15 < n + -1?16 * c8 + 15 : n + -1)); c9++) {\n#pragma omp simd\n                for (c15 = 16 * c2; c15 <= ((16 * c2 + 15 < n + -1?16 * c2 + 15 : n + -1)); c15++) {\n                  B[c15][c9] = B[c15][c9] - A[c15][c9] * A[c15][c9] / B[c15][c9 - 1];\n                }\n              }\n            }\n            for (c8 = 0; c8 <= (((n + -1) * 16 < 0?((16 < 0?-((-(n + -1) + 16 + 1) / 16) : -((-(n + -1) + 16 - 1) / 16))) : (n + -1) / 16)); c8++) {\n              for (c9 = (1 > 16 * c8?1 : 16 * c8); c9 <= ((16 * c8 + 15 < n + -1?16 * c8 + 15 : n + -1)); c9++) {\n#pragma omp simd\n                for (c15 = 16 * c2; c15 <= ((16 * c2 + 15 < n + -1?16 * c2 + 15 : n + -1)); c15++) {\n                  X[c15][c9] = X[c15][c9] - X[c15][c9 - 1] * A[c15][c9] / B[c15][c9 - 1];\n                }\n              }\n            }\n            for (c8 = 0; c8 <= (((n + -3) * 16 < 0?((16 < 0?-((-(n + -3) + 16 + 1) / 16) : -((-(n + -3) + 16 - 1) / 16))) : (n + -3) / 16)); c8++) {\n              for (c9 = 16 * c8; c9 <= ((16 * c8 + 15 < n + -3?16 * c8 + 15 : n + -3)); c9++) {\n#pragma omp simd\n                for (c15 = 16 * c2; c15 <= ((16 * c2 + 15 < n + -1?16 * c2 + 15 : n + -1)); c15++) {\n                  X[c15][n - c9 - 2] = (X[c15][n - 2 - c9] - X[c15][n - 2 - c9 - 1] * A[c15][n - c9 - 3]) / B[c15][n - 3 - c9];\n                }\n              }\n            }\n          }\n        }\n#pragma omp parallel for private(c15)\n        for (c2 = 0; c2 <= (((n + -1) * 16 < 0?((16 < 0?-((-(n + -1) + 16 + 1) / 16) : -((-(n + -1) + 16 - 1) / 16))) : (n + -1) / 16)); c2++) {\n#pragma omp simd\n          for (c15 = 16 * c2; c15 <= ((16 * c2 + 15 < n + -1?16 * c2 + 15 : n + -1)); c15++) {\n            X[c15][n - 1] = X[c15][n - 1] / B[c15][n - 1];\n          }\n        }\n        if (n >= 2) {\n#pragma omp parallel for private(c15, c9, c8)\n          for (c2 = 0; c2 <= (((n + -1) * 16 < 0?((16 < 0?-((-(n + -1) + 16 + 1) / 16) : -((-(n + -1) + 16 - 1) / 16))) : (n + -1) / 16)); c2++) {\n            for (c8 = 0; c8 <= (((n + -1) * 16 < 0?((16 < 0?-((-(n + -1) + 16 + 1) / 16) : -((-(n + -1) + 16 - 1) / 16))) : (n + -1) / 16)); c8++) {\n              for (c9 = (1 > 16 * c8?1 : 16 * c8); c9 <= ((16 * c8 + 15 < n + -1?16 * c8 + 15 : n + -1)); c9++) {\n#pragma omp simd\n                for (c15 = 16 * c2; c15 <= ((16 * c2 + 15 < n + -1?16 * c2 + 15 : n + -1)); c15++) {\n                  B[c9][c15] = B[c9][c15] - A[c9][c15] * A[c9][c15] / B[c9 - 1][c15];\n                }\n              }\n            }\n            for (c8 = 0; c8 <= (((n + -1) * 16 < 0?((16 < 0?-((-(n + -1) + 16 + 1) / 16) : -((-(n + -1) + 16 - 1) / 16))) : (n + -1) / 16)); c8++) {\n              for (c9 = (1 > 16 * c8?1 : 16 * c8); c9 <= ((16 * c8 + 15 < n + -1?16 * c8 + 15 : n + -1)); c9++) {\n#pragma omp simd\n                for (c15 = 16 * c2; c15 <= ((16 * c2 + 15 < n + -1?16 * c2 + 15 : n + -1)); c15++) {\n                  X[c9][c15] = X[c9][c15] - X[c9 - 1][c15] * A[c9][c15] / B[c9 - 1][c15];\n                }\n              }\n            }\n            for (c8 = 0; c8 <= (((n + -3) * 16 < 0?((16 < 0?-((-(n + -3) + 16 + 1) / 16) : -((-(n + -3) + 16 - 1) / 16))) : (n + -3) / 16)); c8++) {\n              for (c9 = 16 * c8; c9 <= ((16 * c8 + 15 < n + -3?16 * c8 + 15 : n + -3)); c9++) {\n#pragma omp simd\n                for (c15 = 16 * c2; c15 <= ((16 * c2 + 15 < n + -1?16 * c2 + 15 : n + -1)); c15++) {\n                  X[n - 2 - c9][c15] = (X[n - 2 - c9][c15] - X[n - c9 - 3][c15] * A[n - 3 - c9][c15]) / B[n - 2 - c9][c15];\n                }\n              }\n            }\n          }\n        }\n#pragma omp parallel for private(c15)\n        for (c2 = 0; c2 <= (((n + -1) * 16 < 0?((16 < 0?-((-(n + -1) + 16 + 1) / 16) : -((-(n + -1) + 16 - 1) / 16))) : (n + -1) / 16)); c2++) {\n#pragma omp simd\n          for (c15 = 16 * c2; c15 <= ((16 * c2 + 15 < n + -1?16 * c2 + 15 : n + -1)); c15++) {\n            X[n - 1][c15] = X[n - 1][c15] / B[n - 1][c15];\n          }\n        }\n      }\n    }\n  }\n  \n//#pragma endscop\n}\n\nint main(int argc,char **argv)\n{\n/* Retrieve problem size. */\n  int n = 500;\n  int tsteps = 10;\n/* Variable declaration/allocation. */\n  double (*X)[500 + 0][500 + 0];\n  X = ((double (*)[500 + 0][500 + 0])(polybench_alloc_data(((500 + 0) * (500 + 0)),(sizeof(double )))));\n  ;\n  double (*A)[500 + 0][500 + 0];\n  A = ((double (*)[500 + 0][500 + 0])(polybench_alloc_data(((500 + 0) * (500 + 0)),(sizeof(double )))));\n  ;\n  double (*B)[500 + 0][500 + 0];\n  B = ((double (*)[500 + 0][500 + 0])(polybench_alloc_data(((500 + 0) * (500 + 0)),(sizeof(double )))));\n  ;\n/* Initialize array(s). */\n  init_array(n, *X, *A, *B);\n/* Start timer. */\n  polybench_timer_start();\n  ;\n/* Run kernel. */\n  kernel_adi(tsteps,n, *X, *A, *B);\n/* Stop and print timer. */\n  polybench_timer_stop();\n  ;\n  polybench_timer_print();\n  ;\n/* Prevent dead-code elimination. All live-out data must be printed\n     by the function call in argument. */\n  if (argc > 42 && !strcmp(argv[0],\"\")) \n    print_array(n, *X);\n/* Be clean. */\n  free(((void *)X));\n  ;\n  free(((void *)A));\n  ;\n  free(((void *)B));\n  ;\n  return 0;\n}\n",
        "data_race": 0,
        "trimmed_code": "#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <math.h>\n\n#include \"polybench/polybench.h\"\n\n\n#include \"polybench/adi.h\"\n\n\nstatic void init_array(int n,double X[500 + 0][500 + 0],double A[500 + 0][500 + 0],double B[500 + 0][500 + 0])\n{\n  \n  \n{\n    int c1;\n    int c3;\n    int c2;\n    int c4;\n    if (n >= 1) {\n#pragma omp parallel for private(c4, c2, c3)\n      for (c1 = 0; c1 <= (((n + -1) * 16 < 0?((16 < 0?-((-(n + -1) + 16 + 1) / 16) : -((-(n + -1) + 16 - 1) / 16))) : (n + -1) / 16)); c1++) {\n        for (c2 = 0; c2 <= (((n + -1) * 16 < 0?((16 < 0?-((-(n + -1) + 16 + 1) / 16) : -((-(n + -1) + 16 - 1) / 16))) : (n + -1) / 16)); c2++) {\n          for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < n + -1?16 * c1 + 15 : n + -1)); c3++) {\n#pragma omp simd\n            for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < n + -1?16 * c2 + 15 : n + -1)); c4++) {\n              X[c3][c4] = (((double )c3) * (c4 + 1) + 1) / n;\n              A[c3][c4] = (((double )c3) * (c4 + 2) + 2) / n;\n              B[c3][c4] = (((double )c3) * (c4 + 3) + 3) / n;\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\n\nstatic void print_array(int n,double X[500 + 0][500 + 0])\n{\n  int i;\n  int j;\n  for (i = 0; i < n; i++) \n    for (j = 0; j < n; j++) {\n      fprintf(stderr,\"%0.2lf \",X[i][j]);\n      if ((i * 500 + j) % 20 == 0) \n        fprintf(stderr,\"\\n\");\n    }\n  fprintf(stderr,\"\\n\");\n}\n\n\nstatic void kernel_adi(int tsteps,int n,double X[500 + 0][500 + 0],double A[500 + 0][500 + 0],double B[500 + 0][500 + 0])\n{\n  \n  \n  \n  \n  \n{\n    int c0;\n    int c2;\n    int c8;\n    int c9;\n    int c15;\n    if (n >= 1 && tsteps >= 1) {\n      for (c0 = 0; c0 <= tsteps + -1; c0++) {\n        if (n >= 2) {\n#pragma omp parallel for private(c15, c9, c8)\n          for (c2 = 0; c2 <= (((n + -1) * 16 < 0?((16 < 0?-((-(n + -1) + 16 + 1) / 16) : -((-(n + -1) + 16 - 1) / 16))) : (n + -1) / 16)); c2++) {\n            for (c8 = 0; c8 <= (((n + -1) * 16 < 0?((16 < 0?-((-(n + -1) + 16 + 1) / 16) : -((-(n + -1) + 16 - 1) / 16))) : (n + -1) / 16)); c8++) {\n              for (c9 = (1 > 16 * c8?1 : 16 * c8); c9 <= ((16 * c8 + 15 < n + -1?16 * c8 + 15 : n + -1)); c9++) {\n#pragma omp simd\n                for (c15 = 16 * c2; c15 <= ((16 * c2 + 15 < n + -1?16 * c2 + 15 : n + -1)); c15++) {\n                  B[c15][c9] = B[c15][c9] - A[c15][c9] * A[c15][c9] / B[c15][c9 - 1];\n                }\n              }\n            }\n            for (c8 = 0; c8 <= (((n + -1) * 16 < 0?((16 < 0?-((-(n + -1) + 16 + 1) / 16) : -((-(n + -1) + 16 - 1) / 16))) : (n + -1) / 16)); c8++) {\n              for (c9 = (1 > 16 * c8?1 : 16 * c8); c9 <= ((16 * c8 + 15 < n + -1?16 * c8 + 15 : n + -1)); c9++) {\n#pragma omp simd\n                for (c15 = 16 * c2; c15 <= ((16 * c2 + 15 < n + -1?16 * c2 + 15 : n + -1)); c15++) {\n                  X[c15][c9] = X[c15][c9] - X[c15][c9 - 1] * A[c15][c9] / B[c15][c9 - 1];\n                }\n              }\n            }\n            for (c8 = 0; c8 <= (((n + -3) * 16 < 0?((16 < 0?-((-(n + -3) + 16 + 1) / 16) : -((-(n + -3) + 16 - 1) / 16))) : (n + -3) / 16)); c8++) {\n              for (c9 = 16 * c8; c9 <= ((16 * c8 + 15 < n + -3?16 * c8 + 15 : n + -3)); c9++) {\n#pragma omp simd\n                for (c15 = 16 * c2; c15 <= ((16 * c2 + 15 < n + -1?16 * c2 + 15 : n + -1)); c15++) {\n                  X[c15][n - c9 - 2] = (X[c15][n - 2 - c9] - X[c15][n - 2 - c9 - 1] * A[c15][n - c9 - 3]) / B[c15][n - 3 - c9];\n                }\n              }\n            }\n          }\n        }\n#pragma omp parallel for private(c15)\n        for (c2 = 0; c2 <= (((n + -1) * 16 < 0?((16 < 0?-((-(n + -1) + 16 + 1) / 16) : -((-(n + -1) + 16 - 1) / 16))) : (n + -1) / 16)); c2++) {\n#pragma omp simd\n          for (c15 = 16 * c2; c15 <= ((16 * c2 + 15 < n + -1?16 * c2 + 15 : n + -1)); c15++) {\n            X[c15][n - 1] = X[c15][n - 1] / B[c15][n - 1];\n          }\n        }\n        if (n >= 2) {\n#pragma omp parallel for private(c15, c9, c8)\n          for (c2 = 0; c2 <= (((n + -1) * 16 < 0?((16 < 0?-((-(n + -1) + 16 + 1) / 16) : -((-(n + -1) + 16 - 1) / 16))) : (n + -1) / 16)); c2++) {\n            for (c8 = 0; c8 <= (((n + -1) * 16 < 0?((16 < 0?-((-(n + -1) + 16 + 1) / 16) : -((-(n + -1) + 16 - 1) / 16))) : (n + -1) / 16)); c8++) {\n              for (c9 = (1 > 16 * c8?1 : 16 * c8); c9 <= ((16 * c8 + 15 < n + -1?16 * c8 + 15 : n + -1)); c9++) {\n#pragma omp simd\n                for (c15 = 16 * c2; c15 <= ((16 * c2 + 15 < n + -1?16 * c2 + 15 : n + -1)); c15++) {\n                  B[c9][c15] = B[c9][c15] - A[c9][c15] * A[c9][c15] / B[c9 - 1][c15];\n                }\n              }\n            }\n            for (c8 = 0; c8 <= (((n + -1) * 16 < 0?((16 < 0?-((-(n + -1) + 16 + 1) / 16) : -((-(n + -1) + 16 - 1) / 16))) : (n + -1) / 16)); c8++) {\n              for (c9 = (1 > 16 * c8?1 : 16 * c8); c9 <= ((16 * c8 + 15 < n + -1?16 * c8 + 15 : n + -1)); c9++) {\n#pragma omp simd\n                for (c15 = 16 * c2; c15 <= ((16 * c2 + 15 < n + -1?16 * c2 + 15 : n + -1)); c15++) {\n                  X[c9][c15] = X[c9][c15] - X[c9 - 1][c15] * A[c9][c15] / B[c9 - 1][c15];\n                }\n              }\n            }\n            for (c8 = 0; c8 <= (((n + -3) * 16 < 0?((16 < 0?-((-(n + -3) + 16 + 1) / 16) : -((-(n + -3) + 16 - 1) / 16))) : (n + -3) / 16)); c8++) {\n              for (c9 = 16 * c8; c9 <= ((16 * c8 + 15 < n + -3?16 * c8 + 15 : n + -3)); c9++) {\n#pragma omp simd\n                for (c15 = 16 * c2; c15 <= ((16 * c2 + 15 < n + -1?16 * c2 + 15 : n + -1)); c15++) {\n                  X[n - 2 - c9][c15] = (X[n - 2 - c9][c15] - X[n - c9 - 3][c15] * A[n - 3 - c9][c15]) / B[n - 2 - c9][c15];\n                }\n              }\n            }\n          }\n        }\n#pragma omp parallel for private(c15)\n        for (c2 = 0; c2 <= (((n + -1) * 16 < 0?((16 < 0?-((-(n + -1) + 16 + 1) / 16) : -((-(n + -1) + 16 - 1) / 16))) : (n + -1) / 16)); c2++) {\n#pragma omp simd\n          for (c15 = 16 * c2; c15 <= ((16 * c2 + 15 < n + -1?16 * c2 + 15 : n + -1)); c15++) {\n            X[n - 1][c15] = X[n - 1][c15] / B[n - 1][c15];\n          }\n        }\n      }\n    }\n  }\n  \n\n}\n\nint main(int argc,char **argv)\n{\n\n  int n = 500;\n  int tsteps = 10;\n\n  double (*X)[500 + 0][500 + 0];\n  X = ((double (*)[500 + 0][500 + 0])(polybench_alloc_data(((500 + 0) * (500 + 0)),(sizeof(double )))));\n  ;\n  double (*A)[500 + 0][500 + 0];\n  A = ((double (*)[500 + 0][500 + 0])(polybench_alloc_data(((500 + 0) * (500 + 0)),(sizeof(double )))));\n  ;\n  double (*B)[500 + 0][500 + 0];\n  B = ((double (*)[500 + 0][500 + 0])(polybench_alloc_data(((500 + 0) * (500 + 0)),(sizeof(double )))));\n  ;\n\n  init_array(n, *X, *A, *B);\n\n  polybench_timer_start();\n  ;\n\n  kernel_adi(tsteps,n, *X, *A, *B);\n\n  polybench_timer_stop();\n  ;\n  polybench_timer_print();\n  ;\n\n  if (argc > 42 && !strcmp(argv[0],\"\")) \n    print_array(n, *X);\n\n  free(((void *)X));\n  ;\n  free(((void *)A));\n  ;\n  free(((void *)B));\n  ;\n  return 0;\n}\n",
        "code_len": 6871,
        "data_race_label": "N2,N4",
        "var_pairs": []
    },
    {
        "ID": "045",
        "name": "DRB045-doall1-orig-no.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/* \nSimplest one dimension array computation\n*/\nint a[100];\nint main()\n{\nint i;\n#pragma omp parallel for\n  for (i=0;i<100;i++)\n    a[i]=a[i]+1;\n  return 0;\n} \n",
        "data_race": 0,
        "trimmed_code": "int a[100];\nint main()\n{\nint i;\n#pragma omp parallel for\n  for (i=0;i<100;i++)\n    a[i]=a[i]+1;\n  return 0;\n} \n",
        "code_len": 111,
        "data_race_label": "N1",
        "var_pairs": []
    },
    {
        "ID": "046",
        "name": "DRB046-doall2-orig-no.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/* \nTwo-dimensional array computation:\nOnly one loop is associated with the omp for construct. \nThe inner loop's loop iteration variable needs an explicit private() clause, \notherwise it will be shared by default. \n*/\n\nint a[100][100];\nint main()\n{\n  int i,j;\n#pragma omp parallel for private(j)\n  for (i=0;i<100;i++)\n    for (j=0;j<100;j++)\n      a[i][j]=a[i][j]+1;\n  return 0;\n}\n\n",
        "data_race": 0,
        "trimmed_code": "int a[100][100];\nint main()\n{\n  int i,j;\n#pragma omp parallel for private(j)\n  for (i=0;i<100;i++)\n    for (j=0;j<100;j++)\n      a[i][j]=a[i][j]+1;\n  return 0;\n}\n\n",
        "code_len": 163,
        "data_race_label": "N1",
        "var_pairs": []
    },
    {
        "ID": "047",
        "name": "DRB047-doallchar-orig-no.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/*\nOne dimension array computation\nwith finer granularity than traditional 4 bytes.\n\nDynamic tools monitoring 4-bytes elements may wrongfully report race condition.\n*/\nchar a[100];\nint main()\n{\n  int i;\n#pragma omp parallel for\n  for (i=0;i<100;i++)\n    a[i]=a[i]+1;\n  return 0;\n} \n",
        "data_race": 0,
        "trimmed_code": "char a[100];\nint main()\n{\n  int i;\n#pragma omp parallel for\n  for (i=0;i<100;i++)\n    a[i]=a[i]+1;\n  return 0;\n} \n",
        "code_len": 114,
        "data_race_label": "N1",
        "var_pairs": []
    },
    {
        "ID": "048",
        "name": "DRB048-firstprivate-orig-no.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\n/*\nExample use of firstprivate()\n*/\nvoid foo(int * a, int n, int g)\n{\n  int i;\n#pragma omp parallel for firstprivate (g)\n  for (i=0;i<n;i++)\n  {\n    a[i] = a[i]+g;\n  }\n}\n\nint a[100];\nint main()\n{\n  foo(a, 100, 7);\n  return 0;\n}  \n",
        "data_race": 0,
        "trimmed_code": "void foo(int * a, int n, int g)\n{\n  int i;\n#pragma omp parallel for firstprivate (g)\n  for (i=0;i<n;i++)\n  {\n    a[i] = a[i]+g;\n  }\n}\n\nint a[100];\nint main()\n{\n  foo(a, 100, 7);\n  return 0;\n}  \n",
        "code_len": 194,
        "data_race_label": "N2",
        "var_pairs": []
    },
    {
        "ID": "049",
        "name": "DRB049-fprintf-orig-no.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/*\n Example use of fprintf\n*/\n#include <stdio.h>\nint main(int argc, char* argv[])\n{\n  int i;\n  int ret;\n  FILE* pfile;\n  int len=1000;\n\n  int A[1000];\n\n  for (i=0; i<len; i++)\n    A[i]=i;\n\n  pfile = fopen(\"mytempfile.txt\",\"a+\");\n  if (pfile ==NULL)\n  {\n    fprintf(stderr,\"Error in fopen()\\n\");\n  }\n\n#pragma omp parallel for\n  for (i=0; i<len; ++i)\n  {\n    fprintf(pfile, \"%d\\n\", A[i] );\n  }\n\n  fclose(pfile);\n  ret = remove(\"mytempfile.txt\");\n  if (ret != 0)\n  {\n    fprintf(stderr, \"Error: unable to delete mytempfile.txt\\n\");\n  }\n  return 0;\n}\n\n",
        "data_race": 0,
        "trimmed_code": "#include <stdio.h>\nint main(int argc, char* argv[])\n{\n  int i;\n  int ret;\n  FILE* pfile;\n  int len=1000;\n\n  int A[1000];\n\n  for (i=0; i<len; i++)\n    A[i]=i;\n\n  pfile = fopen(\"mytempfile.txt\",\"a+\");\n  if (pfile ==NULL)\n  {\n    fprintf(stderr,\"Error in fopen()\\n\");\n  }\n\n#pragma omp parallel for\n  for (i=0; i<len; ++i)\n  {\n    fprintf(pfile, \"%d\\n\", A[i] );\n  }\n\n  fclose(pfile);\n  ret = remove(\"mytempfile.txt\");\n  if (ret != 0)\n  {\n    fprintf(stderr, \"Error: unable to delete mytempfile.txt\\n\");\n  }\n  return 0;\n}\n\n",
        "code_len": 518,
        "data_race_label": "N6",
        "var_pairs": []
    },
    {
        "ID": "050",
        "name": "DRB050-functionparameter-orig-no.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/* \nArrays passed as function parameters\n*/\nvoid foo1(double o1[], double c[], int len)\n{ \n  int i ;\n#pragma omp parallel for\n  for (i = 0; i < len; ++i) {\n    double volnew_o8 = 0.5 * c[i];\n    o1[i] = volnew_o8;\n  } \n}\n\ndouble o1[100];\ndouble c[100];\nint main()\n{\n  foo1 (o1, c, 100);\n  return 0;\n}\n",
        "data_race": 0,
        "trimmed_code": "void foo1(double o1[], double c[], int len)\n{ \n  int i ;\n#pragma omp parallel for\n  for (i = 0; i < len; ++i) {\n    double volnew_o8 = 0.5 * c[i];\n    o1[i] = volnew_o8;\n  } \n}\n\ndouble o1[100];\ndouble c[100];\nint main()\n{\n  foo1 (o1, c, 100);\n  return 0;\n}\n",
        "code_len": 257,
        "data_race_label": "N6",
        "var_pairs": []
    },
    {
        "ID": "051",
        "name": "DRB051-getthreadnum-orig-no.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/*\nomp_get_thread_num() is used to ensure serial semantics.\n*/\n#include <omp.h>\n#include <stdio.h>\n\nint main()\n{\n  int numThreads=0 ; \n#pragma omp parallel\n  {\n    if ( omp_get_thread_num()==0 ) {\n      numThreads = omp_get_num_threads();\n    }\n  }\n  printf (\"numThreads=%d\\n\", numThreads);\n  return 0;\n}\n",
        "data_race": 0,
        "trimmed_code": "#include <omp.h>\n#include <stdio.h>\n\nint main()\n{\n  int numThreads=0 ; \n#pragma omp parallel\n  {\n    if ( omp_get_thread_num()==0 ) {\n      numThreads = omp_get_num_threads();\n    }\n  }\n  printf (\"numThreads=%d\\n\", numThreads);\n  return 0;\n}\n",
        "code_len": 242,
        "data_race_label": "N2",
        "var_pairs": []
    },
    {
        "ID": "052",
        "name": "DRB052-indirectaccesssharebase-orig-no.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/*\nThis example is to mimic a memory access pattern extracted from an LLNL proxy app.\nTwo pointers have distance of 12.\nThey are used as base addresses of two arrays, indexed through an index set.\nThe index set has no two indices with distance of 12.\nSo there is no loop carried dependence.\n*/\n\n#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#define N 180\nint indexSet[N] = {\n521, 523, 525, 527, 529, 531,\n547, 549, 551, 553, 555, 557,\n573, 575, 577, 579, 581, 583,\n599, 601, 603, 605, 607, 609,\n625, 627, 629, 631, 633, 635,\n\n651, 653, 655, 657, 659, 661,\n859, 861, 863, 865, 867, 869,\n885, 887, 889, 891, 893, 895,\n911, 913, 915, 917, 919, 921, \n937, 939, 941, 943, 945, 947,\n\n963, 965, 967, 969, 971, 973,\n989, 991, 993, 995, 997, 999,\n1197, 1199, 1201, 1203, 1205, 1207,\n1223, 1225, 1227, 1229, 1231, 1233,\n1249, 1251, 1253, 1255, 1257, 1259,\n\n1275, 1277, 1279, 1281, 1283, 1285,\n1301, 1303, 1305, 1307, 1309, 1311,\n1327, 1329, 1331, 1333, 1335, 1337,\n1535, 1537, 1539, 1541, 1543, 1545,\n1561, 1563, 1565, 1567, 1569, 1571,\n\n1587, 1589, 1591, 1593, 1595, 1597,\n1613, 1615, 1617, 1619, 1621, 1623,\n1639, 1641, 1643, 1645, 1647, 1649,\n1665, 1667, 1669, 1671, 1673, 1675,\n1873, 1875, 1877, 1879, 1881, 1883,\n\n1899, 1901, 1903, 1905, 1907, 1909,\n1925, 1927, 1929, 1931, 1933, 1935,\n1951, 1953, 1955, 1957, 1959, 1961,\n1977, 1979, 1981, 1983, 1985, 1987,\n2003, 2005, 2007, 2009, 2011, 2013};\n\nint main (int argc, char* argv[])\n{\n  double * base = (double*) malloc(sizeof(double)* (2013+12+1));\n  if (base == 0)\n  {\n    printf(\"Error, malloc() returns NULL. End execution. \\n\");\n    return 1;  \n  }\n\n  double * xa1 = base;\n  double * xa2 = base + 12;\n  int i;\n\n  for (i =521; i<= 2025; ++i)\n  {\n    base[i]=0.0;\n  }\n\n#pragma omp parallel for\n  for (i =0; i< N; ++i) // this level of loop has no loop carried dependence\n  {\n    int idx = indexSet[i];\n    xa1[idx]+= 1.0;\n    xa2[idx]+= 3.0;\n  }\n\n  // verify the results, no overlapping of xa1 vs. xa2, no addition happens to the same element twice\n  for (i =521; i<= 2025; ++i)\n  {\n    //printf (\"%f  \", base[i]);\n    assert (base[i]!=4.0);\n  }\n\n  free (base);\n  return  0;\n}\n\n",
        "data_race": 0,
        "trimmed_code": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#define N 180\nint indexSet[N] = {\n521, 523, 525, 527, 529, 531,\n547, 549, 551, 553, 555, 557,\n573, 575, 577, 579, 581, 583,\n599, 601, 603, 605, 607, 609,\n625, 627, 629, 631, 633, 635,\n\n651, 653, 655, 657, 659, 661,\n859, 861, 863, 865, 867, 869,\n885, 887, 889, 891, 893, 895,\n911, 913, 915, 917, 919, 921, \n937, 939, 941, 943, 945, 947,\n\n963, 965, 967, 969, 971, 973,\n989, 991, 993, 995, 997, 999,\n1197, 1199, 1201, 1203, 1205, 1207,\n1223, 1225, 1227, 1229, 1231, 1233,\n1249, 1251, 1253, 1255, 1257, 1259,\n\n1275, 1277, 1279, 1281, 1283, 1285,\n1301, 1303, 1305, 1307, 1309, 1311,\n1327, 1329, 1331, 1333, 1335, 1337,\n1535, 1537, 1539, 1541, 1543, 1545,\n1561, 1563, 1565, 1567, 1569, 1571,\n\n1587, 1589, 1591, 1593, 1595, 1597,\n1613, 1615, 1617, 1619, 1621, 1623,\n1639, 1641, 1643, 1645, 1647, 1649,\n1665, 1667, 1669, 1671, 1673, 1675,\n1873, 1875, 1877, 1879, 1881, 1883,\n\n1899, 1901, 1903, 1905, 1907, 1909,\n1925, 1927, 1929, 1931, 1933, 1935,\n1951, 1953, 1955, 1957, 1959, 1961,\n1977, 1979, 1981, 1983, 1985, 1987,\n2003, 2005, 2007, 2009, 2011, 2013};\n\nint main (int argc, char* argv[])\n{\n  double * base = (double*) malloc(sizeof(double)* (2013+12+1));\n  if (base == 0)\n  {\n    printf(\"Error, malloc() returns NULL. End execution. \\n\");\n    return 1;  \n  }\n\n  double * xa1 = base;\n  double * xa2 = base + 12;\n  int i;\n\n  for (i =521; i<= 2025; ++i)\n  {\n    base[i]=0.0;\n  }\n\n#pragma omp parallel for\n  for (i =0; i< N; ++i) \n  {\n    int idx = indexSet[i];\n    xa1[idx]+= 1.0;\n    xa2[idx]+= 3.0;\n  }\n\n  \n  for (i =521; i<= 2025; ++i)\n  {\n    \n    assert (base[i]!=4.0);\n  }\n\n  free (base);\n  return  0;\n}\n\n",
        "code_len": 1664,
        "data_race_label": "N7",
        "var_pairs": []
    },
    {
        "ID": "053",
        "name": "DRB053-inneronly1-orig-no.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/*\nExample with loop-carried data dependence at the outer level loop.\nBut the inner level loop can be parallelized.\n*/\n#include <string.h>\nint main(int argc,char *argv[])\n{\n  int i;\n  int j;\n  double a[20][20];\n  memset(a,0,(sizeof(a)));\n\n  for (i = 0; i < 20 -1; i += 1) {\n#pragma omp parallel for\n    for (j = 0; j < 20; j += 1) {\n      a[i][j] += a[i + 1][j];\n    }\n  }\n  return 0;\n}\n",
        "data_race": 0,
        "trimmed_code": "#include <string.h>\nint main(int argc,char *argv[])\n{\n  int i;\n  int j;\n  double a[20][20];\n  memset(a,0,(sizeof(a)));\n\n  for (i = 0; i < 20 -1; i += 1) {\n#pragma omp parallel for\n    for (j = 0; j < 20; j += 1) {\n      a[i][j] += a[i + 1][j];\n    }\n  }\n  return 0;\n}\n",
        "code_len": 268,
        "data_race_label": "N1",
        "var_pairs": []
    },
    {
        "ID": "054",
        "name": "DRB054-inneronly2-orig-no.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/*\nExample with loop-carried data dependence at the outer level loop.\nThe inner level loop can be parallelized.\n*/\nint main()\n{\n  int i,j;\n  int n=100, m=100;\n  double b[n][m];\n\n  for(i=0;i<n; i++) \n    for(j=0;j<n; j++) \n      b[i][j]=(double)(i*j);\n\n  for (i=1;i<n;i++)\n#pragma omp parallel for\n    for (j=1;j<m;j++)\n      b[i][j]=b[i-1][j-1];\n  return 0;\n}\n",
        "data_race": 0,
        "trimmed_code": "int main()\n{\n  int i,j;\n  int n=100, m=100;\n  double b[n][m];\n\n  for(i=0;i<n; i++) \n    for(j=0;j<n; j++) \n      b[i][j]=(double)(i*j);\n\n  for (i=1;i<n;i++)\n#pragma omp parallel for\n    for (j=1;j<m;j++)\n      b[i][j]=b[i-1][j-1];\n  return 0;\n}\n",
        "code_len": 245,
        "data_race_label": "N1",
        "var_pairs": []
    },
    {
        "ID": "055",
        "name": "DRB055-jacobi2d-parallel-no.c",
        "DRB_code": "/**\n * jacobi-2d-imper.c: This file is part of the PolyBench/C 3.2 test suite.\n * Jacobi with array copying, no reduction. \n *\n * Contact: Louis-Noel Pouchet <pouchet@cse.ohio-state.edu>\n * Web address: http://polybench.sourceforge.net\n * License: /LICENSE.OSU.txt\n */\n#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <math.h>\n/* Include polybench common header. */\n#include \"polybench/polybench.h\"\n/* Include benchmark-specific header. */\n/* Default data type is double, default size is 20x1000. */\n#include \"polybench/jacobi-2d-imper.h\"\n/* Array initialization. */\n\nstatic void init_array(int n,double A[500 + 0][500 + 0],double B[500 + 0][500 + 0])\n{\n  //int i;\n  //int j;\n{\n    int c2;\n    int c1;\n    if (n >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = 0; c1 <= n + -1; c1++) {\n        for (c2 = 0; c2 <= n + -1; c2++) {\n          A[c1][c2] = (((double )c1) * (c2 + 2) + 2) / n;\n          B[c1][c2] = (((double )c1) * (c2 + 3) + 3) / n;\n        }\n      }\n    }\n  }\n}\n/* DCE code. Must scan the entire live-out data.\n   Can be used also to check the correctness of the output. */\n\nstatic void print_array(int n,double A[500 + 0][500 + 0])\n{\n  int i;\n  int j;\n  for (i = 0; i < n; i++) \n    for (j = 0; j < n; j++) {\n      fprintf(stderr,\"%0.2lf \",A[i][j]);\n      if ((i * n + j) % 20 == 0) \n        fprintf(stderr,\"\\n\");\n    }\n  fprintf(stderr,\"\\n\");\n}\n/* Main computational kernel. The whole function will be timed,\n   including the call and return. */\n\nstatic void kernel_jacobi_2d_imper(int tsteps,int n,double A[500 + 0][500 + 0],double B[500 + 0][500 + 0])\n{\n  //int t;\n  //int i;\n  //int j;\n  \n  //#pragma scop\n{\n    int c2;\n    int c1;\n    int c0;\n    for (c2 = 1; c2 <= 498; c2++) {\n      B[1][c2] = 0.2 * (A[1][c2] + A[1][c2 - 1] + A[1][1 + c2] + A[1 + 1][c2] + A[1 - 1][c2]);\n    }\n    for (c0 = 2; c0 <= 525; c0++) {\n      if (c0 <= 28) {\n        if ((2 * c0 + 1) % 3 == 0) {\n          for (c2 = ((2 * c0 + 1) * 3 < 0?-(-(2 * c0 + 1) / 3) : ((3 < 0?(-(2 * c0 + 1) + - 3 - 1) / - 3 : (2 * c0 + 1 + 3 - 1) / 3))); c2 <= (((2 * c0 + 1492) * 3 < 0?((3 < 0?-((-(2 * c0 + 1492) + 3 + 1) / 3) : -((-(2 * c0 + 1492) + 3 - 1) / 3))) : (2 * c0 + 1492) / 3)); c2++) {\n            B[1][(-2 * c0 + 3 * c2 + 2) / 3] = 0.2 * (A[1][(-2 * c0 + 3 * c2 + 2) / 3] + A[1][(-2 * c0 + 3 * c2 + 2) / 3 - 1] + A[1][1 + (-2 * c0 + 3 * c2 + 2) / 3] + A[1 + 1][(-2 * c0 + 3 * c2 + 2) / 3] + A[1 - 1][(-2 * c0 + 3 * c2 + 2) / 3]);\n          }\n        }\n      }\n#pragma omp parallel for private(c2)\n      for (c1 = ((((2 * c0 + 2) * 3 < 0?-(-(2 * c0 + 2) / 3) : ((3 < 0?(-(2 * c0 + 2) + - 3 - 1) / - 3 : (2 * c0 + 2 + 3 - 1) / 3)))) > c0 + -9?(((2 * c0 + 2) * 3 < 0?-(-(2 * c0 + 2) / 3) : ((3 < 0?(-(2 * c0 + 2) + - 3 - 1) / - 3 : (2 * c0 + 2 + 3 - 1) / 3)))) : c0 + -9); c1 <= (((((2 * c0 + 498) * 3 < 0?((3 < 0?-((-(2 * c0 + 498) + 3 + 1) / 3) : -((-(2 * c0 + 498) + 3 - 1) / 3))) : (2 * c0 + 498) / 3)) < c0?(((2 * c0 + 498) * 3 < 0?((3 < 0?-((-(2 * c0 + 498) + 3 + 1) / 3) : -((-(2 * c0 + 498) + 3 - 1) / 3))) : (2 * c0 + 498) / 3)) : c0)); c1++) {\n        B[-2 * c0 + 3 * c1][1] = 0.2 * (A[-2 * c0 + 3 * c1][1] + A[-2 * c0 + 3 * c1][1 - 1] + A[-2 * c0 + 3 * c1][1 + 1] + A[1 + (-2 * c0 + 3 * c1)][1] + A[-2 * c0 + 3 * c1 - 1][1]);\n        for (c2 = 2 * c0 + -2 * c1 + 2; c2 <= 2 * c0 + -2 * c1 + 498; c2++) {\n          A[-2 * c0 + 3 * c1 + -1][-2 * c0 + 2 * c1 + c2 + -1] = B[-2 * c0 + 3 * c1 + -1][-2 * c0 + 2 * c1 + c2 + -1];\n          B[-2 * c0 + 3 * c1][-2 * c0 + 2 * c1 + c2] = 0.2 * (A[-2 * c0 + 3 * c1][-2 * c0 + 2 * c1 + c2] + A[-2 * c0 + 3 * c1][-2 * c0 + 2 * c1 + c2 - 1] + A[-2 * c0 + 3 * c1][1 + (-2 * c0 + 2 * c1 + c2)] + A[1 + (-2 * c0 + 3 * c1)][-2 * c0 + 2 * c1 + c2] + A[-2 * c0 + 3 * c1 - 1][-2 * c0 + 2 * c1 + c2]);\n        }\n        A[-2 * c0 + 3 * c1 + -1][498] = B[-2 * c0 + 3 * c1 + -1][498];\n      }\n      if (c0 >= 499) {\n        if ((2 * c0 + 1) % 3 == 0) {\n          for (c2 = ((2 * c0 + -992) * 3 < 0?-(-(2 * c0 + -992) / 3) : ((3 < 0?(-(2 * c0 + -992) + - 3 - 1) / - 3 : (2 * c0 + -992 + 3 - 1) / 3))); c2 <= (((2 * c0 + 499) * 3 < 0?((3 < 0?-((-(2 * c0 + 499) + 3 + 1) / 3) : -((-(2 * c0 + 499) + 3 - 1) / 3))) : (2 * c0 + 499) / 3)); c2++) {\n            A[498][(-2 * c0 + 3 * c2 + 995) / 3] = B[498][(-2 * c0 + 3 * c2 + 995) / 3];\n          }\n        }\n      }\n    }\n    for (c2 = 20; c2 <= 517; c2++) {\n      A[498][c2 + -19] = B[498][c2 + -19];\n    }\n  }\n  \n//#pragma endscop\n}\n\nint main(int argc,char **argv)\n{\n/* Retrieve problem size. */\n  int n = 500;\n  int tsteps = 10;\n/* Variable declaration/allocation. */\n  double (*A)[500 + 0][500 + 0];\n  A = ((double (*)[500 + 0][500 + 0])(polybench_alloc_data(((500 + 0) * (500 + 0)),(sizeof(double )))));\n  ;\n  double (*B)[500 + 0][500 + 0];\n  B = ((double (*)[500 + 0][500 + 0])(polybench_alloc_data(((500 + 0) * (500 + 0)),(sizeof(double )))));\n  ;\n/* Initialize array(s). */\n  init_array(n, *A, *B);\n/* Start timer. */\n  polybench_timer_start();\n  ;\n/* Run kernel. */\n  kernel_jacobi_2d_imper(tsteps,n, *A, *B);\n/* Stop and print timer. */\n  polybench_timer_stop();\n  ;\n  polybench_timer_print();\n  ;\n/* Prevent dead-code elimination. All live-out data must be printed\n     by the function call in argument. */\n  if (argc > 42 && !strcmp(argv[0],\"\")) \n    print_array(n, *A);\n/* Be clean. */\n  free(((void *)A));\n  ;\n  free(((void *)B));\n  ;\n  return 0;\n}\n",
        "data_race": 0,
        "trimmed_code": "#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <math.h>\n\n#include \"polybench/polybench.h\"\n\n\n#include \"polybench/jacobi-2d-imper.h\"\n\n\nstatic void init_array(int n,double A[500 + 0][500 + 0],double B[500 + 0][500 + 0])\n{\n  \n  \n{\n    int c2;\n    int c1;\n    if (n >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = 0; c1 <= n + -1; c1++) {\n        for (c2 = 0; c2 <= n + -1; c2++) {\n          A[c1][c2] = (((double )c1) * (c2 + 2) + 2) / n;\n          B[c1][c2] = (((double )c1) * (c2 + 3) + 3) / n;\n        }\n      }\n    }\n  }\n}\n\n\nstatic void print_array(int n,double A[500 + 0][500 + 0])\n{\n  int i;\n  int j;\n  for (i = 0; i < n; i++) \n    for (j = 0; j < n; j++) {\n      fprintf(stderr,\"%0.2lf \",A[i][j]);\n      if ((i * n + j) % 20 == 0) \n        fprintf(stderr,\"\\n\");\n    }\n  fprintf(stderr,\"\\n\");\n}\n\n\nstatic void kernel_jacobi_2d_imper(int tsteps,int n,double A[500 + 0][500 + 0],double B[500 + 0][500 + 0])\n{\n  \n  \n  \n  \n  \n{\n    int c2;\n    int c1;\n    int c0;\n    for (c2 = 1; c2 <= 498; c2++) {\n      B[1][c2] = 0.2 * (A[1][c2] + A[1][c2 - 1] + A[1][1 + c2] + A[1 + 1][c2] + A[1 - 1][c2]);\n    }\n    for (c0 = 2; c0 <= 525; c0++) {\n      if (c0 <= 28) {\n        if ((2 * c0 + 1) % 3 == 0) {\n          for (c2 = ((2 * c0 + 1) * 3 < 0?-(-(2 * c0 + 1) / 3) : ((3 < 0?(-(2 * c0 + 1) + - 3 - 1) / - 3 : (2 * c0 + 1 + 3 - 1) / 3))); c2 <= (((2 * c0 + 1492) * 3 < 0?((3 < 0?-((-(2 * c0 + 1492) + 3 + 1) / 3) : -((-(2 * c0 + 1492) + 3 - 1) / 3))) : (2 * c0 + 1492) / 3)); c2++) {\n            B[1][(-2 * c0 + 3 * c2 + 2) / 3] = 0.2 * (A[1][(-2 * c0 + 3 * c2 + 2) / 3] + A[1][(-2 * c0 + 3 * c2 + 2) / 3 - 1] + A[1][1 + (-2 * c0 + 3 * c2 + 2) / 3] + A[1 + 1][(-2 * c0 + 3 * c2 + 2) / 3] + A[1 - 1][(-2 * c0 + 3 * c2 + 2) / 3]);\n          }\n        }\n      }\n#pragma omp parallel for private(c2)\n      for (c1 = ((((2 * c0 + 2) * 3 < 0?-(-(2 * c0 + 2) / 3) : ((3 < 0?(-(2 * c0 + 2) + - 3 - 1) / - 3 : (2 * c0 + 2 + 3 - 1) / 3)))) > c0 + -9?(((2 * c0 + 2) * 3 < 0?-(-(2 * c0 + 2) / 3) : ((3 < 0?(-(2 * c0 + 2) + - 3 - 1) / - 3 : (2 * c0 + 2 + 3 - 1) / 3)))) : c0 + -9); c1 <= (((((2 * c0 + 498) * 3 < 0?((3 < 0?-((-(2 * c0 + 498) + 3 + 1) / 3) : -((-(2 * c0 + 498) + 3 - 1) / 3))) : (2 * c0 + 498) / 3)) < c0?(((2 * c0 + 498) * 3 < 0?((3 < 0?-((-(2 * c0 + 498) + 3 + 1) / 3) : -((-(2 * c0 + 498) + 3 - 1) / 3))) : (2 * c0 + 498) / 3)) : c0)); c1++) {\n        B[-2 * c0 + 3 * c1][1] = 0.2 * (A[-2 * c0 + 3 * c1][1] + A[-2 * c0 + 3 * c1][1 - 1] + A[-2 * c0 + 3 * c1][1 + 1] + A[1 + (-2 * c0 + 3 * c1)][1] + A[-2 * c0 + 3 * c1 - 1][1]);\n        for (c2 = 2 * c0 + -2 * c1 + 2; c2 <= 2 * c0 + -2 * c1 + 498; c2++) {\n          A[-2 * c0 + 3 * c1 + -1][-2 * c0 + 2 * c1 + c2 + -1] = B[-2 * c0 + 3 * c1 + -1][-2 * c0 + 2 * c1 + c2 + -1];\n          B[-2 * c0 + 3 * c1][-2 * c0 + 2 * c1 + c2] = 0.2 * (A[-2 * c0 + 3 * c1][-2 * c0 + 2 * c1 + c2] + A[-2 * c0 + 3 * c1][-2 * c0 + 2 * c1 + c2 - 1] + A[-2 * c0 + 3 * c1][1 + (-2 * c0 + 2 * c1 + c2)] + A[1 + (-2 * c0 + 3 * c1)][-2 * c0 + 2 * c1 + c2] + A[-2 * c0 + 3 * c1 - 1][-2 * c0 + 2 * c1 + c2]);\n        }\n        A[-2 * c0 + 3 * c1 + -1][498] = B[-2 * c0 + 3 * c1 + -1][498];\n      }\n      if (c0 >= 499) {\n        if ((2 * c0 + 1) % 3 == 0) {\n          for (c2 = ((2 * c0 + -992) * 3 < 0?-(-(2 * c0 + -992) / 3) : ((3 < 0?(-(2 * c0 + -992) + - 3 - 1) / - 3 : (2 * c0 + -992 + 3 - 1) / 3))); c2 <= (((2 * c0 + 499) * 3 < 0?((3 < 0?-((-(2 * c0 + 499) + 3 + 1) / 3) : -((-(2 * c0 + 499) + 3 - 1) / 3))) : (2 * c0 + 499) / 3)); c2++) {\n            A[498][(-2 * c0 + 3 * c2 + 995) / 3] = B[498][(-2 * c0 + 3 * c2 + 995) / 3];\n          }\n        }\n      }\n    }\n    for (c2 = 20; c2 <= 517; c2++) {\n      A[498][c2 + -19] = B[498][c2 + -19];\n    }\n  }\n  \n\n}\n\nint main(int argc,char **argv)\n{\n\n  int n = 500;\n  int tsteps = 10;\n\n  double (*A)[500 + 0][500 + 0];\n  A = ((double (*)[500 + 0][500 + 0])(polybench_alloc_data(((500 + 0) * (500 + 0)),(sizeof(double )))));\n  ;\n  double (*B)[500 + 0][500 + 0];\n  B = ((double (*)[500 + 0][500 + 0])(polybench_alloc_data(((500 + 0) * (500 + 0)),(sizeof(double )))));\n  ;\n\n  init_array(n, *A, *B);\n\n  polybench_timer_start();\n  ;\n\n  kernel_jacobi_2d_imper(tsteps,n, *A, *B);\n\n  polybench_timer_stop();\n  ;\n  polybench_timer_print();\n  ;\n\n  if (argc > 42 && !strcmp(argv[0],\"\")) \n    print_array(n, *A);\n\n  free(((void *)A));\n  ;\n  free(((void *)B));\n  ;\n  return 0;\n}\n",
        "code_len": 4370,
        "data_race_label": "N7",
        "var_pairs": []
    },
    {
        "ID": "056",
        "name": "DRB056-jacobi2d-tile-no.c",
        "DRB_code": "/**\n * jacobi-2d-imper.c: This file is part of the PolyBench/C 3.2 test suite.\n * Jacobi with array copying, no reduction. with tiling and nested SIMD.\n *\n * Contact: Louis-Noel Pouchet <pouchet@cse.ohio-state.edu>\n * Web address: http://polybench.sourceforge.net\n * License: /LICENSE.OSU.txt\n */\n#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <math.h>\n/* Include polybench common header. */\n#include \"polybench/polybench.h\"\n/* Include benchmark-specific header. */\n/* Default data type is double, default size is 20x1000. */\n#include \"polybench/jacobi-2d-imper.h\"\n/* Array initialization. */\n\nstatic void init_array(int n,double A[500 + 0][500 + 0],double B[500 + 0][500 + 0])\n{\n  //int i;\n  //int j;\n{\n    int c1;\n    int c2;\n    int c4;\n    int c3;\n    if (n >= 1) {\n#pragma omp parallel for private(c3, c4, c2)\n      for (c1 = 0; c1 <= (((n + -1) * 16 < 0?((16 < 0?-((-(n + -1) + 16 + 1) / 16) : -((-(n + -1) + 16 - 1) / 16))) : (n + -1) / 16)); c1++) {\n        for (c2 = 0; c2 <= (((n + -1) * 16 < 0?((16 < 0?-((-(n + -1) + 16 + 1) / 16) : -((-(n + -1) + 16 - 1) / 16))) : (n + -1) / 16)); c2++) {\n          for (c3 = 16 * c2; c3 <= ((16 * c2 + 15 < n + -1?16 * c2 + 15 : n + -1)); c3++) {\n#pragma omp simd\n            for (c4 = 16 * c1; c4 <= ((16 * c1 + 15 < n + -1?16 * c1 + 15 : n + -1)); c4++) {\n              A[c4][c3] = (((double )c4) * (c3 + 2) + 2) / n;\n              B[c4][c3] = (((double )c4) * (c3 + 3) + 3) / n;\n            }\n          }\n        }\n      }\n    }\n  }\n}\n/* DCE code. Must scan the entire live-out data.\n   Can be used also to check the correctness of the output. */\n\nstatic void print_array(int n,double A[500 + 0][500 + 0])\n{\n  int i;\n  int j;\n  for (i = 0; i < n; i++) \n    for (j = 0; j < n; j++) {\n      fprintf(stderr,\"%0.2lf \",A[i][j]);\n      if ((i * n + j) % 20 == 0) \n        fprintf(stderr,\"\\n\");\n    }\n  fprintf(stderr,\"\\n\");\n}\n/* Main computational kernel. The whole function will be timed,\n   including the call and return. */\n\nstatic void kernel_jacobi_2d_imper(int tsteps,int n,double A[500 + 0][500 + 0],double B[500 + 0][500 + 0])\n{\n  //int t;\n  //int i;\n  //int j;\n  \n  //#pragma scop\n{\n    int c0;\n    int c1;\n    int c3;\n    int c2;\n    int c4;\n    int c5;\n    if (n >= 3 && tsteps >= 1) {\n      for (c0 = 0; c0 <= (((n + 3 * tsteps + -4) * 16 < 0?((16 < 0?-((-(n + 3 * tsteps + -4) + 16 + 1) / 16) : -((-(n + 3 * tsteps + -4) + 16 - 1) / 16))) : (n + 3 * tsteps + -4) / 16)); c0++) {\n#pragma omp parallel for private(c5, c4, c2, c3)\n        for (c1 = (((2 * c0 * 3 < 0?-(-(2 * c0) / 3) : ((3 < 0?(-(2 * c0) + - 3 - 1) / - 3 : (2 * c0 + 3 - 1) / 3)))) > (((16 * c0 + -1 * tsteps + 1) * 16 < 0?-(-(16 * c0 + -1 * tsteps + 1) / 16) : ((16 < 0?(-(16 * c0 + -1 * tsteps + 1) + - 16 - 1) / - 16 : (16 * c0 + -1 * tsteps + 1 + 16 - 1) / 16))))?((2 * c0 * 3 < 0?-(-(2 * c0) / 3) : ((3 < 0?(-(2 * c0) + - 3 - 1) / - 3 : (2 * c0 + 3 - 1) / 3)))) : (((16 * c0 + -1 * tsteps + 1) * 16 < 0?-(-(16 * c0 + -1 * tsteps + 1) / 16) : ((16 < 0?(-(16 * c0 + -1 * tsteps + 1) + - 16 - 1) / - 16 : (16 * c0 + -1 * tsteps + 1 + 16 - 1) / 16))))); c1 <= (((((((n + 2 * tsteps + -3) * 16 < 0?((16 < 0?-((-(n + 2 * tsteps + -3) + 16 + 1) / 16) : -((-(n + 2 * tsteps + -3) + 16 - 1) / 16))) : (n + 2 * tsteps + -3) / 16)) < (((32 * c0 + n + 29) * 48 < 0?((48 < 0?-((-(32 * c0 + n + 29) + 48 + 1) / 48) : -((-(32 * c0 + n + 29) + 48 - 1) / 48))) : (32 * c0 + n + 29) / 48))?(((n + 2 * tsteps + -3) * 16 < 0?((16 < 0?-((-(n + 2 * tsteps + -3) + 16 + 1) / 16) : -((-(n + 2 * tsteps + -3) + 16 - 1) / 16))) : (n + 2 * tsteps + -3) / 16)) : (((32 * c0 + n + 29) * 48 < 0?((48 < 0?-((-(32 * c0 + n + 29) + 48 + 1) / 48) : -((-(32 * c0 + n + 29) + 48 - 1) / 48))) : (32 * c0 + n + 29) / 48)))) < c0?(((((n + 2 * tsteps + -3) * 16 < 0?((16 < 0?-((-(n + 2 * tsteps + -3) + 16 + 1) / 16) : -((-(n + 2 * tsteps + -3) + 16 - 1) / 16))) : (n + 2 * tsteps + -3) / 16)) < (((32 * c0 + n + 29) * 48 < 0?((48 < 0?-((-(32 * c0 + n + 29) + 48 + 1) / 48) : -((-(32 * c0 + n + 29) + 48 - 1) / 48))) : (32 * c0 + n + 29) / 48))?(((n + 2 * tsteps + -3) * 16 < 0?((16 < 0?-((-(n + 2 * tsteps + -3) + 16 + 1) / 16) : -((-(n + 2 * tsteps + -3) + 16 - 1) / 16))) : (n + 2 * tsteps + -3) / 16)) : (((32 * c0 + n + 29) * 48 < 0?((48 < 0?-((-(32 * c0 + n + 29) + 48 + 1) / 48) : -((-(32 * c0 + n + 29) + 48 - 1) / 48))) : (32 * c0 + n + 29) / 48)))) : c0)); c1++) {\n          for (c2 = ((((16 * c1 + -1 * n + -12) * 16 < 0?-(-(16 * c1 + -1 * n + -12) / 16) : ((16 < 0?(-(16 * c1 + -1 * n + -12) + - 16 - 1) / - 16 : (16 * c1 + -1 * n + -12 + 16 - 1) / 16)))) > 2 * c0 + -2 * c1?(((16 * c1 + -1 * n + -12) * 16 < 0?-(-(16 * c1 + -1 * n + -12) / 16) : ((16 < 0?(-(16 * c1 + -1 * n + -12) + - 16 - 1) / - 16 : (16 * c1 + -1 * n + -12 + 16 - 1) / 16)))) : 2 * c0 + -2 * c1); c2 <= (((((((16 * c1 + n + 12) * 16 < 0?((16 < 0?-((-(16 * c1 + n + 12) + 16 + 1) / 16) : -((-(16 * c1 + n + 12) + 16 - 1) / 16))) : (16 * c1 + n + 12) / 16)) < (((n + 2 * tsteps + -3) * 16 < 0?((16 < 0?-((-(n + 2 * tsteps + -3) + 16 + 1) / 16) : -((-(n + 2 * tsteps + -3) + 16 - 1) / 16))) : (n + 2 * tsteps + -3) / 16))?(((16 * c1 + n + 12) * 16 < 0?((16 < 0?-((-(16 * c1 + n + 12) + 16 + 1) / 16) : -((-(16 * c1 + n + 12) + 16 - 1) / 16))) : (16 * c1 + n + 12) / 16)) : (((n + 2 * tsteps + -3) * 16 < 0?((16 < 0?-((-(n + 2 * tsteps + -3) + 16 + 1) / 16) : -((-(n + 2 * tsteps + -3) + 16 - 1) / 16))) : (n + 2 * tsteps + -3) / 16)))) < (((32 * c0 + -32 * c1 + n + 29) * 16 < 0?((16 < 0?-((-(32 * c0 + -32 * c1 + n + 29) + 16 + 1) / 16) : -((-(32 * c0 + -32 * c1 + n + 29) + 16 - 1) / 16))) : (32 * c0 + -32 * c1 + n + 29) / 16))?(((((16 * c1 + n + 12) * 16 < 0?((16 < 0?-((-(16 * c1 + n + 12) + 16 + 1) / 16) : -((-(16 * c1 + n + 12) + 16 - 1) / 16))) : (16 * c1 + n + 12) / 16)) < (((n + 2 * tsteps + -3) * 16 < 0?((16 < 0?-((-(n + 2 * tsteps + -3) + 16 + 1) / 16) : -((-(n + 2 * tsteps + -3) + 16 - 1) / 16))) : (n + 2 * tsteps + -3) / 16))?(((16 * c1 + n + 12) * 16 < 0?((16 < 0?-((-(16 * c1 + n + 12) + 16 + 1) / 16) : -((-(16 * c1 + n + 12) + 16 - 1) / 16))) : (16 * c1 + n + 12) / 16)) : (((n + 2 * tsteps + -3) * 16 < 0?((16 < 0?-((-(n + 2 * tsteps + -3) + 16 + 1) / 16) : -((-(n + 2 * tsteps + -3) + 16 - 1) / 16))) : (n + 2 * tsteps + -3) / 16)))) : (((32 * c0 + -32 * c1 + n + 29) * 16 < 0?((16 < 0?-((-(32 * c0 + -32 * c1 + n + 29) + 16 + 1) / 16) : -((-(32 * c0 + -32 * c1 + n + 29) + 16 - 1) / 16))) : (32 * c0 + -32 * c1 + n + 29) / 16)))); c2++) {\n            if (c0 <= (((32 * c1 + 16 * c2 + -1 * n + 1) * 32 < 0?((32 < 0?-((-(32 * c1 + 16 * c2 + -1 * n + 1) + 32 + 1) / 32) : -((-(32 * c1 + 16 * c2 + -1 * n + 1) + 32 - 1) / 32))) : (32 * c1 + 16 * c2 + -1 * n + 1) / 32)) && c1 <= c2 + -1) {\n              if ((n + 1) % 2 == 0) {\n                for (c4 = (16 * c1 > 16 * c2 + -1 * n + 3?16 * c1 : 16 * c2 + -1 * n + 3); c4 <= 16 * c1 + 15; c4++) {\n                  A[-16 * c2 + c4 + n + -2][n + -2] = B[-16 * c2 + c4 + n + -2][n + -2];\n                }\n              }\n            }\n            if (c0 <= (((48 * c1 + -1 * n + 1) * 32 < 0?((32 < 0?-((-(48 * c1 + -1 * n + 1) + 32 + 1) / 32) : -((-(48 * c1 + -1 * n + 1) + 32 - 1) / 32))) : (48 * c1 + -1 * n + 1) / 32)) && c1 >= c2) {\n              if ((n + 1) % 2 == 0) {\n                for (c5 = (16 * c2 > 16 * c1 + -1 * n + 3?16 * c2 : 16 * c1 + -1 * n + 3); c5 <= ((16 * c1 < 16 * c2 + 15?16 * c1 : 16 * c2 + 15)); c5++) {\n                  A[n + -2][-16 * c1 + c5 + n + -2] = B[n + -2][-16 * c1 + c5 + n + -2];\n                }\n              }\n            }\n            for (c3 = ((((((16 * c1 + -1 * n + 2) * 2 < 0?-(-(16 * c1 + -1 * n + 2) / 2) : ((2 < 0?(-(16 * c1 + -1 * n + 2) + - 2 - 1) / - 2 : (16 * c1 + -1 * n + 2 + 2 - 1) / 2)))) > (((16 * c2 + -1 * n + 2) * 2 < 0?-(-(16 * c2 + -1 * n + 2) / 2) : ((2 < 0?(-(16 * c2 + -1 * n + 2) + - 2 - 1) / - 2 : (16 * c2 + -1 * n + 2 + 2 - 1) / 2))))?(((16 * c1 + -1 * n + 2) * 2 < 0?-(-(16 * c1 + -1 * n + 2) / 2) : ((2 < 0?(-(16 * c1 + -1 * n + 2) + - 2 - 1) / - 2 : (16 * c1 + -1 * n + 2 + 2 - 1) / 2)))) : (((16 * c2 + -1 * n + 2) * 2 < 0?-(-(16 * c2 + -1 * n + 2) / 2) : ((2 < 0?(-(16 * c2 + -1 * n + 2) + - 2 - 1) / - 2 : (16 * c2 + -1 * n + 2 + 2 - 1) / 2)))))) > 16 * c0 + -16 * c1?(((((16 * c1 + -1 * n + 2) * 2 < 0?-(-(16 * c1 + -1 * n + 2) / 2) : ((2 < 0?(-(16 * c1 + -1 * n + 2) + - 2 - 1) / - 2 : (16 * c1 + -1 * n + 2 + 2 - 1) / 2)))) > (((16 * c2 + -1 * n + 2) * 2 < 0?-(-(16 * c2 + -1 * n + 2) / 2) : ((2 < 0?(-(16 * c2 + -1 * n + 2) + - 2 - 1) / - 2 : (16 * c2 + -1 * n + 2 + 2 - 1) / 2))))?(((16 * c1 + -1 * n + 2) * 2 < 0?-(-(16 * c1 + -1 * n + 2) / 2) : ((2 < 0?(-(16 * c1 + -1 * n + 2) + - 2 - 1) / - 2 : (16 * c1 + -1 * n + 2 + 2 - 1) / 2)))) : (((16 * c2 + -1 * n + 2) * 2 < 0?-(-(16 * c2 + -1 * n + 2) / 2) : ((2 < 0?(-(16 * c2 + -1 * n + 2) + - 2 - 1) / - 2 : (16 * c2 + -1 * n + 2 + 2 - 1) / 2)))))) : 16 * c0 + -16 * c1); c3 <= ((((((8 * c1 + 6 < 8 * c2 + 6?8 * c1 + 6 : 8 * c2 + 6)) < tsteps + -1?((8 * c1 + 6 < 8 * c2 + 6?8 * c1 + 6 : 8 * c2 + 6)) : tsteps + -1)) < 16 * c0 + -16 * c1 + 15?((((8 * c1 + 6 < 8 * c2 + 6?8 * c1 + 6 : 8 * c2 + 6)) < tsteps + -1?((8 * c1 + 6 < 8 * c2 + 6?8 * c1 + 6 : 8 * c2 + 6)) : tsteps + -1)) : 16 * c0 + -16 * c1 + 15)); c3++) {\n              if (c1 <= ((c3 * 8 < 0?((8 < 0?-((-c3 + 8 + 1) / 8) : -((-c3 + 8 - 1) / 8))) : c3 / 8))) {\n                for (c5 = (16 * c2 > 2 * c3 + 1?16 * c2 : 2 * c3 + 1); c5 <= ((16 * c2 + 15 < 2 * c3 + n + -2?16 * c2 + 15 : 2 * c3 + n + -2)); c5++) {\n                  B[1][-2 * c3 + c5] = 0.2 * (A[1][-2 * c3 + c5] + A[1][-2 * c3 + c5 - 1] + A[1][1 + (-2 * c3 + c5)] + A[1 + 1][-2 * c3 + c5] + A[1 - 1][-2 * c3 + c5]);\n                }\n              }\n              for (c4 = (16 * c1 > 2 * c3 + 2?16 * c1 : 2 * c3 + 2); c4 <= ((16 * c1 + 15 < 2 * c3 + n + -2?16 * c1 + 15 : 2 * c3 + n + -2)); c4++) {\n                if (c2 <= ((c3 * 8 < 0?((8 < 0?-((-c3 + 8 + 1) / 8) : -((-c3 + 8 - 1) / 8))) : c3 / 8))) {\n                  B[-2 * c3 + c4][1] = 0.2 * (A[-2 * c3 + c4][1] + A[-2 * c3 + c4][1 - 1] + A[-2 * c3 + c4][1 + 1] + A[1 + (-2 * c3 + c4)][1] + A[-2 * c3 + c4 - 1][1]);\n                }\n                for (c5 = (16 * c2 > 2 * c3 + 2?16 * c2 : 2 * c3 + 2); c5 <= ((16 * c2 + 15 < 2 * c3 + n + -2?16 * c2 + 15 : 2 * c3 + n + -2)); c5++) {\n                  B[-2 * c3 + c4][-2 * c3 + c5] = 0.2 * (A[-2 * c3 + c4][-2 * c3 + c5] + A[-2 * c3 + c4][-2 * c3 + c5 - 1] + A[-2 * c3 + c4][1 + (-2 * c3 + c5)] + A[1 + (-2 * c3 + c4)][-2 * c3 + c5] + A[-2 * c3 + c4 - 1][-2 * c3 + c5]);\n                  A[-2 * c3 + c4 + -1][-2 * c3 + c5 + -1] = B[-2 * c3 + c4 + -1][-2 * c3 + c5 + -1];\n                }\n                if (c2 >= (((2 * c3 + n + -16) * 16 < 0?-(-(2 * c3 + n + -16) / 16) : ((16 < 0?(-(2 * c3 + n + -16) + - 16 - 1) / - 16 : (2 * c3 + n + -16 + 16 - 1) / 16))))) {\n                  A[-2 * c3 + c4 + -1][n + -2] = B[-2 * c3 + c4 + -1][n + -2];\n                }\n              }\n              if (c1 >= (((2 * c3 + n + -16) * 16 < 0?-(-(2 * c3 + n + -16) / 16) : ((16 < 0?(-(2 * c3 + n + -16) + - 16 - 1) / - 16 : (2 * c3 + n + -16 + 16 - 1) / 16))))) {\n                for (c5 = (16 * c2 > 2 * c3 + 2?16 * c2 : 2 * c3 + 2); c5 <= ((16 * c2 + 15 < 2 * c3 + n + -1?16 * c2 + 15 : 2 * c3 + n + -1)); c5++) {\n                  A[n + -2][-2 * c3 + c5 + -1] = B[n + -2][-2 * c3 + c5 + -1];\n                }\n              }\n            }\n            if (c0 >= (((2 * c1 + c2 + -1) * 2 < 0?-(-(2 * c1 + c2 + -1) / 2) : ((2 < 0?(-(2 * c1 + c2 + -1) + - 2 - 1) / - 2 : (2 * c1 + c2 + -1 + 2 - 1) / 2)))) && c1 >= c2 + 1 && c2 <= (((tsteps + -8) * 8 < 0?((8 < 0?-((-(tsteps + -8) + 8 + 1) / 8) : -((-(tsteps + -8) + 8 - 1) / 8))) : (tsteps + -8) / 8))) {\n              for (c4 = 16 * c1; c4 <= ((16 * c1 + 15 < 16 * c2 + n + 12?16 * c1 + 15 : 16 * c2 + n + 12)); c4++) {\n                B[-16 * c2 + c4 + -14][1] = 0.2 * (A[-16 * c2 + c4 + -14][1] + A[-16 * c2 + c4 + -14][1 - 1] + A[-16 * c2 + c4 + -14][1 + 1] + A[1 + (-16 * c2 + c4 + -14)][1] + A[-16 * c2 + c4 + -14 - 1][1]);\n              }\n            }\n            if (c0 >= (((3 * c1 + -1) * 2 < 0?-(-(3 * c1 + -1) / 2) : ((2 < 0?(-(3 * c1 + -1) + - 2 - 1) / - 2 : (3 * c1 + -1 + 2 - 1) / 2)))) && c1 <= (((((tsteps + -8) * 8 < 0?((8 < 0?-((-(tsteps + -8) + 8 + 1) / 8) : -((-(tsteps + -8) + 8 - 1) / 8))) : (tsteps + -8) / 8)) < c2?(((tsteps + -8) * 8 < 0?((8 < 0?-((-(tsteps + -8) + 8 + 1) / 8) : -((-(tsteps + -8) + 8 - 1) / 8))) : (tsteps + -8) / 8)) : c2))) {\n              for (c5 = (16 * c2 > 16 * c1 + 15?16 * c2 : 16 * c1 + 15); c5 <= ((16 * c2 + 15 < 16 * c1 + n + 12?16 * c2 + 15 : 16 * c1 + n + 12)); c5++) {\n                B[1][-16 * c1 + c5 + -14] = 0.2 * (A[1][-16 * c1 + c5 + -14] + A[1][-16 * c1 + c5 + -14 - 1] + A[1][1 + (-16 * c1 + c5 + -14)] + A[1 + 1][-16 * c1 + c5 + -14] + A[1 - 1][-16 * c1 + c5 + -14]);\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  \n//#pragma endscop\n}\n\nint main(int argc,char **argv)\n{\n/* Retrieve problem size. */\n  int n = 500;\n  int tsteps = 10;\n/* Variable declaration/allocation. */\n  double (*A)[500 + 0][500 + 0];\n  A = ((double (*)[500 + 0][500 + 0])(polybench_alloc_data(((500 + 0) * (500 + 0)),(sizeof(double )))));\n  ;\n  double (*B)[500 + 0][500 + 0];\n  B = ((double (*)[500 + 0][500 + 0])(polybench_alloc_data(((500 + 0) * (500 + 0)),(sizeof(double )))));\n  ;\n/* Initialize array(s). */\n  init_array(n, *A, *B);\n/* Start timer. */\n  polybench_timer_start();\n  ;\n/* Run kernel. */\n  kernel_jacobi_2d_imper(tsteps,n, *A, *B);\n/* Stop and print timer. */\n  polybench_timer_stop();\n  ;\n  polybench_timer_print();\n  ;\n/* Prevent dead-code elimination. All live-out data must be printed\n     by the function call in argument. */\n  if (argc > 42 && !strcmp(argv[0],\"\")) \n    print_array(n, *A);\n/* Be clean. */\n  free(((void *)A));\n  ;\n  free(((void *)B));\n  ;\n  return 0;\n}\n",
        "data_race": 0,
        "trimmed_code": "#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <math.h>\n\n#include \"polybench/polybench.h\"\n\n\n#include \"polybench/jacobi-2d-imper.h\"\n\n\nstatic void init_array(int n,double A[500 + 0][500 + 0],double B[500 + 0][500 + 0])\n{\n  \n  \n{\n    int c1;\n    int c2;\n    int c4;\n    int c3;\n    if (n >= 1) {\n#pragma omp parallel for private(c3, c4, c2)\n      for (c1 = 0; c1 <= (((n + -1) * 16 < 0?((16 < 0?-((-(n + -1) + 16 + 1) / 16) : -((-(n + -1) + 16 - 1) / 16))) : (n + -1) / 16)); c1++) {\n        for (c2 = 0; c2 <= (((n + -1) * 16 < 0?((16 < 0?-((-(n + -1) + 16 + 1) / 16) : -((-(n + -1) + 16 - 1) / 16))) : (n + -1) / 16)); c2++) {\n          for (c3 = 16 * c2; c3 <= ((16 * c2 + 15 < n + -1?16 * c2 + 15 : n + -1)); c3++) {\n#pragma omp simd\n            for (c4 = 16 * c1; c4 <= ((16 * c1 + 15 < n + -1?16 * c1 + 15 : n + -1)); c4++) {\n              A[c4][c3] = (((double )c4) * (c3 + 2) + 2) / n;\n              B[c4][c3] = (((double )c4) * (c3 + 3) + 3) / n;\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\n\nstatic void print_array(int n,double A[500 + 0][500 + 0])\n{\n  int i;\n  int j;\n  for (i = 0; i < n; i++) \n    for (j = 0; j < n; j++) {\n      fprintf(stderr,\"%0.2lf \",A[i][j]);\n      if ((i * n + j) % 20 == 0) \n        fprintf(stderr,\"\\n\");\n    }\n  fprintf(stderr,\"\\n\");\n}\n\n\nstatic void kernel_jacobi_2d_imper(int tsteps,int n,double A[500 + 0][500 + 0],double B[500 + 0][500 + 0])\n{\n  \n  \n  \n  \n  \n{\n    int c0;\n    int c1;\n    int c3;\n    int c2;\n    int c4;\n    int c5;\n    if (n >= 3 && tsteps >= 1) {\n      for (c0 = 0; c0 <= (((n + 3 * tsteps + -4) * 16 < 0?((16 < 0?-((-(n + 3 * tsteps + -4) + 16 + 1) / 16) : -((-(n + 3 * tsteps + -4) + 16 - 1) / 16))) : (n + 3 * tsteps + -4) / 16)); c0++) {\n#pragma omp parallel for private(c5, c4, c2, c3)\n        for (c1 = (((2 * c0 * 3 < 0?-(-(2 * c0) / 3) : ((3 < 0?(-(2 * c0) + - 3 - 1) / - 3 : (2 * c0 + 3 - 1) / 3)))) > (((16 * c0 + -1 * tsteps + 1) * 16 < 0?-(-(16 * c0 + -1 * tsteps + 1) / 16) : ((16 < 0?(-(16 * c0 + -1 * tsteps + 1) + - 16 - 1) / - 16 : (16 * c0 + -1 * tsteps + 1 + 16 - 1) / 16))))?((2 * c0 * 3 < 0?-(-(2 * c0) / 3) : ((3 < 0?(-(2 * c0) + - 3 - 1) / - 3 : (2 * c0 + 3 - 1) / 3)))) : (((16 * c0 + -1 * tsteps + 1) * 16 < 0?-(-(16 * c0 + -1 * tsteps + 1) / 16) : ((16 < 0?(-(16 * c0 + -1 * tsteps + 1) + - 16 - 1) / - 16 : (16 * c0 + -1 * tsteps + 1 + 16 - 1) / 16))))); c1 <= (((((((n + 2 * tsteps + -3) * 16 < 0?((16 < 0?-((-(n + 2 * tsteps + -3) + 16 + 1) / 16) : -((-(n + 2 * tsteps + -3) + 16 - 1) / 16))) : (n + 2 * tsteps + -3) / 16)) < (((32 * c0 + n + 29) * 48 < 0?((48 < 0?-((-(32 * c0 + n + 29) + 48 + 1) / 48) : -((-(32 * c0 + n + 29) + 48 - 1) / 48))) : (32 * c0 + n + 29) / 48))?(((n + 2 * tsteps + -3) * 16 < 0?((16 < 0?-((-(n + 2 * tsteps + -3) + 16 + 1) / 16) : -((-(n + 2 * tsteps + -3) + 16 - 1) / 16))) : (n + 2 * tsteps + -3) / 16)) : (((32 * c0 + n + 29) * 48 < 0?((48 < 0?-((-(32 * c0 + n + 29) + 48 + 1) / 48) : -((-(32 * c0 + n + 29) + 48 - 1) / 48))) : (32 * c0 + n + 29) / 48)))) < c0?(((((n + 2 * tsteps + -3) * 16 < 0?((16 < 0?-((-(n + 2 * tsteps + -3) + 16 + 1) / 16) : -((-(n + 2 * tsteps + -3) + 16 - 1) / 16))) : (n + 2 * tsteps + -3) / 16)) < (((32 * c0 + n + 29) * 48 < 0?((48 < 0?-((-(32 * c0 + n + 29) + 48 + 1) / 48) : -((-(32 * c0 + n + 29) + 48 - 1) / 48))) : (32 * c0 + n + 29) / 48))?(((n + 2 * tsteps + -3) * 16 < 0?((16 < 0?-((-(n + 2 * tsteps + -3) + 16 + 1) / 16) : -((-(n + 2 * tsteps + -3) + 16 - 1) / 16))) : (n + 2 * tsteps + -3) / 16)) : (((32 * c0 + n + 29) * 48 < 0?((48 < 0?-((-(32 * c0 + n + 29) + 48 + 1) / 48) : -((-(32 * c0 + n + 29) + 48 - 1) / 48))) : (32 * c0 + n + 29) / 48)))) : c0)); c1++) {\n          for (c2 = ((((16 * c1 + -1 * n + -12) * 16 < 0?-(-(16 * c1 + -1 * n + -12) / 16) : ((16 < 0?(-(16 * c1 + -1 * n + -12) + - 16 - 1) / - 16 : (16 * c1 + -1 * n + -12 + 16 - 1) / 16)))) > 2 * c0 + -2 * c1?(((16 * c1 + -1 * n + -12) * 16 < 0?-(-(16 * c1 + -1 * n + -12) / 16) : ((16 < 0?(-(16 * c1 + -1 * n + -12) + - 16 - 1) / - 16 : (16 * c1 + -1 * n + -12 + 16 - 1) / 16)))) : 2 * c0 + -2 * c1); c2 <= (((((((16 * c1 + n + 12) * 16 < 0?((16 < 0?-((-(16 * c1 + n + 12) + 16 + 1) / 16) : -((-(16 * c1 + n + 12) + 16 - 1) / 16))) : (16 * c1 + n + 12) / 16)) < (((n + 2 * tsteps + -3) * 16 < 0?((16 < 0?-((-(n + 2 * tsteps + -3) + 16 + 1) / 16) : -((-(n + 2 * tsteps + -3) + 16 - 1) / 16))) : (n + 2 * tsteps + -3) / 16))?(((16 * c1 + n + 12) * 16 < 0?((16 < 0?-((-(16 * c1 + n + 12) + 16 + 1) / 16) : -((-(16 * c1 + n + 12) + 16 - 1) / 16))) : (16 * c1 + n + 12) / 16)) : (((n + 2 * tsteps + -3) * 16 < 0?((16 < 0?-((-(n + 2 * tsteps + -3) + 16 + 1) / 16) : -((-(n + 2 * tsteps + -3) + 16 - 1) / 16))) : (n + 2 * tsteps + -3) / 16)))) < (((32 * c0 + -32 * c1 + n + 29) * 16 < 0?((16 < 0?-((-(32 * c0 + -32 * c1 + n + 29) + 16 + 1) / 16) : -((-(32 * c0 + -32 * c1 + n + 29) + 16 - 1) / 16))) : (32 * c0 + -32 * c1 + n + 29) / 16))?(((((16 * c1 + n + 12) * 16 < 0?((16 < 0?-((-(16 * c1 + n + 12) + 16 + 1) / 16) : -((-(16 * c1 + n + 12) + 16 - 1) / 16))) : (16 * c1 + n + 12) / 16)) < (((n + 2 * tsteps + -3) * 16 < 0?((16 < 0?-((-(n + 2 * tsteps + -3) + 16 + 1) / 16) : -((-(n + 2 * tsteps + -3) + 16 - 1) / 16))) : (n + 2 * tsteps + -3) / 16))?(((16 * c1 + n + 12) * 16 < 0?((16 < 0?-((-(16 * c1 + n + 12) + 16 + 1) / 16) : -((-(16 * c1 + n + 12) + 16 - 1) / 16))) : (16 * c1 + n + 12) / 16)) : (((n + 2 * tsteps + -3) * 16 < 0?((16 < 0?-((-(n + 2 * tsteps + -3) + 16 + 1) / 16) : -((-(n + 2 * tsteps + -3) + 16 - 1) / 16))) : (n + 2 * tsteps + -3) / 16)))) : (((32 * c0 + -32 * c1 + n + 29) * 16 < 0?((16 < 0?-((-(32 * c0 + -32 * c1 + n + 29) + 16 + 1) / 16) : -((-(32 * c0 + -32 * c1 + n + 29) + 16 - 1) / 16))) : (32 * c0 + -32 * c1 + n + 29) / 16)))); c2++) {\n            if (c0 <= (((32 * c1 + 16 * c2 + -1 * n + 1) * 32 < 0?((32 < 0?-((-(32 * c1 + 16 * c2 + -1 * n + 1) + 32 + 1) / 32) : -((-(32 * c1 + 16 * c2 + -1 * n + 1) + 32 - 1) / 32))) : (32 * c1 + 16 * c2 + -1 * n + 1) / 32)) && c1 <= c2 + -1) {\n              if ((n + 1) % 2 == 0) {\n                for (c4 = (16 * c1 > 16 * c2 + -1 * n + 3?16 * c1 : 16 * c2 + -1 * n + 3); c4 <= 16 * c1 + 15; c4++) {\n                  A[-16 * c2 + c4 + n + -2][n + -2] = B[-16 * c2 + c4 + n + -2][n + -2];\n                }\n              }\n            }\n            if (c0 <= (((48 * c1 + -1 * n + 1) * 32 < 0?((32 < 0?-((-(48 * c1 + -1 * n + 1) + 32 + 1) / 32) : -((-(48 * c1 + -1 * n + 1) + 32 - 1) / 32))) : (48 * c1 + -1 * n + 1) / 32)) && c1 >= c2) {\n              if ((n + 1) % 2 == 0) {\n                for (c5 = (16 * c2 > 16 * c1 + -1 * n + 3?16 * c2 : 16 * c1 + -1 * n + 3); c5 <= ((16 * c1 < 16 * c2 + 15?16 * c1 : 16 * c2 + 15)); c5++) {\n                  A[n + -2][-16 * c1 + c5 + n + -2] = B[n + -2][-16 * c1 + c5 + n + -2];\n                }\n              }\n            }\n            for (c3 = ((((((16 * c1 + -1 * n + 2) * 2 < 0?-(-(16 * c1 + -1 * n + 2) / 2) : ((2 < 0?(-(16 * c1 + -1 * n + 2) + - 2 - 1) / - 2 : (16 * c1 + -1 * n + 2 + 2 - 1) / 2)))) > (((16 * c2 + -1 * n + 2) * 2 < 0?-(-(16 * c2 + -1 * n + 2) / 2) : ((2 < 0?(-(16 * c2 + -1 * n + 2) + - 2 - 1) / - 2 : (16 * c2 + -1 * n + 2 + 2 - 1) / 2))))?(((16 * c1 + -1 * n + 2) * 2 < 0?-(-(16 * c1 + -1 * n + 2) / 2) : ((2 < 0?(-(16 * c1 + -1 * n + 2) + - 2 - 1) / - 2 : (16 * c1 + -1 * n + 2 + 2 - 1) / 2)))) : (((16 * c2 + -1 * n + 2) * 2 < 0?-(-(16 * c2 + -1 * n + 2) / 2) : ((2 < 0?(-(16 * c2 + -1 * n + 2) + - 2 - 1) / - 2 : (16 * c2 + -1 * n + 2 + 2 - 1) / 2)))))) > 16 * c0 + -16 * c1?(((((16 * c1 + -1 * n + 2) * 2 < 0?-(-(16 * c1 + -1 * n + 2) / 2) : ((2 < 0?(-(16 * c1 + -1 * n + 2) + - 2 - 1) / - 2 : (16 * c1 + -1 * n + 2 + 2 - 1) / 2)))) > (((16 * c2 + -1 * n + 2) * 2 < 0?-(-(16 * c2 + -1 * n + 2) / 2) : ((2 < 0?(-(16 * c2 + -1 * n + 2) + - 2 - 1) / - 2 : (16 * c2 + -1 * n + 2 + 2 - 1) / 2))))?(((16 * c1 + -1 * n + 2) * 2 < 0?-(-(16 * c1 + -1 * n + 2) / 2) : ((2 < 0?(-(16 * c1 + -1 * n + 2) + - 2 - 1) / - 2 : (16 * c1 + -1 * n + 2 + 2 - 1) / 2)))) : (((16 * c2 + -1 * n + 2) * 2 < 0?-(-(16 * c2 + -1 * n + 2) / 2) : ((2 < 0?(-(16 * c2 + -1 * n + 2) + - 2 - 1) / - 2 : (16 * c2 + -1 * n + 2 + 2 - 1) / 2)))))) : 16 * c0 + -16 * c1); c3 <= ((((((8 * c1 + 6 < 8 * c2 + 6?8 * c1 + 6 : 8 * c2 + 6)) < tsteps + -1?((8 * c1 + 6 < 8 * c2 + 6?8 * c1 + 6 : 8 * c2 + 6)) : tsteps + -1)) < 16 * c0 + -16 * c1 + 15?((((8 * c1 + 6 < 8 * c2 + 6?8 * c1 + 6 : 8 * c2 + 6)) < tsteps + -1?((8 * c1 + 6 < 8 * c2 + 6?8 * c1 + 6 : 8 * c2 + 6)) : tsteps + -1)) : 16 * c0 + -16 * c1 + 15)); c3++) {\n              if (c1 <= ((c3 * 8 < 0?((8 < 0?-((-c3 + 8 + 1) / 8) : -((-c3 + 8 - 1) / 8))) : c3 / 8))) {\n                for (c5 = (16 * c2 > 2 * c3 + 1?16 * c2 : 2 * c3 + 1); c5 <= ((16 * c2 + 15 < 2 * c3 + n + -2?16 * c2 + 15 : 2 * c3 + n + -2)); c5++) {\n                  B[1][-2 * c3 + c5] = 0.2 * (A[1][-2 * c3 + c5] + A[1][-2 * c3 + c5 - 1] + A[1][1 + (-2 * c3 + c5)] + A[1 + 1][-2 * c3 + c5] + A[1 - 1][-2 * c3 + c5]);\n                }\n              }\n              for (c4 = (16 * c1 > 2 * c3 + 2?16 * c1 : 2 * c3 + 2); c4 <= ((16 * c1 + 15 < 2 * c3 + n + -2?16 * c1 + 15 : 2 * c3 + n + -2)); c4++) {\n                if (c2 <= ((c3 * 8 < 0?((8 < 0?-((-c3 + 8 + 1) / 8) : -((-c3 + 8 - 1) / 8))) : c3 / 8))) {\n                  B[-2 * c3 + c4][1] = 0.2 * (A[-2 * c3 + c4][1] + A[-2 * c3 + c4][1 - 1] + A[-2 * c3 + c4][1 + 1] + A[1 + (-2 * c3 + c4)][1] + A[-2 * c3 + c4 - 1][1]);\n                }\n                for (c5 = (16 * c2 > 2 * c3 + 2?16 * c2 : 2 * c3 + 2); c5 <= ((16 * c2 + 15 < 2 * c3 + n + -2?16 * c2 + 15 : 2 * c3 + n + -2)); c5++) {\n                  B[-2 * c3 + c4][-2 * c3 + c5] = 0.2 * (A[-2 * c3 + c4][-2 * c3 + c5] + A[-2 * c3 + c4][-2 * c3 + c5 - 1] + A[-2 * c3 + c4][1 + (-2 * c3 + c5)] + A[1 + (-2 * c3 + c4)][-2 * c3 + c5] + A[-2 * c3 + c4 - 1][-2 * c3 + c5]);\n                  A[-2 * c3 + c4 + -1][-2 * c3 + c5 + -1] = B[-2 * c3 + c4 + -1][-2 * c3 + c5 + -1];\n                }\n                if (c2 >= (((2 * c3 + n + -16) * 16 < 0?-(-(2 * c3 + n + -16) / 16) : ((16 < 0?(-(2 * c3 + n + -16) + - 16 - 1) / - 16 : (2 * c3 + n + -16 + 16 - 1) / 16))))) {\n                  A[-2 * c3 + c4 + -1][n + -2] = B[-2 * c3 + c4 + -1][n + -2];\n                }\n              }\n              if (c1 >= (((2 * c3 + n + -16) * 16 < 0?-(-(2 * c3 + n + -16) / 16) : ((16 < 0?(-(2 * c3 + n + -16) + - 16 - 1) / - 16 : (2 * c3 + n + -16 + 16 - 1) / 16))))) {\n                for (c5 = (16 * c2 > 2 * c3 + 2?16 * c2 : 2 * c3 + 2); c5 <= ((16 * c2 + 15 < 2 * c3 + n + -1?16 * c2 + 15 : 2 * c3 + n + -1)); c5++) {\n                  A[n + -2][-2 * c3 + c5 + -1] = B[n + -2][-2 * c3 + c5 + -1];\n                }\n              }\n            }\n            if (c0 >= (((2 * c1 + c2 + -1) * 2 < 0?-(-(2 * c1 + c2 + -1) / 2) : ((2 < 0?(-(2 * c1 + c2 + -1) + - 2 - 1) / - 2 : (2 * c1 + c2 + -1 + 2 - 1) / 2)))) && c1 >= c2 + 1 && c2 <= (((tsteps + -8) * 8 < 0?((8 < 0?-((-(tsteps + -8) + 8 + 1) / 8) : -((-(tsteps + -8) + 8 - 1) / 8))) : (tsteps + -8) / 8))) {\n              for (c4 = 16 * c1; c4 <= ((16 * c1 + 15 < 16 * c2 + n + 12?16 * c1 + 15 : 16 * c2 + n + 12)); c4++) {\n                B[-16 * c2 + c4 + -14][1] = 0.2 * (A[-16 * c2 + c4 + -14][1] + A[-16 * c2 + c4 + -14][1 - 1] + A[-16 * c2 + c4 + -14][1 + 1] + A[1 + (-16 * c2 + c4 + -14)][1] + A[-16 * c2 + c4 + -14 - 1][1]);\n              }\n            }\n            if (c0 >= (((3 * c1 + -1) * 2 < 0?-(-(3 * c1 + -1) / 2) : ((2 < 0?(-(3 * c1 + -1) + - 2 - 1) / - 2 : (3 * c1 + -1 + 2 - 1) / 2)))) && c1 <= (((((tsteps + -8) * 8 < 0?((8 < 0?-((-(tsteps + -8) + 8 + 1) / 8) : -((-(tsteps + -8) + 8 - 1) / 8))) : (tsteps + -8) / 8)) < c2?(((tsteps + -8) * 8 < 0?((8 < 0?-((-(tsteps + -8) + 8 + 1) / 8) : -((-(tsteps + -8) + 8 - 1) / 8))) : (tsteps + -8) / 8)) : c2))) {\n              for (c5 = (16 * c2 > 16 * c1 + 15?16 * c2 : 16 * c1 + 15); c5 <= ((16 * c2 + 15 < 16 * c1 + n + 12?16 * c2 + 15 : 16 * c1 + n + 12)); c5++) {\n                B[1][-16 * c1 + c5 + -14] = 0.2 * (A[1][-16 * c1 + c5 + -14] + A[1][-16 * c1 + c5 + -14 - 1] + A[1][1 + (-16 * c1 + c5 + -14)] + A[1 + 1][-16 * c1 + c5 + -14] + A[1 - 1][-16 * c1 + c5 + -14]);\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  \n\n}\n\nint main(int argc,char **argv)\n{\n\n  int n = 500;\n  int tsteps = 10;\n\n  double (*A)[500 + 0][500 + 0];\n  A = ((double (*)[500 + 0][500 + 0])(polybench_alloc_data(((500 + 0) * (500 + 0)),(sizeof(double )))));\n  ;\n  double (*B)[500 + 0][500 + 0];\n  B = ((double (*)[500 + 0][500 + 0])(polybench_alloc_data(((500 + 0) * (500 + 0)),(sizeof(double )))));\n  ;\n\n  init_array(n, *A, *B);\n\n  polybench_timer_start();\n  ;\n\n  kernel_jacobi_2d_imper(tsteps,n, *A, *B);\n\n  polybench_timer_stop();\n  ;\n  polybench_timer_print();\n  ;\n\n  if (argc > 42 && !strcmp(argv[0],\"\")) \n    print_array(n, *A);\n\n  free(((void *)A));\n  ;\n  free(((void *)B));\n  ;\n  return 0;\n}\n",
        "code_len": 12811,
        "data_race_label": "N4,N7",
        "var_pairs": []
    },
    {
        "ID": "057",
        "name": "DRB057-jacobiinitialize-orig-no.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/*\nUse of private() clause\n*/\n#include <stdio.h>\n#include <math.h>\n\n#define MSIZE 200\nint n=MSIZE, m=MSIZE;\ndouble alpha = 0.0543;\ndouble u[MSIZE][MSIZE], f[MSIZE][MSIZE], uold[MSIZE][MSIZE];\ndouble dx, dy;\n\nvoid\ninitialize ()\n{\n  int i, j, xx, yy;\n\n  dx = 2.0 / (n - 1);\n  dy = 2.0 / (m - 1);\n\n  /* Initialize initial condition and RHS */\n#pragma omp parallel for private(i,j,xx,yy)\n  for (i = 0; i < n; i++)\n    for (j = 0; j < m; j++)\n    {\n      xx = (int) (-1.0 + dx * (i - 1));       /* -1 < x < 1 */\n      yy = (int) (-1.0 + dy * (j - 1));       /* -1 < y < 1 */\n      u[i][j] = 0.0;\n      f[i][j] = -1.0 * alpha * (1.0 - xx * xx) * (1.0 - yy * yy)\n        - 2.0 * (1.0 - xx * xx) - 2.0 * (1.0 - yy * yy);\n\n    }\n}\n\nint main()\n{\n  initialize();\n  return 0;\n}\n",
        "data_race": 0,
        "trimmed_code": "#include <stdio.h>\n#include <math.h>\n\n#define MSIZE 200\nint n=MSIZE, m=MSIZE;\ndouble alpha = 0.0543;\ndouble u[MSIZE][MSIZE], f[MSIZE][MSIZE], uold[MSIZE][MSIZE];\ndouble dx, dy;\n\nvoid\ninitialize ()\n{\n  int i, j, xx, yy;\n\n  dx = 2.0 / (n - 1);\n  dy = 2.0 / (m - 1);\n\n  \n#pragma omp parallel for private(i,j,xx,yy)\n  for (i = 0; i < n; i++)\n    for (j = 0; j < m; j++)\n    {\n      xx = (int) (-1.0 + dx * (i - 1));       \n      yy = (int) (-1.0 + dy * (j - 1));       \n      u[i][j] = 0.0;\n      f[i][j] = -1.0 * alpha * (1.0 - xx * xx) * (1.0 - yy * yy)\n        - 2.0 * (1.0 - xx * xx) - 2.0 * (1.0 - yy * yy);\n\n    }\n}\n\nint main()\n{\n  initialize();\n  return 0;\n}\n",
        "code_len": 662,
        "data_race_label": "N7",
        "var_pairs": []
    },
    {
        "ID": "058",
        "name": "DRB058-jacobikernel-orig-no.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/*\nTwo parallel for loops within one single parallel region,\ncombined with private() and reduction().\n*/\n#include <stdio.h>\n#include <math.h>\n\n#define MSIZE 200\nint n=MSIZE, m=MSIZE, mits=1000;\ndouble tol=0.0000000001, relax = 1.0, alpha = 0.0543;\ndouble u[MSIZE][MSIZE], f[MSIZE][MSIZE], uold[MSIZE][MSIZE];\ndouble dx, dy;\n\nvoid\ninitialize ()\n{\n  int i, j, xx, yy;\n\n  dx = 2.0 / (n - 1);\n  dy = 2.0 / (m - 1);\n\n/* Initialize initial condition and RHS */\n//#pragma omp parallel for private(i,j,xx,yy)\n  for (i = 0; i < n; i++)\n    for (j = 0; j < m; j++)\n    {\n      xx = (int) (-1.0 + dx * (i - 1));       /* -1 < x < 1 */\n      yy = (int) (-1.0 + dy * (j - 1));       /* -1 < y < 1 */\n      u[i][j] = 0.0;\n      f[i][j] = -1.0 * alpha * (1.0 - xx * xx) * (1.0 - yy * yy)\n        - 2.0 * (1.0 - xx * xx) - 2.0 * (1.0 - yy * yy);\n\n    }\n}\n\nvoid\njacobi ()\n{\n  double omega;\n  int i, j, k;\n  double error, resid,  ax, ay, b;\n\n  omega = relax;\n/* Initialize coefficients */\n\n  dx = 2.0 / (n - 1); \n  dy = 2.0 / (m - 1);\n\n  ax = 1.0 / (dx * dx);         /* X-direction coef */\n  ay = 1.0 / (dy * dy);         /* Y-direction coef */\n  b = -2.0 / (dx * dx) - 2.0 / (dy * dy) - alpha;       /* Central coeff */\n\n  error = 10.0 * tol;\n  k = 1;\n\n  while (k <= mits)\n    {\n      error = 0.0;\n\n/* Copy new solution into old */\n#pragma omp parallel\n      {\n#pragma omp for private(i,j)\n        for (i = 0; i < n; i++)\n          for (j = 0; j < m; j++)\n            uold[i][j] = u[i][j];\n#pragma omp for private(i,j,resid) reduction(+:error) nowait\n        for (i = 1; i < (n - 1); i++)\n          for (j = 1; j < (m - 1); j++)\n            {\n              resid = (ax * (uold[i - 1][j] + uold[i + 1][j])\n                       + ay * (uold[i][j - 1] + uold[i][j + 1]) +\n                       b * uold[i][j] - f[i][j]) / b;\n\n              u[i][j] = uold[i][j] - omega * resid;\n              error = error + resid * resid;\n            }\n      }\n/*  omp end parallel */\n\n/* Error check */\n\n     k = k + 1;\n      error = sqrt (error) / (n * m);\n    }                           /*  End iteration loop */\n\n  printf (\"Total Number of Iterations:%d\\n\", k);\n  printf (\"Residual:%E\\n\", error);\n}\n\nint main()\n{\n  initialize();\n  jacobi();\n  return 0;\n}\n",
        "data_race": 0,
        "trimmed_code": "#include <stdio.h>\n#include <math.h>\n\n#define MSIZE 200\nint n=MSIZE, m=MSIZE, mits=1000;\ndouble tol=0.0000000001, relax = 1.0, alpha = 0.0543;\ndouble u[MSIZE][MSIZE], f[MSIZE][MSIZE], uold[MSIZE][MSIZE];\ndouble dx, dy;\n\nvoid\ninitialize ()\n{\n  int i, j, xx, yy;\n\n  dx = 2.0 / (n - 1);\n  dy = 2.0 / (m - 1);\n\n\n\n  for (i = 0; i < n; i++)\n    for (j = 0; j < m; j++)\n    {\n      xx = (int) (-1.0 + dx * (i - 1));       \n      yy = (int) (-1.0 + dy * (j - 1));       \n      u[i][j] = 0.0;\n      f[i][j] = -1.0 * alpha * (1.0 - xx * xx) * (1.0 - yy * yy)\n        - 2.0 * (1.0 - xx * xx) - 2.0 * (1.0 - yy * yy);\n\n    }\n}\n\nvoid\njacobi ()\n{\n  double omega;\n  int i, j, k;\n  double error, resid,  ax, ay, b;\n\n  omega = relax;\n\n\n  dx = 2.0 / (n - 1); \n  dy = 2.0 / (m - 1);\n\n  ax = 1.0 / (dx * dx);         \n  ay = 1.0 / (dy * dy);         \n  b = -2.0 / (dx * dx) - 2.0 / (dy * dy) - alpha;       \n\n  error = 10.0 * tol;\n  k = 1;\n\n  while (k <= mits)\n    {\n      error = 0.0;\n\n\n#pragma omp parallel\n      {\n#pragma omp for private(i,j)\n        for (i = 0; i < n; i++)\n          for (j = 0; j < m; j++)\n            uold[i][j] = u[i][j];\n#pragma omp for private(i,j,resid) reduction(+:error) nowait\n        for (i = 1; i < (n - 1); i++)\n          for (j = 1; j < (m - 1); j++)\n            {\n              resid = (ax * (uold[i - 1][j] + uold[i + 1][j])\n                       + ay * (uold[i][j - 1] + uold[i][j + 1]) +\n                       b * uold[i][j] - f[i][j]) / b;\n\n              u[i][j] = uold[i][j] - omega * resid;\n              error = error + resid * resid;\n            }\n      }\n\n\n\n\n     k = k + 1;\n      error = sqrt (error) / (n * m);\n    }                           \n\n  printf (\"Total Number of Iterations:%d\\n\", k);\n  printf (\"Residual:%E\\n\", error);\n}\n\nint main()\n{\n  initialize();\n  jacobi();\n  return 0;\n}\n",
        "code_len": 1815,
        "data_race_label": "N7",
        "var_pairs": []
    },
    {
        "ID": "059",
        "name": "DRB059-lastprivate-orig-no.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/*\nUsing lastprivate() to resolve an output dependence.\n\nSemantics of lastprivate (x):\ncauses the corresponding original list item to be updated after the end of the region.\nThe compiler/runtime copies the local value back to the shared one within the last iteration.\n*/\n#include <stdio.h>\n\nvoid foo()\n{\n  int i,x;\n#pragma omp parallel for private (i) lastprivate (x)\n  for (i=0;i<100;i++)\n    x=i;\n  printf(\"x=%d\",x);\n}\n\nint main()\n{\n  foo();\n  return 0;\n}\n\n",
        "data_race": 0,
        "trimmed_code": "#include <stdio.h>\n\nvoid foo()\n{\n  int i,x;\n#pragma omp parallel for private (i) lastprivate (x)\n  for (i=0;i<100;i++)\n    x=i;\n  printf(\"x=%d\",x);\n}\n\nint main()\n{\n  foo();\n  return 0;\n}\n\n",
        "code_len": 188,
        "data_race_label": "N2",
        "var_pairs": []
    },
    {
        "ID": "060",
        "name": "DRB060-matrixmultiply-orig-no.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/*\nClassic i-k-j matrix multiplication\n*/\n\n#define N 100\n#define M 100 \n#define K 100\ndouble a[N][M],b[M][K],c[N][K];\n            \nint mmm()   \n{           \n  int i,j,k;\n#pragma omp parallel for private(j,k)\n  for (i = 0; i < N; i++) \n    for (k = 0; k < K; k++) \n      for (j = 0; j < M; j++)\n        c[i][j]= c[i][j]+a[i][k]*b[k][j];\n  return 0; \n} \n\nint main()\n{\n  mmm();\n  return 0;\n}  \n",
        "data_race": 0,
        "trimmed_code": "#define N 100\n#define M 100 \n#define K 100\ndouble a[N][M],b[M][K],c[N][K];\n            \nint mmm()   \n{           \n  int i,j,k;\n#pragma omp parallel for private(j,k)\n  for (i = 0; i < N; i++) \n    for (k = 0; k < K; k++) \n      for (j = 0; j < M; j++)\n        c[i][j]= c[i][j]+a[i][k]*b[k][j];\n  return 0; \n} \n\nint main()\n{\n  mmm();\n  return 0;\n}  \n",
        "code_len": 348,
        "data_race_label": "N7",
        "var_pairs": []
    },
    {
        "ID": "061",
        "name": "DRB061-matrixvector1-orig-no.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/*\nMatrix-vector multiplication: outer-level loop parallelization\n*/\n#define N 100\n\ndouble a[N][N],v[N],v_out[N];\nint mv()\n{           \n  int i,j;\n#pragma omp parallel for private (i,j)\n  for (i = 0; i < N; i++)\n  {         \n    float sum = 0.0;\n    for (j = 0; j < N; j++)\n    { \n      sum += a[i][j]*v[j];\n    }  \n    v_out[i] = sum;\n  }         \n  return 0; \n}\n\nint main()\n{\n  mv();\n  return 0;\n}\n\n",
        "data_race": 0,
        "trimmed_code": "#define N 100\n\ndouble a[N][N],v[N],v_out[N];\nint mv()\n{           \n  int i,j;\n#pragma omp parallel for private (i,j)\n  for (i = 0; i < N; i++)\n  {         \n    float sum = 0.0;\n    for (j = 0; j < N; j++)\n    { \n      sum += a[i][j]*v[j];\n    }  \n    v_out[i] = sum;\n  }         \n  return 0; \n}\n\nint main()\n{\n  mv();\n  return 0;\n}\n\n",
        "code_len": 332,
        "data_race_label": "N7",
        "var_pairs": []
    },
    {
        "ID": "062",
        "name": "DRB062-matrixvector2-orig-no.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/*\nMatrix-vector multiplication: inner level parallelization.\n*/\n#define N 1000\ndouble a[N][N],v[N],v_out[N];\n\nvoid mv()\n{           \n  int i,j;\n  for (i = 0; i < N; i++)\n  {         \n    float sum = 0.0;\n#pragma omp parallel for reduction(+:sum)\n    for (j = 0; j < N; j++)\n    { \n      sum += a[i][j]*v[j];\n    }  \n    v_out[i] = sum;\n  }         \n}\n\nint main()\n{\n  mv();\n  return 0;\n}\n",
        "data_race": 0,
        "trimmed_code": "#define N 1000\ndouble a[N][N],v[N],v_out[N];\n\nvoid mv()\n{           \n  int i,j;\n  for (i = 0; i < N; i++)\n  {         \n    float sum = 0.0;\n#pragma omp parallel for reduction(+:sum)\n    for (j = 0; j < N; j++)\n    { \n      sum += a[i][j]*v[j];\n    }  \n    v_out[i] = sum;\n  }         \n}\n\nint main()\n{\n  mv();\n  return 0;\n}\n",
        "code_len": 323,
        "data_race_label": "N7",
        "var_pairs": []
    },
    {
        "ID": "063",
        "name": "DRB063-outeronly1-orig-no.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/* \nOnly the outmost loop can be parallelized. \n  \n*/\nint n=100, m=100;\ndouble b[100][100];\n\nvoid foo()\n{\n  int i,j;\n#pragma omp parallel for private(j)\n  for (i=0;i<n;i++)\n    for (j=0;j<m-1;j++) // Be careful about bounds of j\n      b[i][j]=b[i][j+1];\n}\n\nint main()\n{\n  foo();\n  return 0;\n}\n",
        "data_race": 0,
        "trimmed_code": "int n=100, m=100;\ndouble b[100][100];\n\nvoid foo()\n{\n  int i,j;\n#pragma omp parallel for private(j)\n  for (i=0;i<n;i++)\n    for (j=0;j<m-1;j++) \n      b[i][j]=b[i][j+1];\n}\n\nint main()\n{\n  foo();\n  return 0;\n}\n",
        "code_len": 208,
        "data_race_label": "N2",
        "var_pairs": []
    },
    {
        "ID": "064",
        "name": "DRB064-outeronly2-orig-no.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/* \nOnly the outmost loop can be parallelized. \n  \nThe inner loop has loop carried true data dependence.\nHowever, the loop is not parallelized so no race condition.\n*/\nint n=100, m=100;\ndouble b[100][100];\n\nvoid foo()\n{\n  int i,j;\n#pragma omp parallel for private(j)\n  for (i=0;i<n;i++)\n    for (j=1;j<m;j++) // Be careful about bounds of j\n      b[i][j]=b[i][j-1];\n}\n\nint main()\n{\n  foo();\n  return 0;\n}\n",
        "data_race": 0,
        "trimmed_code": "int n=100, m=100;\ndouble b[100][100];\n\nvoid foo()\n{\n  int i,j;\n#pragma omp parallel for private(j)\n  for (i=0;i<n;i++)\n    for (j=1;j<m;j++) \n      b[i][j]=b[i][j-1];\n}\n\nint main()\n{\n  foo();\n  return 0;\n}\n",
        "code_len": 206,
        "data_race_label": "N2",
        "var_pairs": []
    },
    {
        "ID": "065",
        "name": "DRB065-pireduction-orig-no.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/*\nClassic PI calculation using reduction    \n*/\n\n#define num_steps 2000000000 \n\n#include <stdio.h>\nint main(int argc, char** argv)\n{\n  double pi = 0.0;\n  long int i;\n  double x, interval_width;\n  interval_width = 1.0/(double)num_steps;\n\n#pragma omp parallel for reduction(+:pi) private(x)\n  for (i = 0; i < num_steps; i++) {\n    x = (i+ 0.5) * interval_width;\n    pi += 1.0 / (x*x + 1.0);\n  }\n\n  pi = pi * 4.0 * interval_width;\n  printf (\"PI=%f\\n\", pi);\n  return 0;\n}\n",
        "data_race": 0,
        "trimmed_code": "#define num_steps 2000000000 \n\n#include <stdio.h>\nint main(int argc, char** argv)\n{\n  double pi = 0.0;\n  long int i;\n  double x, interval_width;\n  interval_width = 1.0/(double)num_steps;\n\n#pragma omp parallel for reduction(+:pi) private(x)\n  for (i = 0; i < num_steps; i++) {\n    x = (i+ 0.5) * interval_width;\n    pi += 1.0 / (x*x + 1.0);\n  }\n\n  pi = pi * 4.0 * interval_width;\n  printf (\"PI=%f\\n\", pi);\n  return 0;\n}\n",
        "code_len": 419,
        "data_race_label": "N7",
        "var_pairs": []
    },
    {
        "ID": "066",
        "name": "DRB066-pointernoaliasing-orig-no.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/*\nFreshly allocated pointers do not alias to each other.\n*/\n#include <stdlib.h>\nvoid setup(int N)\n{\n  double * m_pdv_sum = (double* ) malloc (sizeof (double) * N );\n  double * m_nvol = (double* ) malloc (sizeof (double) * N );\n\n#pragma omp parallel for schedule(static)\n  for (int i=0; i < N; ++i ) \n  { \n    m_pdv_sum[ i ] = 0.0;\n    m_nvol[ i ]   = i*2.5;\n  }\n\n  free(m_pdv_sum);\n  free(m_nvol);\n}\n\nint main()\n{\n  int N =1000;\n  setup(N);\n}\n  \n",
        "data_race": 0,
        "trimmed_code": "#include <stdlib.h>\nvoid setup(int N)\n{\n  double * m_pdv_sum = (double* ) malloc (sizeof (double) * N );\n  double * m_nvol = (double* ) malloc (sizeof (double) * N );\n\n#pragma omp parallel for schedule(static)\n  for (int i=0; i < N; ++i ) \n  { \n    m_pdv_sum[ i ] = 0.0;\n    m_nvol[ i ]   = i*2.5;\n  }\n\n  free(m_pdv_sum);\n  free(m_nvol);\n}\n\nint main()\n{\n  int N =1000;\n  setup(N);\n}\n  \n",
        "code_len": 386,
        "data_race_label": "N6",
        "var_pairs": []
    },
    {
        "ID": "067",
        "name": "DRB067-restrictpointer1-orig-no.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/*\nrestrict pointers: no aliasing\nArray initialization using assignments. \n\nC99 is needed to compile this code\ne.g. gcc -std=c99 -c Stress-1.c\n*/\n#include <stdlib.h>\ntypedef double real8;\n\nvoid foo(real8 * restrict newSxx, real8 * restrict newSyy, int length)\n{\n  int i;\n\n#pragma omp parallel for private (i) firstprivate (length)\n  for (i = 0; i <= length - 1; i += 1) {\n    newSxx[i] = 0.0;\n    newSyy[i] = 0.0;\n  }\n}\n\nint main()\n{\n  int length=1000;\n  real8* newSxx = malloc (length* sizeof (real8));\n  real8* newSyy = malloc (length* sizeof (real8));\n\n  foo(newSxx, newSyy, length);\n\n  free (newSxx);\n  free (newSyy);\n  return 0;\n}\n\n",
        "data_race": 0,
        "trimmed_code": "#include <stdlib.h>\ntypedef double real8;\n\nvoid foo(real8 * restrict newSxx, real8 * restrict newSyy, int length)\n{\n  int i;\n\n#pragma omp parallel for private (i) firstprivate (length)\n  for (i = 0; i <= length - 1; i += 1) {\n    newSxx[i] = 0.0;\n    newSyy[i] = 0.0;\n  }\n}\n\nint main()\n{\n  int length=1000;\n  real8* newSxx = malloc (length* sizeof (real8));\n  real8* newSyy = malloc (length* sizeof (real8));\n\n  foo(newSxx, newSyy, length);\n\n  free (newSxx);\n  free (newSyy);\n  return 0;\n}\n\n",
        "code_len": 491,
        "data_race_label": "N6",
        "var_pairs": []
    },
    {
        "ID": "068",
        "name": "DRB068-restrictpointer2-orig-no.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/*\nThe restrict type qualifier is an indication to the compiler that,\nif the memory addressed by the restrict -qualified pointer is modified, no other pointer will access that same memory.\nIf a particular chunk of memory is not modified, it can be aliased through more than one restricted pointer.\nA C99 restrict feature.\nFor gcc, you must use -std=c99 to compile this program.\n*/\n\n#include <stdlib.h>\n#include <stdio.h>\n\nvoid foo(int n, int * restrict  a, int * restrict b, int * restrict  c)\n{\n  int i;\n#pragma omp parallel for \n  for (i = 0; i < n; i++)\n    a[i] = b[i] + c[i];  \n}\n\nint main()\n{\n  int n = 1000;\n  int * a , *b, *c;\n\n  a = (int*) malloc (n* sizeof (int));\n  if (a ==0)\n  {\n    fprintf (stderr, \"skip the execution due to malloc failures.\\n\");\n    return 1;\n  }\n\n  b = (int*) malloc (n* sizeof (int));\n  if (b ==0)\n  {\n    fprintf (stderr, \"skip the execution due to malloc failures.\\n\");\n    return 1;\n  }\n\n  c = (int*) malloc (n* sizeof (int));\n  if (c ==0)\n  {\n    fprintf (stderr, \"skip the execution due to malloc failures.\\n\");\n    return 1;\n  }\n\n  foo (n, a, b,c);\n\n  free (a);\n  free (b);\n  free (c);\n  return 0;\n}  \n\n",
        "data_race": 0,
        "trimmed_code": "#include <stdlib.h>\n#include <stdio.h>\n\nvoid foo(int n, int * restrict  a, int * restrict b, int * restrict  c)\n{\n  int i;\n#pragma omp parallel for \n  for (i = 0; i < n; i++)\n    a[i] = b[i] + c[i];  \n}\n\nint main()\n{\n  int n = 1000;\n  int * a , *b, *c;\n\n  a = (int*) malloc (n* sizeof (int));\n  if (a ==0)\n  {\n    fprintf (stderr, \"skip the execution due to malloc failures.\\n\");\n    return 1;\n  }\n\n  b = (int*) malloc (n* sizeof (int));\n  if (b ==0)\n  {\n    fprintf (stderr, \"skip the execution due to malloc failures.\\n\");\n    return 1;\n  }\n\n  c = (int*) malloc (n* sizeof (int));\n  if (c ==0)\n  {\n    fprintf (stderr, \"skip the execution due to malloc failures.\\n\");\n    return 1;\n  }\n\n  foo (n, a, b,c);\n\n  free (a);\n  free (b);\n  free (c);\n  return 0;\n}  \n\n",
        "code_len": 762,
        "data_race_label": "N6",
        "var_pairs": []
    },
    {
        "ID": "069",
        "name": "DRB069-sectionslock1-orig-no.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/*\nTwo tasks with a lock synchronization to ensure execution order.\n*/\n\n#include <omp.h>\n#include <assert.h> \nint main()\n{\n  omp_lock_t lck;\n  int i=0;\n  omp_init_lock(&lck);\n#pragma omp parallel sections\n  {\n#pragma omp section\n    {\n      omp_set_lock(&lck);\n      i += 1;    \n      omp_unset_lock(&lck);\n    }\n#pragma omp section\n    {\n      omp_set_lock(&lck);\n      i += 2;    \n      omp_unset_lock(&lck);\n    }\n  }\n\n  omp_destroy_lock(&lck);\n  assert (i==3);\n  return 0;\n} \n",
        "data_race": 0,
        "trimmed_code": "#include <omp.h>\n#include <assert.h> \nint main()\n{\n  omp_lock_t lck;\n  int i=0;\n  omp_init_lock(&lck);\n#pragma omp parallel sections\n  {\n#pragma omp section\n    {\n      omp_set_lock(&lck);\n      i += 1;    \n      omp_unset_lock(&lck);\n    }\n#pragma omp section\n    {\n      omp_set_lock(&lck);\n      i += 2;    \n      omp_unset_lock(&lck);\n    }\n  }\n\n  omp_destroy_lock(&lck);\n  assert (i==3);\n  return 0;\n} \n",
        "code_len": 408,
        "data_race_label": "N3",
        "var_pairs": []
    },
    {
        "ID": "070",
        "name": "DRB070-simd1-orig-no.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/*\nOne dimension array computation with a vectorization directive\n*/\nint a[100], b[100], c[100];\nint main()\n{\n  int i;\n#pragma omp simd\n  for (i=0;i<100;i++)\n    a[i]=b[i]*c[i];\n  return 0;\n}\n",
        "data_race": 0,
        "trimmed_code": "int a[100], b[100], c[100];\nint main()\n{\n  int i;\n#pragma omp simd\n  for (i=0;i<100;i++)\n    a[i]=b[i]*c[i];\n  return 0;\n}\n",
        "code_len": 123,
        "data_race_label": "N1,N4",
        "var_pairs": []
    },
    {
        "ID": "071",
        "name": "DRB071-targetparallelfor-orig-no.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/*\nuse of omp target: len is not mapped. It should be firstprivate within target.\n*/\nint main(int argc, char* argv[])\n{\n  int i;\n  int len = 1000;\n  int a[len];\n\n  for (i=0; i<len; i++)\n    a[i]= i;\n\n#pragma omp target map(a[0:len])\n#pragma omp parallel for\n  for (i=0;i< len;i++)\n    a[i]=a[i]+1;\n\n  return 0;\n}\n",
        "data_race": 0,
        "trimmed_code": "int main(int argc, char* argv[])\n{\n  int i;\n  int len = 1000;\n  int a[len];\n\n  for (i=0; i<len; i++)\n    a[i]= i;\n\n#pragma omp target map(a[0:len])\n#pragma omp parallel for\n  for (i=0;i< len;i++)\n    a[i]=a[i]+1;\n\n  return 0;\n}\n",
        "code_len": 228,
        "data_race_label": "N1,N5",
        "var_pairs": []
    },
    {
        "ID": "072",
        "name": "DRB072-taskdep1-orig-no.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/*\nTwo tasks with depend clause to ensure execution order:\ni is shared for two tasks based on implicit data-sharing attribute rules.\n*/\n#include <assert.h> \nint main()\n{\n  int i=0;\n#pragma omp parallel\n#pragma omp single\n  {\n#pragma omp task depend (out:i)\n    i = 1;    \n#pragma omp task depend (in:i)\n    i = 2;    \n  }\n\n  assert (i==2);\n  return 0;\n} \n",
        "data_race": 0,
        "trimmed_code": "#include <assert.h> \nint main()\n{\n  int i=0;\n#pragma omp parallel\n#pragma omp single\n  {\n#pragma omp task depend (out:i)\n    i = 1;    \n#pragma omp task depend (in:i)\n    i = 2;    \n  }\n\n  assert (i==2);\n  return 0;\n} \n",
        "code_len": 219,
        "data_race_label": "N3",
        "var_pairs": []
    },
    {
        "ID": "073",
        "name": "DRB073-doall2-orig-yes.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n#include <stdio.h>\n/*\nTwo-dimensional array computation using loops: missing private(j).\nReferences to j in the loop cause data races.\nData race pairs (we allow multiple ones to preserve the pattern):\n  Write_set = {j@61:10, j@61:20}\n  Read_set = {j@62:20, j@62:12, j@61:14, j@61:20}\n  Any pair from Write_set vs. Write_set  and Write_set vs. Read_set is a data race pair.\n*/\nint a[100][100];\nint main()\n{\n  int i,j;\n#pragma omp parallel for\n  for (i=0;i<100;i++)\n    for (j=0;j<100;j++)\n      a[i][j]=a[i][j]+1;\n  return 0;\n}\n\n",
        "data_race": 1,
        "trimmed_code": "#include <stdio.h>\n\nint a[100][100];\nint main()\n{\n  int i,j;\n#pragma omp parallel for\n  for (i=0;i<100;i++)\n    for (j=0;j<100;j++)\n      a[i][j]=a[i][j]+1;\n  return 0;\n}\n\n",
        "code_len": 172,
        "data_race_label": "Y2",
        "var_pairs": [
            {
                "name": [
                    "j",
                    "j"
                ],
                "line": [
                    61,
                    61
                ],
                "col": [
                    10,
                    20
                ],
                "operation": [
                    "W",
                    "W"
                ]
            },
            {
                "name": [
                    "j",
                    "j"
                ],
                "line": [
                    61,
                    62
                ],
                "col": [
                    10,
                    20
                ],
                "operation": [
                    "W",
                    "R"
                ]
            },
            {
                "name": [
                    "j",
                    "j"
                ],
                "line": [
                    61,
                    62
                ],
                "col": [
                    10,
                    12
                ],
                "operation": [
                    "W",
                    "R"
                ]
            },
            {
                "name": [
                    "j",
                    "j"
                ],
                "line": [
                    61,
                    61
                ],
                "col": [
                    10,
                    14
                ],
                "operation": [
                    "W",
                    "R"
                ]
            },
            {
                "name": [
                    "j",
                    "j"
                ],
                "line": [
                    61,
                    61
                ],
                "col": [
                    10,
                    20
                ],
                "operation": [
                    "W",
                    "R"
                ]
            },
            {
                "name": [
                    "j",
                    "j"
                ],
                "line": [
                    61,
                    62
                ],
                "col": [
                    20,
                    20
                ],
                "operation": [
                    "W",
                    "R"
                ]
            },
            {
                "name": [
                    "j",
                    "j"
                ],
                "line": [
                    61,
                    62
                ],
                "col": [
                    20,
                    12
                ],
                "operation": [
                    "W",
                    "R"
                ]
            },
            {
                "name": [
                    "j",
                    "j"
                ],
                "line": [
                    61,
                    61
                ],
                "col": [
                    20,
                    14
                ],
                "operation": [
                    "W",
                    "R"
                ]
            },
            {
                "name": [
                    "j",
                    "j"
                ],
                "line": [
                    61,
                    61
                ],
                "col": [
                    20,
                    20
                ],
                "operation": [
                    "W",
                    "R"
                ]
            }
        ]
    },
    {
        "ID": "074",
        "name": "DRB074-flush-orig-yes.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/*\nThis benchmark is extracted from flush_nolist.1c of OpenMP Application\nProgramming Interface Examples Version 4.5.0 .\nWe added one critical section to make it a test with only one pair of data races.\nThe data race will not generate wrong result though. So the assertion always passes.\nData race pair:  *q@60:3:W vs. i@71:11:R\n*/\n#include<stdio.h>\n#include<assert.h>\n\nvoid f1(int *q)\n{\n#pragma omp critical\n  *q = 1;\n#pragma omp flush\n}\n\nint main()\n{ \n  int i=0, sum=0; \n  \n  #pragma omp parallel reduction(+:sum) num_threads(10) \n  {\n     f1(&i);\n     sum+=i;\n  }\n  assert (sum==10);\n  printf(\"sum=%d\\n\", sum);\n  return 0;   \n}\n",
        "data_race": 1,
        "trimmed_code": "#include<stdio.h>\n#include<assert.h>\n\nvoid f1(int *q)\n{\n#pragma omp critical\n  *q = 1;\n#pragma omp flush\n}\n\nint main()\n{ \n  int i=0, sum=0; \n  \n  #pragma omp parallel reduction(+:sum) num_threads(10) \n  {\n     f1(&i);\n     sum+=i;\n  }\n  assert (sum==10);\n  printf(\"sum=%d\\n\", sum);\n  return 0;   \n}\n",
        "code_len": 299,
        "data_race_label": "Y2",
        "var_pairs": [
            "{\"name\": [\"*q\", \"i\"],\n\"line\": [60, 71],\n\"col\": [3, 11],\n\"operation\": [\"W\", \"R\"]}"
        ]
    },
    {
        "ID": "075",
        "name": "DRB075-getthreadnum-orig-yes.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/*\nTest if the semantics of omp_get_thread_num() is correctly recognized.\nThread with id 0 writes numThreads while other threads read it, causing data races.\nData race pair: numThreads@60:7:W vs. numThreads@64:33:R\n*/\n#include <omp.h>\n#include <stdio.h>\nint main()\n{\n  int numThreads=0 ; \n#pragma omp parallel\n  {\n    if ( omp_get_thread_num()==0 ) {\n      numThreads = omp_get_num_threads();\n    }\n    else\n    {\n      printf(\"numThreads=%d\\n\", numThreads);\n    }\n  }\n  return 0;\n}\n",
        "data_race": 1,
        "trimmed_code": "#include <omp.h>\n#include <stdio.h>\nint main()\n{\n  int numThreads=0 ; \n#pragma omp parallel\n  {\n    if ( omp_get_thread_num()==0 ) {\n      numThreads = omp_get_num_threads();\n    }\n    else\n    {\n      printf(\"numThreads=%d\\n\", numThreads);\n    }\n  }\n  return 0;\n}\n",
        "code_len": 265,
        "data_race_label": "Y1",
        "var_pairs": [
            "{\"name\": [\"numThreads\", \"numThreads\"],\n\"line\": [60, 64],\n\"col\": [7, 33],\n\"operation\": [\"W\", \"R\"]}"
        ]
    },
    {
        "ID": "076",
        "name": "DRB076-flush-orig-no.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/*\nThis benchmark is extracted from flush_nolist.1c of OpenMP\nApplication Programming Interface Examples Version 4.5.0 .\n\nWe privatize variable i to fix data races in the original example.\nOnce i is privatized, flush is no longer needed.\n*/\n\n#include<stdio.h>\n#include<assert.h>\nvoid f1(int *q)\n{\n  *q = 1;\n}\n\nint main()\n{ \n  int i=0, sum=0; \n  #pragma omp parallel reduction(+:sum) num_threads(10) private(i)\n  {\n     f1(&i);\n     sum+= i; \n  }\n  assert (sum==10);\n  printf(\"sum=%d\\n\", sum);\n  return 0;   \n}\n",
        "data_race": 0,
        "trimmed_code": "#include<stdio.h>\n#include<assert.h>\nvoid f1(int *q)\n{\n  *q = 1;\n}\n\nint main()\n{ \n  int i=0, sum=0; \n  #pragma omp parallel reduction(+:sum) num_threads(10) private(i)\n  {\n     f1(&i);\n     sum+= i; \n  }\n  assert (sum==10);\n  printf(\"sum=%d\\n\", sum);\n  return 0;   \n}\n",
        "code_len": 268,
        "data_race_label": "N2",
        "var_pairs": []
    },
    {
        "ID": "077",
        "name": "DRB077-single-orig-no.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/*\nA single directive is used to protect a write.\n*/\n#include <stdio.h>\n\nint main()\n{\n  int count=0;\n\n#pragma omp parallel shared(count) \n  {\n#pragma omp single\n    count += 1;\n  }\n\n  printf (\"count= %d\\n\", count);\n  return 0;\n}\n",
        "data_race": 0,
        "trimmed_code": "#include <stdio.h>\n\nint main()\n{\n  int count=0;\n\n#pragma omp parallel shared(count) \n  {\n#pragma omp single\n    count += 1;\n  }\n\n  printf (\"count= %d\\n\", count);\n  return 0;\n}\n",
        "code_len": 176,
        "data_race_label": "N1",
        "var_pairs": []
    },
    {
        "ID": "078",
        "name": "DRB078-taskdep2-orig-no.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/*\nTwo tasks with depend clause to ensure execution order, no data races.\ni is shared for two tasks based on implicit data-sharing attribute rules.\n*/\n#include <assert.h> \n#include <unistd.h>\nint main()\n{\n  int i=0;\n#pragma omp parallel\n#pragma omp single\n  {\n#pragma omp task depend (out:i)\n    {\n      sleep(3);\n      i = 1;    \n    }\n#pragma omp task depend (out:i)\n    i = 2;    \n  }\n\n  assert (i==2);\n  return 0;\n} \n",
        "data_race": 0,
        "trimmed_code": "#include <assert.h> \n#include <unistd.h>\nint main()\n{\n  int i=0;\n#pragma omp parallel\n#pragma omp single\n  {\n#pragma omp task depend (out:i)\n    {\n      sleep(3);\n      i = 1;    \n    }\n#pragma omp task depend (out:i)\n    i = 2;    \n  }\n\n  assert (i==2);\n  return 0;\n} \n",
        "code_len": 270,
        "data_race_label": "N3",
        "var_pairs": []
    },
    {
        "ID": "079",
        "name": "DRB079-taskdep3-orig-no.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/*\ntasks with depend clauses to ensure execution order, no data races.\n*/\n#include <stdio.h> \n#include <assert.h> \n#include <unistd.h>\nint main()\n{\n  int i=0, j, k;\n#pragma omp parallel\n#pragma omp single\n  {\n#pragma omp task depend (out:i)\n    {\n      sleep(3);\n      i = 1;    \n    }\n#pragma omp task depend (in:i)\n    j =i; \n#pragma omp task depend (in:i)\n    k =i; \n  }\n  printf (\"j=%d k=%d\\n\", j, k);\n  assert (j==1 && k==1);\n  return 0;\n} \n",
        "data_race": 0,
        "trimmed_code": "#include <stdio.h> \n#include <assert.h> \n#include <unistd.h>\nint main()\n{\n  int i=0, j, k;\n#pragma omp parallel\n#pragma omp single\n  {\n#pragma omp task depend (out:i)\n    {\n      sleep(3);\n      i = 1;    \n    }\n#pragma omp task depend (in:i)\n    j =i; \n#pragma omp task depend (in:i)\n    k =i; \n  }\n  printf (\"j=%d k=%d\\n\", j, k);\n  assert (j==1 && k==1);\n  return 0;\n} \n",
        "code_len": 372,
        "data_race_label": "N3",
        "var_pairs": []
    },
    {
        "ID": "080",
        "name": "DRB080-func-arg-orig-yes.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/*\nA function arguments is passed by reference: \nits data-sharing attribute is the same as its actual argument's. \ni is shared. *q is shared.\nData race pair: *q@59:4:W vs. *q@59:4:W \n*/\n\n#include<stdio.h>\n\n/*  argument pass-by-reference */\nvoid f1(int* q)\n{\n  *q += 1;\n}\n\nint main()\n{ \n  int i=0; \n  #pragma omp parallel \n  {\n     f1(&i);\n  }\n  printf (\"i=%d\\n\",i);\n  return 0;   \n}\n",
        "data_race": 1,
        "trimmed_code": "#include<stdio.h>\n\n\nvoid f1(int* q)\n{\n  *q += 1;\n}\n\nint main()\n{ \n  int i=0; \n  #pragma omp parallel \n  {\n     f1(&i);\n  }\n  printf (\"i=%d\\n\",i);\n  return 0;   \n}\n",
        "code_len": 163,
        "data_race_label": "Y6",
        "var_pairs": [
            "{\"name\": [\"*q\", \"*q\"],\n\"line\": [59, 59],\n\"col\": [4, 4],\n\"operation\": [\"W\", \"W\"]}"
        ]
    },
    {
        "ID": "081",
        "name": "DRB081-func-arg-orig-no.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/*\nA function argument passed by value should be private inside the function.\nVariable i is read only.\n*/\n\n#include<stdio.h>\n#include<assert.h>\n/*  argument pass-by-value */\nvoid f1(int q)\n{\n  q += 1;\n}\n\nint main()\n{\n  int i=0;\n  #pragma omp parallel \n  {\n     f1(i);\n  }\n  assert (i==0);\n  printf (\"i=%d\\n\",i);\n  return 0;\n}\n\n",
        "data_race": 0,
        "trimmed_code": "#include<stdio.h>\n#include<assert.h>\n\nvoid f1(int q)\n{\n  q += 1;\n}\n\nint main()\n{\n  int i=0;\n  #pragma omp parallel \n  {\n     f1(i);\n  }\n  assert (i==0);\n  printf (\"i=%d\\n\",i);\n  return 0;\n}\n\n",
        "code_len": 191,
        "data_race_label": "N6",
        "var_pairs": []
    },
    {
        "ID": "082",
        "name": "DRB082-declared-in-func-orig-yes.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/*\nA variable is declared inside a function called within a parallel region.\nThe variable should be shared if it uses static storage.\n\nData race pair: q@57:3:W vs. q@57:3:W \n*/\n\nvoid foo()\n{\n  static int q; \n  q += 1;\n}\n\nint main()\n{ \n  #pragma omp parallel \n  {\n     foo();\n  }\n  return 0;   \n}\n\n",
        "data_race": 1,
        "trimmed_code": "void foo()\n{\n  static int q; \n  q += 1;\n}\n\nint main()\n{ \n  #pragma omp parallel \n  {\n     foo();\n  }\n  return 0;   \n}\n\n",
        "code_len": 119,
        "data_race_label": "Y6",
        "var_pairs": [
            "{\"name\": [\"q\", \"q\"],\n\"line\": [57, 57],\n\"col\": [3, 3],\n\"operation\": [\"W\", \"W\"]}"
        ]
    },
    {
        "ID": "083",
        "name": "DRB083-declared-in-func-orig-no.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/*\nA variable is declared inside a function called within a parallel region.\nThe variable should be private if it does not use static storage.\n\n*/\n\nvoid foo()\n{\n  int q=0; \n  q += 1;\n}\n\nint main()\n{ \n  #pragma omp parallel \n  {\n     foo();\n  }\n  return 0;   \n}\n\n",
        "data_race": 0,
        "trimmed_code": "void foo()\n{\n  int q=0; \n  q += 1;\n}\n\nint main()\n{ \n  #pragma omp parallel \n  {\n     foo();\n  }\n  return 0;   \n}\n\n",
        "code_len": 114,
        "data_race_label": "N6",
        "var_pairs": []
    },
    {
        "ID": "084",
        "name": "DRB084-threadprivatemissing-orig-yes.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/*\nA file-scope variable used within a function called by a parallel region.\nNo threadprivate is used to avoid data races.\n\nData race pairs  sum0@61:3:W vs. sum0@61:8:R\n                 sum0@61:3:W vs. sum0@61:3:W\n*/\n#include <stdio.h>\n#include <assert.h>\nint sum0=0, sum1=0;\n//#pragma omp threadprivate(sum0)\n\nvoid foo (int i)\n{\n  sum0=sum0+i;\n}\n\nint main()\n{\n  int i, sum=0;\n#pragma omp parallel\n  {\n#pragma omp for\n    for (i=1;i<=1000;i++)\n    {\n       foo (i);\n    }   \n#pragma omp critical\n    {\n      sum= sum+sum0;\n    } \n  }  \n/*  reference calculation */\n  for (i=1;i<=1000;i++)\n  {\n    sum1=sum1+i;\n  }\n  printf(\"sum=%d; sum1=%d\\n\",sum,sum1);\n//  assert(sum==sum1);\n  return 0;\n}\n\n",
        "data_race": 1,
        "trimmed_code": "#include <stdio.h>\n#include <assert.h>\nint sum0=0, sum1=0;\n\n\nvoid foo (int i)\n{\n  sum0=sum0+i;\n}\n\nint main()\n{\n  int i, sum=0;\n#pragma omp parallel\n  {\n#pragma omp for\n    for (i=1;i<=1000;i++)\n    {\n       foo (i);\n    }   \n#pragma omp critical\n    {\n      sum= sum+sum0;\n    } \n  }  \n\n  for (i=1;i<=1000;i++)\n  {\n    sum1=sum1+i;\n  }\n  printf(\"sum=%d; sum1=%d\\n\",sum,sum1);\n\n  return 0;\n}\n\n",
        "code_len": 392,
        "data_race_label": "Y2",
        "var_pairs": [
            "{\"name\": [\"sum0\", \"sum0\"],\n\"line\": [61, 61],\n\"col\": [3, 8],\n\"operation\": [\"W\", \"R\"]}"
        ]
    },
    {
        "ID": "085",
        "name": "DRB085-threadprivate-orig-no.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/*\nA file-scope variable used within a function called by a parallel region.\nUse threadprivate to avoid data races.\n*/\n#include <stdio.h>\n#include <assert.h>\n\nint sum0=0, sum1=0;\n#pragma omp threadprivate(sum0)\n\nvoid foo (int i)\n{\n  sum0=sum0+i;\n}\n\nint main()\n{\n  int len=1000;\n  int i, sum=0;\n#pragma omp parallel copyin(sum0)\n  {\n#pragma omp for\n    for (i=0;i<len;i++)\n    {\n       foo (i);\n    }   \n#pragma omp critical\n    {\n      sum= sum+sum0;\n    } \n  }  \n/*  reference calculation */\n  for (i=0;i<len;i++)\n  {\n    sum1=sum1+i;\n  }\n  printf(\"sum=%d; sum1=%d\\n\",sum,sum1);\n  assert(sum==sum1);\n  return 0;\n}\n\n",
        "data_race": 0,
        "trimmed_code": "#include <stdio.h>\n#include <assert.h>\n\nint sum0=0, sum1=0;\n#pragma omp threadprivate(sum0)\n\nvoid foo (int i)\n{\n  sum0=sum0+i;\n}\n\nint main()\n{\n  int len=1000;\n  int i, sum=0;\n#pragma omp parallel copyin(sum0)\n  {\n#pragma omp for\n    for (i=0;i<len;i++)\n    {\n       foo (i);\n    }   \n#pragma omp critical\n    {\n      sum= sum+sum0;\n    } \n  }  \n\n  for (i=0;i<len;i++)\n  {\n    sum1=sum1+i;\n  }\n  printf(\"sum=%d; sum1=%d\\n\",sum,sum1);\n  assert(sum==sum1);\n  return 0;\n}\n\n",
        "code_len": 469,
        "data_race_label": "N2",
        "var_pairs": []
    },
    {
        "ID": "086",
        "name": "DRB086-static-data-member-orig-yes.cpp",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/*\nFor the case of a variable which is not referenced within a construct:\nstatic data member should be shared, unless it is within a threadprivate directive.\n\nDependence pair: a.counter@72:6:W vs. a.counter@72:6:W\n*/\n\n#include<iostream>\n#include<cassert>\nusing namespace std;\n\nclass A {\npublic:\n  static int counter; \n  static int pcounter; \n#pragma omp threadprivate(pcounter)\n};\n\nint A::counter=0; \nint A::pcounter=0; \n\nA a; \n\nvoid foo()\n{\n   a.counter++; \n   a.pcounter++; \n}\n\nint main()\n{ \n  #pragma omp parallel \n  {\n     foo();\n  }\n  assert (A::pcounter == 1);\n  cout<<A::counter <<\" \"<< A::pcounter<<endl;\n  return 0;   \n}\n",
        "data_race": 1,
        "trimmed_code": "#include<iostream>\n#include<cassert>\nusing namespace std;\n\nclass A {\npublic:\n  static int counter; \n  static int pcounter; \n#pragma omp threadprivate(pcounter)\n};\n\nint A::counter=0; \nint A::pcounter=0; \n\nA a; \n\nvoid foo()\n{\n   a.counter++; \n   a.pcounter++; \n}\n\nint main()\n{ \n  #pragma omp parallel \n  {\n     foo();\n  }\n  assert (A::pcounter == 1);\n  cout<<A::counter <<\" \"<< A::pcounter<<endl;\n  return 0;   \n}\n",
        "code_len": 412,
        "data_race_label": "Y2",
        "var_pairs": [
            {
                "name": [
                    "j",
                    "j"
                ],
                "line": [
                    61,
                    61
                ],
                "col": [
                    20,
                    20
                ],
                "operation": [
                    "W",
                    "R"
                ]
            }
        ]
    },
    {
        "ID": "087",
        "name": "DRB087-static-data-member2-orig-yes.cpp",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/*\nFor the case of a variable which is referenced within a construct:\nstatic data member should be shared, unless it is within a threadprivate directive.\n\nDependence pair: a.counter@74:6:W vs. a.counter@74:6:W\n*/\n\n#include<iostream>\n#include<cassert>\nusing namespace std;\n\nclass A {\npublic:\n  static int counter; \n  static int pcounter; \n#pragma omp threadprivate(pcounter)\n};\n\nint A::counter=0; \nint A::pcounter=0; \n\nA a; \n\nint main()\n{ \n  #pragma omp parallel \n  {\n   a.counter++; \n   a.pcounter++; \n  }\n  assert (A::pcounter == 1);\n  cout<<A::counter <<\" \"<< A::pcounter<<endl;\n  return 0;   \n}\n",
        "data_race": 1,
        "trimmed_code": "#include<iostream>\n#include<cassert>\nusing namespace std;\n\nclass A {\npublic:\n  static int counter; \n  static int pcounter; \n#pragma omp threadprivate(pcounter)\n};\n\nint A::counter=0; \nint A::pcounter=0; \n\nA a; \n\nint main()\n{ \n  #pragma omp parallel \n  {\n   a.counter++; \n   a.pcounter++; \n  }\n  assert (A::pcounter == 1);\n  cout<<A::counter <<\" \"<< A::pcounter<<endl;\n  return 0;   \n}\n",
        "code_len": 384,
        "data_race_label": "Y2",
        "var_pairs": [
            {
                "name": [
                    "a.counter",
                    "a.counter"
                ],
                "line": [
                    74,
                    74
                ],
                "col": [
                    6,
                    6
                ],
                "operation": [
                    "W",
                    "W"
                ]
            }
        ]
    },
    {
        "ID": "088",
        "name": "DRB088-dynamic-storage-orig-yes.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/*\nFor the case of a variable which is not referenced within a construct:\nobjects with dynamic storage duration should be shared.\nPutting it within a threadprivate directive may cause seg fault since\n threadprivate copies are not allocated!\n\nDependence pair: *counter@63:6:W vs. *counter@63:6:W\n*/\n\n#include<stdio.h>\n#include<stdlib.h>\n\nint* counter; \n\nvoid foo()\n{\n   (*counter)++; \n}\n\nint main()\n{ \n  counter = (int*) malloc(sizeof(int));\n  if (counter== NULL)\n  {\n    fprintf(stderr, \"malloc() fails\\n\");\n    exit(1);\n  }\n  *counter = 0; \n #pragma omp parallel \n  {\n     foo();\n  }\n  printf(\"%d \\n\", *counter);\n  free (counter);\n  return 0;   \n}\n\n",
        "data_race": 1,
        "trimmed_code": "#include<stdio.h>\n#include<stdlib.h>\n\nint* counter; \n\nvoid foo()\n{\n   (*counter)++; \n}\n\nint main()\n{ \n  counter = (int*) malloc(sizeof(int));\n  if (counter== NULL)\n  {\n    fprintf(stderr, \"malloc() fails\\n\");\n    exit(1);\n  }\n  *counter = 0; \n #pragma omp parallel \n  {\n     foo();\n  }\n  printf(\"%d \\n\", *counter);\n  free (counter);\n  return 0;   \n}\n\n",
        "code_len": 351,
        "data_race_label": "Y2",
        "var_pairs": [
            {
                "name": [
                    "*counter",
                    "*counter"
                ],
                "line": [
                    63,
                    63
                ],
                "col": [
                    6,
                    6
                ],
                "operation": [
                    "W",
                    "W"
                ]
            }
        ]
    },
    {
        "ID": "089",
        "name": "DRB089-dynamic-storage2-orig-yes.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/*\nFor the case of a variable which is referenced within a construct:\nobjects with dynamic storage duration should be shared.\nPutting it within a threadprivate directive may cause seg fault \nsince threadprivate copies are not allocated.\n\nDependence pair: *counter@73:7:W vs. *counter@73:7:W\n*/\n\n#include<stdio.h>\n#include<stdlib.h>\n\nint* counter; \n//#pragma omp threadprivate(counter)\n\nint main()\n{ \n  counter = (int*) malloc(sizeof(int));\n  if (counter== NULL)\n  {\n    fprintf(stderr, \"malloc() fails\\n\");\n    exit(1);\n  }\n  *counter = 0; \n #pragma omp parallel \n  {\n    (*counter)++; \n  }\n  printf(\"%d \\n\", *counter);\n  free (counter);\n  return 0;   \n}\n\n",
        "data_race": 1,
        "trimmed_code": "#include<stdio.h>\n#include<stdlib.h>\n\nint* counter; \n\n\nint main()\n{ \n  counter = (int*) malloc(sizeof(int));\n  if (counter== NULL)\n  {\n    fprintf(stderr, \"malloc() fails\\n\");\n    exit(1);\n  }\n  *counter = 0; \n #pragma omp parallel \n  {\n    (*counter)++; \n  }\n  printf(\"%d \\n\", *counter);\n  free (counter);\n  return 0;   \n}\n\n",
        "code_len": 325,
        "data_race_label": "Y2",
        "var_pairs": [
            {
                "name": [
                    "*counter",
                    "*counter"
                ],
                "line": [
                    73,
                    73
                ],
                "col": [
                    7,
                    7
                ],
                "operation": [
                    "W",
                    "W"
                ]
            }
        ]
    },
    {
        "ID": "090",
        "name": "DRB090-static-local-orig-yes.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/*\nFor a variable declared in a scope inside an OpenMP construct:\n* private if the variable has an automatic storage duration\n* shared if the variable has a static storage duration. \n\nDependence pairs: \n   tmp@73:7:W vs. tmp@73:7:W\n   tmp@73:7:W vs. tmp@74:14:R\n*/\n#include<stdio.h>\n\nint main(int argc, char* argv[])\n{\n  int i;\n  int len=100;\n  int a[len], b[len];\n\n  for (i=0;i<len;i++)\n  {  a[i]=i; b[i]=i;} \n/* static storage for a local variable */\n#pragma omp parallel \n  {\n    static int tmp;\n#pragma omp for\n    for (i=0;i<len;i++)\n    {\n      tmp = a[i]+i;\n      a[i] = tmp;\n    }\n  }\n\n/* automatic storage for a local variable */\n#pragma omp parallel \n  {\n    int tmp;\n#pragma omp for\n    for (i=0;i<len;i++)\n    {\n      tmp = b[i]+i;\n      b[i] = tmp;\n    }\n  }\n\n  printf(\"a[50]=%d b[50]=%d\\n\", a[50], b[50]);\n \n  return 0;\n}\n",
        "data_race": 1,
        "trimmed_code": "#include<stdio.h>\n\nint main(int argc, char* argv[])\n{\n  int i;\n  int len=100;\n  int a[len], b[len];\n\n  for (i=0;i<len;i++)\n  {  a[i]=i; b[i]=i;} \n\n#pragma omp parallel \n  {\n    static int tmp;\n#pragma omp for\n    for (i=0;i<len;i++)\n    {\n      tmp = a[i]+i;\n      a[i] = tmp;\n    }\n  }\n\n\n#pragma omp parallel \n  {\n    int tmp;\n#pragma omp for\n    for (i=0;i<len;i++)\n    {\n      tmp = b[i]+i;\n      b[i] = tmp;\n    }\n  }\n\n  printf(\"a[50]=%d b[50]=%d\\n\", a[50], b[50]);\n \n  return 0;\n}\n",
        "code_len": 486,
        "data_race_label": "Y2",
        "var_pairs": [
            {
                "name": [
                    "tmp",
                    "tmp"
                ],
                "line": [
                    73,
                    73
                ],
                "col": [
                    7,
                    7
                ],
                "operation": [
                    "W",
                    "W"
                ]
            },
            {
                "name": [
                    "tmp",
                    "tmp"
                ],
                "line": [
                    73,
                    74
                ],
                "col": [
                    7,
                    14
                ],
                "operation": [
                    "W",
                    "R"
                ]
            }
        ]
    },
    {
        "ID": "091",
        "name": "DRB091-threadprivate2-orig-no.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/*\nA file-scope variable used within a function called by a parallel region.\nUse threadprivate to avoid data races.\nThis is the case for a variable referenced within a construct.\n*/\n#include <stdio.h>\n#include <assert.h>\n\nint sum0=0, sum1=0;\n#pragma omp threadprivate(sum0)\n\nint main()\n{\n  int len=1000;\n  int i, sum=0;\n#pragma omp parallel copyin(sum0)\n  {\n#pragma omp for\n    for (i=0;i<len;i++)\n    {\n      sum0=sum0+i;\n    }   \n#pragma omp critical\n    {\n      sum= sum+sum0;\n    } \n  }  \n  /*  reference calculation */\n  for (i=0;i<len;i++)\n  {\n    sum1=sum1+i;\n  }\n  printf(\"sum=%d; sum1=%d\\n\",sum,sum1);\n  assert(sum==sum1);\n  return 0;\n}\n\n",
        "data_race": 0,
        "trimmed_code": "#include <stdio.h>\n#include <assert.h>\n\nint sum0=0, sum1=0;\n#pragma omp threadprivate(sum0)\n\nint main()\n{\n  int len=1000;\n  int i, sum=0;\n#pragma omp parallel copyin(sum0)\n  {\n#pragma omp for\n    for (i=0;i<len;i++)\n    {\n      sum0=sum0+i;\n    }   \n#pragma omp critical\n    {\n      sum= sum+sum0;\n    } \n  }  \n  \n  for (i=0;i<len;i++)\n  {\n    sum1=sum1+i;\n  }\n  printf(\"sum=%d; sum1=%d\\n\",sum,sum1);\n  assert(sum==sum1);\n  return 0;\n}\n\n",
        "code_len": 437,
        "data_race_label": "N2",
        "var_pairs": []
    },
    {
        "ID": "092",
        "name": "DRB092-threadprivatemissing2-orig-yes.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/*\nA file-scope variable used within a function called by a parallel region.\nNo threadprivate is used to avoid data races.\nThis is the case for a variable referenced within a construct. \n\nData race pairs  sum0@68:7:W vs. sum0@68:12:R\n                 sum0@68:7:W vs. sum0@68:7:W\n*/\n#include <stdio.h>\n#include <assert.h>\nint sum0=0, sum1=0;\n//#pragma omp threadprivate(sum0)\n\nint main()\n{\n  int i, sum=0;\n#pragma omp parallel\n  {\n#pragma omp for\n    for (i=1;i<=1000;i++)\n    {\n      sum0=sum0+i;\n    }   \n#pragma omp critical\n    {\n      sum= sum+sum0;\n    } \n  }  \n/*  reference calculation */\n  for (i=1;i<=1000;i++)\n  {\n    sum1=sum1+i;\n  }\n  printf(\"sum=%d; sum1=%d\\n\",sum,sum1);\n//  assert(sum==sum1);\n  return 0;\n}\n\n",
        "data_race": 1,
        "trimmed_code": "#include <stdio.h>\n#include <assert.h>\nint sum0=0, sum1=0;\n\n\nint main()\n{\n  int i, sum=0;\n#pragma omp parallel\n  {\n#pragma omp for\n    for (i=1;i<=1000;i++)\n    {\n      sum0=sum0+i;\n    }   \n#pragma omp critical\n    {\n      sum= sum+sum0;\n    } \n  }  \n\n  for (i=1;i<=1000;i++)\n  {\n    sum1=sum1+i;\n  }\n  printf(\"sum=%d; sum1=%d\\n\",sum,sum1);\n\n  return 0;\n}\n\n",
        "code_len": 358,
        "data_race_label": "Y2",
        "var_pairs": [
            "{\"name\": [\"sum0\", \"sum0\"],\n\"line\": [68, 68],\n\"col\": [7, 12],\n\"operation\": [\"W\", \"R\"]}"
        ]
    },
    {
        "ID": "093",
        "name": "DRB093-doall2-collapse-orig-no.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/* \nTwo-dimensional array computation: \ncollapse(2) is used to associate two loops with omp for. \nThe corresponding loop iteration variables are private. \n*/\nint a[100][100];\nint main()\n{\n  int i,j;\n#pragma omp parallel for collapse(2)\n  for (i=0;i<100;i++)\n    for (j=0;j<100;j++)\n      a[i][j]=a[i][j]+1;\n  return 0;\n}\n\n",
        "data_race": 0,
        "trimmed_code": "int a[100][100];\nint main()\n{\n  int i,j;\n#pragma omp parallel for collapse(2)\n  for (i=0;i<100;i++)\n    for (j=0;j<100;j++)\n      a[i][j]=a[i][j]+1;\n  return 0;\n}\n\n",
        "code_len": 164,
        "data_race_label": "N2",
        "var_pairs": []
    },
    {
        "ID": "094",
        "name": "DRB094-doall2-ordered-orig-no.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/* \nTwo-dimensional array computation: \nordered(2) is used to associate two loops with omp for.\nThe corresponding loop iteration variables are private. \n\nordered(n) is an OpenMP 4.5 addition. \n*/\n#if (_OPENMP<201511)\n#error \"An OpenMP 4.5 compiler is needed to compile this test.\"\n#endif\n#include <stdio.h>\nint a[100][100];\nint main()\n{\n  int i, j;\n#pragma omp parallel for ordered(2)\n  for (i = 0; i < 100; i++)\n    for (j = 0; j < 100; j++)\n    {\n      a[i][j] = a[i][j] + 1;\n#pragma omp ordered depend(sink:i-1,j) depend (sink:i,j-1)\n      printf (\"test i=%d j=%d\\n\",i,j);\n#pragma omp ordered depend(source)\n    }\n  return 0;\n}\n\n",
        "data_race": 0,
        "trimmed_code": "#if (_OPENMP<201511)\n#error \"An OpenMP 4.5 compiler is needed to compile this test.\"\n#endif\n#include <stdio.h>\nint a[100][100];\nint main()\n{\n  int i, j;\n#pragma omp parallel for ordered(2)\n  for (i = 0; i < 100; i++)\n    for (j = 0; j < 100; j++)\n    {\n      a[i][j] = a[i][j] + 1;\n#pragma omp ordered depend(sink:i-1,j) depend (sink:i,j-1)\n      printf (\"test i=%d j=%d\\n\",i,j);\n#pragma omp ordered depend(source)\n    }\n  return 0;\n}\n\n",
        "code_len": 436,
        "data_race_label": "N2",
        "var_pairs": []
    },
    {
        "ID": "095",
        "name": "DRB095-doall2-taskloop-orig-yes.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n/* \nTwo-dimensional array computation:\nOnly one loop is associated with omp taskloop. \nThe inner loop's loop iteration variable will be shared if it is shared in the enclosing context.\nData race pairs (we allow multiple ones to preserve the pattern):\n  Write_set = {j@69:14, j@69:30, a[i][j]@70:11}\n  Read_set = {j@69:21, j@69:30, j@70:16, a[i][j]@70:11}\n  Any pair from Write_set vs. Write_set  and Write_set vs. Read_set is a data race pair.\n*/\n#if (_OPENMP<201511)\n#error \"An OpenMP 4.5 compiler is needed to compile this test.\"\n#endif\n#include <stdio.h>\nint a[100][100];\nint main()\n{\n  int i, j;\n#pragma omp parallel\n  {\n#pragma omp single\n    {\n#pragma omp taskloop\n      for (i = 0; i < 100; i++)\n        for (j = 0; j < 100; j++)\n          a[i][j]+=1; \n    }\n  }\n  printf (\"a[50][50]=%d\\n\", a[50][50]);\n  return 0;\n}\n",
        "data_race": 1,
        "trimmed_code": "#if (_OPENMP<201511)\n#error \"An OpenMP 4.5 compiler is needed to compile this test.\"\n#endif\n#include <stdio.h>\nint a[100][100];\nint main()\n{\n  int i, j;\n#pragma omp parallel\n  {\n#pragma omp single\n    {\n#pragma omp taskloop\n      for (i = 0; i < 100; i++)\n        for (j = 0; j < 100; j++)\n          a[i][j]+=1; \n    }\n  }\n  printf (\"a[50][50]=%d\\n\", a[50][50]);\n  return 0;\n}\n",
        "code_len": 377,
        "data_race_label": "Y2",
        "var_pairs": [
            {
                "name": [
                    "j",
                    "j"
                ],
                "line": [
                    69,
                    69
                ],
                "col": [
                    14,
                    30
                ],
                "operation": [
                    "W",
                    "W"
                ]
            },
            {
                "name": [
                    "j",
                    "a[i][j]"
                ],
                "line": [
                    69,
                    70
                ],
                "col": [
                    14,
                    11
                ],
                "operation": [
                    "W",
                    "W"
                ]
            },
            {
                "name": [
                    "j",
                    "a[i][j]"
                ],
                "line": [
                    69,
                    70
                ],
                "col": [
                    30,
                    11
                ],
                "operation": [
                    "W",
                    "W"
                ]
            },
            {
                "name": [
                    "j",
                    "j"
                ],
                "line": [
                    69,
                    69
                ],
                "col": [
                    14,
                    21
                ],
                "operation": [
                    "W",
                    "R"
                ]
            },
            {
                "name": [
                    "j",
                    "j"
                ],
                "line": [
                    69,
                    69
                ],
                "col": [
                    14,
                    30
                ],
                "operation": [
                    "W",
                    "R"
                ]
            },
            {
                "name": [
                    "j",
                    "j"
                ],
                "line": [
                    69,
                    70
                ],
                "col": [
                    14,
                    16
                ],
                "operation": [
                    "W",
                    "R"
                ]
            },
            {
                "name": [
                    "j",
                    "a[i][j]"
                ],
                "line": [
                    69,
                    70
                ],
                "col": [
                    14,
                    11
                ],
                "operation": [
                    "W",
                    "R"
                ]
            },
            {
                "name": [
                    "j",
                    "j"
                ],
                "line": [
                    69,
                    69
                ],
                "col": [
                    30,
                    21
                ],
                "operation": [
                    "W",
                    "R"
                ]
            },
            {
                "name": [
                    "j",
                    "j"
                ],
                "line": [
                    69,
                    69
                ],
                "col": [
                    30,
                    21
                ],
                "operation": [
                    "W",
                    "R"
                ]
            },
            {
                "name": [
                    "j",
                    "a[i][j]"
                ],
                "line": [
                    69,
                    70
                ],
                "col": [
                    30,
                    11
                ],
                "operation": [
                    "W",
                    "R"
                ]
            },
            {
                "name": [
                    "a[i][j]",
                    "j"
                ],
                "line": [
                    70,
                    69
                ],
                "col": [
                    11,
                    21
                ],
                "operation": [
                    "W",
                    "R"
                ]
            },
            {
                "name": [
                    "a[i][j]",
                    "j"
                ],
                "line": [
                    70,
                    69
                ],
                "col": [
                    11,
                    30
                ],
                "operation": [
                    "W",
                    "R"
                ]
            },
            {
                "name": [
                    "a[i][j]",
                    "j"
                ],
                "line": [
                    70,
                    70
                ],
                "col": [
                    11,
                    16
                ],
                "operation": [
                    "W",
                    "R"
                ]
            },
            {
                "name": [
                    "a[i][j]",
                    "a[i][j]"
                ],
                "line": [
                    70,
                    70
                ],
                "col": [
                    11,
                    11
                ],
                "operation": [
                    "W",
                    "R"
                ]
            }
        ]
    },
    {
        "ID": "096",
        "name": "DRB096-doall2-taskloop-collapse-orig-no.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n/* \nTwo-dimensional array computation:\nTwo loops are associated with omp taskloop due to collapse(2).\nBoth loop index variables are private.\ntaskloop requires OpenMP 4.5 compilers.\n*/\n#if (_OPENMP<201511)\n#error \"An OpenMP 4.5 compiler is needed to compile this test.\"\n#endif\n\n#include <stdio.h>\nint a[100][100];\nint main()\n{\n  int i, j;\n#pragma omp parallel\n  {\n#pragma omp single\n    {\n#pragma omp taskloop collapse(2)\n      for (i = 0; i < 100; i++)\n        for (j = 0; j < 100; j++)\n          a[i][j]+=1; \n    }\n  }\n  printf (\"a[50][50]=%d\\n\", a[50][50]);\n  return 0;\n}\n",
        "data_race": 0,
        "trimmed_code": "#if (_OPENMP<201511)\n#error \"An OpenMP 4.5 compiler is needed to compile this test.\"\n#endif\n\n#include <stdio.h>\nint a[100][100];\nint main()\n{\n  int i, j;\n#pragma omp parallel\n  {\n#pragma omp single\n    {\n#pragma omp taskloop collapse(2)\n      for (i = 0; i < 100; i++)\n        for (j = 0; j < 100; j++)\n          a[i][j]+=1; \n    }\n  }\n  printf (\"a[50][50]=%d\\n\", a[50][50]);\n  return 0;\n}\n",
        "code_len": 390,
        "data_race_label": "N2",
        "var_pairs": []
    },
    {
        "ID": "097",
        "name": "DRB097-target-teams-distribute-orig-no.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n#include <stdio.h>\n#define min(x, y) (((x) < (y)) ? (x) : (y))\n\n/*\nuse of omp target + teams + distribute + parallel for\n*/\nint main(int argc, char* argv[])\n{\n  int i, i2;\n  int len = 2560;\n  double sum =0.0, sum2=0.0;\n  double a[len], b[len];\n  /*Initialize with some values*/\n  for (i=0; i<len; i++)\n  {\n    a[i]= ((double)i)/2.0;\n    b[i]= ((double)i)/3.0;\n  }\n\n#pragma omp target map(to: a[0:len], b[0:len]) map(tofrom: sum)\n#pragma omp teams num_teams(10) thread_limit(256) reduction (+:sum) \n#pragma omp distribute\n  for (i2=0; i2< len; i2+=256)  \n#pragma omp parallel for reduction (+:sum)\n    for (i=i2;i< min(i2+256, len); i++)\n      sum += a[i]*b[i];\n\n/* CPU reference computation */  \n#pragma omp parallel for reduction (+:sum2)\n    for (i=0;i< len; i++)\n      sum2 += a[i]*b[i];\n  printf (\"sum=%f sum2=%f\\n\", sum, sum2);\n  return 0;\n}\n",
        "data_race": 0,
        "trimmed_code": "#include <stdio.h>\n#define min(x, y) (((x) < (y)) ? (x) : (y))\n\n\nint main(int argc, char* argv[])\n{\n  int i, i2;\n  int len = 2560;\n  double sum =0.0, sum2=0.0;\n  double a[len], b[len];\n  \n  for (i=0; i<len; i++)\n  {\n    a[i]= ((double)i)/2.0;\n    b[i]= ((double)i)/3.0;\n  }\n\n#pragma omp target map(to: a[0:len], b[0:len]) map(tofrom: sum)\n#pragma omp teams num_teams(10) thread_limit(256) reduction (+:sum) \n#pragma omp distribute\n  for (i2=0; i2< len; i2+=256)  \n#pragma omp parallel for reduction (+:sum)\n    for (i=i2;i< min(i2+256, len); i++)\n      sum += a[i]*b[i];\n\n  \n#pragma omp parallel for reduction (+:sum2)\n    for (i=0;i< len; i++)\n      sum2 += a[i]*b[i];\n  printf (\"sum=%f sum2=%f\\n\", sum, sum2);\n  return 0;\n}\n",
        "code_len": 726,
        "data_race_label": "N2",
        "var_pairs": []
    },
    {
        "ID": "098",
        "name": "DRB098-simd2-orig-no.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n#include <stdio.h>\n/*\nTwo-dimension array computation with a vectorization directive\ncollapse(2) makes simd associate with 2 loops.\nLoop iteration variables should be predetermined as lastprivate. \n*/\nint main()\n{\n  int len=100;\n  double a[len][len], b[len][len], c[len][len];\n  int i,j;\n\n  for (i=0;i<len;i++)\n    for (j=0;j<len;j++)\n    {\n      a[i][j]=((double)i)/2.0; \n      b[i][j]=((double)i)/3.0; \n      c[i][j]=((double)i)/7.0; \n    }\n\n#pragma omp simd collapse(2)\n  for (i=0;i<len;i++)\n    for (j=0;j<len;j++)\n      c[i][j]=a[i][j]*b[i][j];\n\n  printf (\"c[50][50]=%f\\n\",c[50][50]);\n  return 0;\n}\n",
        "data_race": 0,
        "trimmed_code": "#include <stdio.h>\n\nint main()\n{\n  int len=100;\n  double a[len][len], b[len][len], c[len][len];\n  int i,j;\n\n  for (i=0;i<len;i++)\n    for (j=0;j<len;j++)\n    {\n      a[i][j]=((double)i)/2.0; \n      b[i][j]=((double)i)/3.0; \n      c[i][j]=((double)i)/7.0; \n    }\n\n#pragma omp simd collapse(2)\n  for (i=0;i<len;i++)\n    for (j=0;j<len;j++)\n      c[i][j]=a[i][j]*b[i][j];\n\n  printf (\"c[50][50]=%f\\n\",c[50][50]);\n  return 0;\n}\n",
        "code_len": 423,
        "data_race_label": "N1,N2",
        "var_pairs": []
    },
    {
        "ID": "099",
        "name": "DRB099-targetparallelfor2-orig-no.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n#include <stdio.h>\n/*\nuse of omp target + map + array sections derived from pointers\n*/\nvoid foo (double* a, double* b, int N)\n{\n  int i; \n#pragma omp target map(to:a[0:N]) map(from:b[0:N])\n#pragma omp parallel for\n  for (i=0;i< N ;i++)\n    b[i]=a[i]*(double)i;\n}\n\nint main(int argc, char* argv[])\n{\n  int i;\n  int len = 1000;\n  double a[len], b[len];\n  for (i=0; i<len; i++)\n  {\n    a[i]= ((double)i)/2.0;\n    b[i]=0.0;\n  }\n\n  foo(a, b, len);\n\n  printf(\"b[50]=%f\\n\",b[50]);\n  return 0;\n}\n",
        "data_race": 0,
        "trimmed_code": "#include <stdio.h>\n\nvoid foo (double* a, double* b, int N)\n{\n  int i; \n#pragma omp target map(to:a[0:N]) map(from:b[0:N])\n#pragma omp parallel for\n  for (i=0;i< N ;i++)\n    b[i]=a[i]*(double)i;\n}\n\nint main(int argc, char* argv[])\n{\n  int i;\n  int len = 1000;\n  double a[len], b[len];\n  for (i=0; i<len; i++)\n  {\n    a[i]= ((double)i)/2.0;\n    b[i]=0.0;\n  }\n\n  foo(a, b, len);\n\n  printf(\"b[50]=%f\\n\",b[50]);\n  return 0;\n}\n",
        "code_len": 421,
        "data_race_label": "N1,N5",
        "var_pairs": []
    },
    {
        "ID": "100",
        "name": "DRB100-task-reference-orig-no.cpp",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n/*\n * Cover the implicitly determined rule: In an orphaned task generating construct, \n * formal arguments passed by reference are firstprivate.\n * This requires OpenMP 4.5 to work. \n * Earlier OpenMP does not allow a reference type for a variable within firstprivate(). \n * */\n#if (_OPENMP<201511)\n#error \"OpenMP 4.5 compilers (e.g. GCC 6.x or later ) are needed to compile this test.\"\n#endif\n\n#include <stdio.h>\n#define MYLEN 100\nint a[MYLEN];\n\nvoid gen_task(int& i)\n{\n#pragma omp task\n  {\n    a[i]= i+1;\n  }\n}\n\nint main()\n{\n  int i=0;\n#pragma omp parallel\n  {\n#pragma omp single\n    {\n      for (i=0; i<MYLEN; i++)\n      {\n        gen_task(i);\n      }\n    }\n  }\n  \n  /* correctness checking */\n  for (i=0; i<MYLEN; i++)\n  {\n    //assert (a[i]==i+1);\n    if (a[i]!= i+1)\n    {\n      printf(\"warning: a[%d] = %d, not expected %d\\n\", i, a[i], i+1);\n    }\n  }\n  return 0;\n}\n\n",
        "data_race": 0,
        "trimmed_code": "#if (_OPENMP<201511)\n#error \"OpenMP 4.5 compilers (e.g. GCC 6.x or later ) are needed to compile this test.\"\n#endif\n\n#include <stdio.h>\n#define MYLEN 100\nint a[MYLEN];\n\nvoid gen_task(int& i)\n{\n#pragma omp task\n  {\n    a[i]= i+1;\n  }\n}\n\nint main()\n{\n  int i=0;\n#pragma omp parallel\n  {\n#pragma omp single\n    {\n      for (i=0; i<MYLEN; i++)\n      {\n        gen_task(i);\n      }\n    }\n  }\n  \n  \n  for (i=0; i<MYLEN; i++)\n  {\n    \n    if (a[i]!= i+1)\n    {\n      printf(\"warning: a[%d] = %d, not expected %d\\n\", i, a[i], i+1);\n    }\n  }\n  return 0;\n}\n\n",
        "code_len": 549,
        "data_race_label": "N1",
        "var_pairs": []
    },
    {
        "ID": "101",
        "name": "DRB101-task-value-orig-no.cpp",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/*\n * Cover an implicitly determined rule: In a task generating construct, \n * a variable without applicable rules is firstprivate.\n * */\n#include <stdio.h>\n\n#define MYLEN 100\nint a[MYLEN];\n\nvoid gen_task(int i)\n{\n#pragma omp task\n  {\n    a[i]= i+1;\n  }\n}\n\nint main()\n{\n  int i=0;\n#pragma omp parallel\n  {\n#pragma omp single\n    {\n      for (i=0; i<MYLEN; i++)\n      {\n        gen_task(i);\n      }\n    }\n  }\n  \n  /* correctness checking */\n  for (i=0; i<MYLEN; i++)\n  {\n    //assert (a[i]==i+1);\n    if (a[i]!= i+1)\n    {\n      printf(\"warning: a[%d] = %d, not expected %d\\n\", i, a[i], i+1);\n    }\n  }\n  return 0;\n}\n\n",
        "data_race": 0,
        "trimmed_code": "#include <stdio.h>\n\n#define MYLEN 100\nint a[MYLEN];\n\nvoid gen_task(int i)\n{\n#pragma omp task\n  {\n    a[i]= i+1;\n  }\n}\n\nint main()\n{\n  int i=0;\n#pragma omp parallel\n  {\n#pragma omp single\n    {\n      for (i=0; i<MYLEN; i++)\n      {\n        gen_task(i);\n      }\n    }\n  }\n  \n  \n  for (i=0; i<MYLEN; i++)\n  {\n    \n    if (a[i]!= i+1)\n    {\n      printf(\"warning: a[%d] = %d, not expected %d\\n\", i, a[i], i+1);\n    }\n  }\n  return 0;\n}\n\n",
        "code_len": 432,
        "data_race_label": "N1",
        "var_pairs": []
    },
    {
        "ID": "102",
        "name": "DRB102-copyprivate-orig-no.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/*\n *  threadprivate+copyprivate: no data races\n*/\n#include <stdio.h>\n \nfloat x=0.0;\nint y=0;\n#pragma omp threadprivate(x,y)\n\nint main (int argc, char * argv[])\n{\n#pragma omp parallel\n  {\n#pragma omp single copyprivate(x,y)\n    {\n      x=1.0;\n      y=1;\n    }\n  }\n  printf (\"x=%f y=%d\\n\", x, y);\n  return 0;\n}\n",
        "data_race": 0,
        "trimmed_code": "#include <stdio.h>\n \nfloat x=0.0;\nint y=0;\n#pragma omp threadprivate(x,y)\n\nint main (int argc, char * argv[])\n{\n#pragma omp parallel\n  {\n#pragma omp single copyprivate(x,y)\n    {\n      x=1.0;\n      y=1;\n    }\n  }\n  printf (\"x=%f y=%d\\n\", x, y);\n  return 0;\n}\n",
        "code_len": 259,
        "data_race_label": "N2",
        "var_pairs": []
    },
    {
        "ID": "103",
        "name": "DRB103-master-orig-no.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/*\nA master directive is used to protect memory accesses.\n*/\n#include <omp.h>\n#include <stdio.h>\n\nint main()\n{\n  int k;\n\n#pragma omp parallel\n  {\n#pragma omp master\n    {\n      k = omp_get_num_threads();\n      printf (\"Number of Threads requested = %i\\n\",k);\n    }\n  }\n  return 0;\n}\n",
        "data_race": 0,
        "trimmed_code": "#include <omp.h>\n#include <stdio.h>\n\nint main()\n{\n  int k;\n\n#pragma omp parallel\n  {\n#pragma omp master\n    {\n      k = omp_get_num_threads();\n      printf (\"Number of Threads requested = %i\\n\",k);\n    }\n  }\n  return 0;\n}\n",
        "code_len": 222,
        "data_race_label": "N1",
        "var_pairs": []
    },
    {
        "ID": "104",
        "name": "DRB104-nowait-barrier-orig-no.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/*\nThis example is based on one code snippet extracted from a paper: \nMa etc. Symbolic Analysis of Concurrency Errors in OpenMP Programs, ICPP 2013\n\nExplicit barrier to counteract nowait\n*/\n#include <stdio.h>\n#include <assert.h>\nint main()\n{\n  int i,error;\n  int len = 1000;\n  int a[len], b=5;\n\n  for (i=0; i<len; i++)\n    a[i]= i;\n \n#pragma omp parallel shared(b, error) \n  {\n#pragma omp for nowait\n    for(i = 0; i < len; i++)\n      a[i] = b + a[i]*5;\n\n#pragma omp barrier\n\n#pragma omp single\n    error = a[9] + 1;\n  }\n  assert (error == 51);\n  printf (\"error = %d\\n\", error);\n  return 0;\n}  \n",
        "data_race": 0,
        "trimmed_code": "#include <stdio.h>\n#include <assert.h>\nint main()\n{\n  int i,error;\n  int len = 1000;\n  int a[len], b=5;\n\n  for (i=0; i<len; i++)\n    a[i]= i;\n \n#pragma omp parallel shared(b, error) \n  {\n#pragma omp for nowait\n    for(i = 0; i < len; i++)\n      a[i] = b + a[i]*5;\n\n#pragma omp barrier\n\n#pragma omp single\n    error = a[9] + 1;\n  }\n  assert (error == 51);\n  printf (\"error = %d\\n\", error);\n  return 0;\n}  \n",
        "code_len": 405,
        "data_race_label": "N3",
        "var_pairs": []
    },
    {
        "ID": "105",
        "name": "DRB105-taskwait-orig-no.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/* This is a program based on a test contributed by Yizi Gu@Rice Univ.\n * Classic Fibonacci calculation using task+taskwait. No data races.  \n * */\n#include <stdio.h>\n#include <assert.h>\nunsigned int input = 30;\nint fib(unsigned int n)\n{\n  if (n<2)\n    return n;\n  else\n  {\n    int i, j;\n#pragma omp task shared(i)\n    i=fib(n-1);\n#pragma omp task shared(j)\n    j=fib(n-2);\n#pragma omp taskwait\n    return i+j;\n  }\n}\nint main()\n{\n  int result = 0;\n#pragma omp parallel\n  {\n   #pragma omp single\n    {\n      result = fib(input);\n    }\n  }\n  printf (\"Fib(%d)=%d\\n\", input, result);\n  assert (result==832040);\n  return 0;\n}\n",
        "data_race": 0,
        "trimmed_code": "#include <stdio.h>\n#include <assert.h>\nunsigned int input = 30;\nint fib(unsigned int n)\n{\n  if (n<2)\n    return n;\n  else\n  {\n    int i, j;\n#pragma omp task shared(i)\n    i=fib(n-1);\n#pragma omp task shared(j)\n    j=fib(n-2);\n#pragma omp taskwait\n    return i+j;\n  }\n}\nint main()\n{\n  int result = 0;\n#pragma omp parallel\n  {\n   #pragma omp single\n    {\n      result = fib(input);\n    }\n  }\n  printf (\"Fib(%d)=%d\\n\", input, result);\n  assert (result==832040);\n  return 0;\n}\n",
        "code_len": 473,
        "data_race_label": "N3",
        "var_pairs": []
    },
    {
        "ID": "106",
        "name": "DRB106-taskwaitmissing-orig-yes.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n#include <stdio.h>\n/* This is a program based on a test contributed by Yizi Gu@Rice Univ.\n * Classic Fibonacci calculation using task but missing taskwait. \n * Data races pairs: i@61:5:W vs. i@65:14:R\n *                   j@63:5:W vs. j@65:16:R\n * */\nunsigned int input = 10;\nint fib(unsigned int n)\n{\n  if (n<2)\n    return n;\n  else\n  {\n    int i, j;\n#pragma omp task shared(i)\n    i=fib(n-1);\n#pragma omp task shared(j)\n    j=fib(n-2);\n\n    int res= i+j; \n/* We move the original taskwait to a location after i+j to \n * simulate the missing taskwait mistake.\n * Directly removing the taskwait may cause a child task to write to i or j\n * within the stack of a parent task which may already be gone, causing seg fault.\n * This change is suggested by Joachim Protze @RWTH-Aachen. \n * */\n#pragma omp taskwait\n    return res;\n  }\n}\nint main()\n{\n  int result = 0;\n#pragma omp parallel\n  {\n   #pragma omp single\n    {\n      result = fib(input);\n    }\n  }\n  printf (\"Fib(%d)=%d (correct answer should be 55)\\n\", input, result);\n  return 0;\n}\n",
        "data_race": 1,
        "trimmed_code": "#include <stdio.h>\n\nunsigned int input = 10;\nint fib(unsigned int n)\n{\n  if (n<2)\n    return n;\n  else\n  {\n    int i, j;\n#pragma omp task shared(i)\n    i=fib(n-1);\n#pragma omp task shared(j)\n    j=fib(n-2);\n\n    int res= i+j; \n\n#pragma omp taskwait\n    return res;\n  }\n}\nint main()\n{\n  int result = 0;\n#pragma omp parallel\n  {\n   #pragma omp single\n    {\n      result = fib(input);\n    }\n  }\n  printf (\"Fib(%d)=%d (correct answer should be 55)\\n\", input, result);\n  return 0;\n}\n",
        "code_len": 478,
        "data_race_label": "Y3",
        "var_pairs": [
            {
                "name": [
                    "i",
                    "i"
                ],
                "line": [
                    61,
                    65
                ],
                "col": [
                    5,
                    14
                ],
                "operation": [
                    "W",
                    "R"
                ]
            },
            {
                "name": [
                    "j",
                    "j"
                ],
                "line": [
                    63,
                    65
                ],
                "col": [
                    5,
                    16
                ],
                "operation": [
                    "W",
                    "R"
                ]
            }
        ]
    },
    {
        "ID": "107",
        "name": "DRB107-taskgroup-orig-no.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/* This is a program based on a test contributed by Yizi Gu@Rice Univ.\n * Use taskgroup to synchronize two tasks: \n * */\n#include <stdio.h>\n#include <assert.h>\n#include <unistd.h>\n\nint main()\n{\n  int result = 0;\n#pragma omp parallel\n  {\n#pragma omp single\n    {\n#pragma omp taskgroup\n      {\n#pragma omp task\n        {\n          sleep(3);\n          result = 1; \n        }\n      }\n#pragma omp task\n      {\n        result = 2; \n      }\n    }\n  }\n  printf (\"result=%d\\n\", result);\n  assert (result==2);\n  return 0;\n}\n",
        "data_race": 0,
        "trimmed_code": "#include <stdio.h>\n#include <assert.h>\n#include <unistd.h>\n\nint main()\n{\n  int result = 0;\n#pragma omp parallel\n  {\n#pragma omp single\n    {\n#pragma omp taskgroup\n      {\n#pragma omp task\n        {\n          sleep(3);\n          result = 1; \n        }\n      }\n#pragma omp task\n      {\n        result = 2; \n      }\n    }\n  }\n  printf (\"result=%d\\n\", result);\n  assert (result==2);\n  return 0;\n}\n",
        "code_len": 393,
        "data_race_label": "N3",
        "var_pairs": []
    },
    {
        "ID": "108",
        "name": "DRB108-atomic-orig-no.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n#include <stdio.h>\n/*\n * Test if atomic can be recognized properly. No data races.\n * */\nint main (void)\n{\n  int a=0;\n#pragma omp parallel \n  {\n#pragma omp atomic\n    a+=1;\n  }\n  printf (\"a=%d\\n\",a);\n  return 0;\n}\n\n",
        "data_race": 0,
        "trimmed_code": "#include <stdio.h>\n\nint main (void)\n{\n  int a=0;\n#pragma omp parallel \n  {\n#pragma omp atomic\n    a+=1;\n  }\n  printf (\"a=%d\\n\",a);\n  return 0;\n}\n\n",
        "code_len": 146,
        "data_race_label": "N3",
        "var_pairs": []
    },
    {
        "ID": "109",
        "name": "DRB109-orderedmissing-orig-yes.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n#include <stdio.h>\n/* This is a program based on a test contributed by Yizi Gu@Rice Univ.\n * Missing the ordered clause\n * Data race pair: x@56:5:W vs. x@56:5:W\n * */\nint main()\n{\n  int x =0;\n#pragma omp parallel for ordered \n  for (int i = 0; i < 100; ++i) {\n    x++;\n  }\n  printf (\"x=%d\\n\",x);\n  return 0;\n} \n",
        "data_race": 1,
        "trimmed_code": "#include <stdio.h>\n\nint main()\n{\n  int x =0;\n#pragma omp parallel for ordered \n  for (int i = 0; i < 100; ++i) {\n    x++;\n  }\n  printf (\"x=%d\\n\",x);\n  return 0;\n} \n",
        "code_len": 164,
        "data_race_label": "Y3",
        "var_pairs": [
            "{\"name\": [\"x\", \"x\"],\n\"line\": [56, 56],\n\"col\": [5, 5],\n\"operation\": [\"W\", \"W\"]}"
        ]
    },
    {
        "ID": "110",
        "name": "DRB110-ordered-orig-no.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n#include <assert.h> \n#include <stdio.h>\n/* This is a program based on a test contributed by Yizi Gu@Rice Univ.\n * Proper user of ordered directive and clause, no data races\n * */\nint main()\n{\n  int x =0;\n#pragma omp parallel for ordered \n  for (int i = 0; i < 100; ++i) {\n#pragma omp ordered\n    {\n      x++;\n    }\n  }\n  assert (x==100);\n  printf (\"x=%d\\n\",x);\n  return 0;\n} \n",
        "data_race": 0,
        "trimmed_code": "#include <assert.h> \n#include <stdio.h>\n\nint main()\n{\n  int x =0;\n#pragma omp parallel for ordered \n  for (int i = 0; i < 100; ++i) {\n#pragma omp ordered\n    {\n      x++;\n    }\n  }\n  assert (x==100);\n  printf (\"x=%d\\n\",x);\n  return 0;\n} \n",
        "code_len": 238,
        "data_race_label": "N3",
        "var_pairs": []
    },
    {
        "ID": "111",
        "name": "DRB111-linearmissing-orig-yes.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n#include <stdio.h>\n/*\n *  loop missing the linear clause\n *  Data race pairs (race on j allows wrong indexing of c):  \n     j@70:7:R vs. j@71:5:W\n     j@71:5:W vs. j@71:5:W \n     c[j]@70:5:W vs. c[j]@70:5:W\n*/\nint main()\n{\n  int len=100;\n  double a[len], b[len], c[len];\n  int i,j=0;\n\n  for (i=0;i<len;i++)\n  {\n    a[i]=((double)i)/2.0; \n    b[i]=((double)i)/3.0; \n    c[i]=((double)i)/7.0; \n  }\n\n#pragma omp parallel for \n  for (i=0;i<len;i++)\n  {\n    c[j]+=a[i]*b[i];\n    j++;\n  }\n\n  printf (\"c[50]=%f\\n\",c[50]);\n  return 0;\n}\n",
        "data_race": 1,
        "trimmed_code": "#include <stdio.h>\n\nint main()\n{\n  int len=100;\n  double a[len], b[len], c[len];\n  int i,j=0;\n\n  for (i=0;i<len;i++)\n  {\n    a[i]=((double)i)/2.0; \n    b[i]=((double)i)/3.0; \n    c[i]=((double)i)/7.0; \n  }\n\n#pragma omp parallel for \n  for (i=0;i<len;i++)\n  {\n    c[j]+=a[i]*b[i];\n    j++;\n  }\n\n  printf (\"c[50]=%f\\n\",c[50]);\n  return 0;\n}\n",
        "code_len": 339,
        "data_race_label": "Y2",
        "var_pairs": [
            "{\"name\": [\"j\", \"c\"],\n\"line\": [],\n\"col\": [],\n\"operation\": []}"
        ]
    },
    {
        "ID": "112",
        "name": "DRB112-linear-orig-no.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n/*\n   omp for loop is allowed to use the linear clause, an OpenMP 4.5 addition.\n*/\n#if (_OPENMP<201511)\n#error \"An OpenMP 4.5 compiler is needed to compile this test.\"\n#endif\n#include <stdio.h>\nint main()\n{\n  int len=100;\n  double a[len], b[len], c[len];\n  int i,j=0;\n\n  for (i=0;i<len;i++)\n  {\n    a[i]=((double)i)/2.0; \n    b[i]=((double)i)/3.0; \n    c[i]=((double)i)/7.0; \n  }\n\n#pragma omp parallel for linear(j)\n  for (i=0;i<len;i++)\n  {\n    c[j]+=a[i]*b[i];\n    j++;\n  }\n\n  printf (\"c[50]=%f\\n\",c[50]);\n  return 0;\n}\n",
        "data_race": 0,
        "trimmed_code": "#if (_OPENMP<201511)\n#error \"An OpenMP 4.5 compiler is needed to compile this test.\"\n#endif\n#include <stdio.h>\nint main()\n{\n  int len=100;\n  double a[len], b[len], c[len];\n  int i,j=0;\n\n  for (i=0;i<len;i++)\n  {\n    a[i]=((double)i)/2.0; \n    b[i]=((double)i)/3.0; \n    c[i]=((double)i)/7.0; \n  }\n\n#pragma omp parallel for linear(j)\n  for (i=0;i<len;i++)\n  {\n    c[j]+=a[i]*b[i];\n    j++;\n  }\n\n  printf (\"c[50]=%f\\n\",c[50]);\n  return 0;\n}\n",
        "code_len": 439,
        "data_race_label": "N2",
        "var_pairs": []
    },
    {
        "ID": "113",
        "name": "DRB113-default-orig-no.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/* \nTwo-dimensional array computation:\ndefault(none) to enforce explicitly list all variables in data-sharing attribute clauses\ndefault(shared) to cover another option.\n*/\n\nint a[100][100];\nint b[100][100];\nint main()\n{\n  int i,j;\n#pragma omp parallel for default(none) shared(a) private(i,j)\n  for (i=0;i<100;i++)\n    for (j=0;j<100;j++)\n      a[i][j]=a[i][j]+1;\n\n#pragma omp parallel for default(shared) private(i,j)\n  for (i=0;i<100;i++)\n    for (j=0;j<100;j++)\n      b[i][j]=b[i][j]+1;\n\n  return 0;\n}\n\n",
        "data_race": 0,
        "trimmed_code": "int a[100][100];\nint b[100][100];\nint main()\n{\n  int i,j;\n#pragma omp parallel for default(none) shared(a) private(i,j)\n  for (i=0;i<100;i++)\n    for (j=0;j<100;j++)\n      a[i][j]=a[i][j]+1;\n\n#pragma omp parallel for default(shared) private(i,j)\n  for (i=0;i<100;i++)\n    for (j=0;j<100;j++)\n      b[i][j]=b[i][j]+1;\n\n  return 0;\n}\n\n",
        "code_len": 333,
        "data_race_label": "N1",
        "var_pairs": []
    },
    {
        "ID": "114",
        "name": "DRB114-if-orig-yes.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/* \nWhen if() evaluates to true, this program has data races due to true dependence within the loop at 65.\nData race pair: a[i+1]@66:5:W vs. a[i]@66:12:R\n*/\n#include <stdlib.h>\n#include <stdio.h>\n#include <time.h>\nint main(int argc, char* argv[])\n{\n  int i;\n  int len=100;\n  int a[100];\n\n  for (i=0;i<len;i++)\n    a[i]=i;\n   \n  srand(time(NULL));\n#pragma omp parallel for if (rand()%2)\n  for (i=0;i<len-1;i++)\n    a[i+1]=a[i]+1;\n\n  printf(\"a[50]=%d\\n\", a[50]);   \n  return 0;\n}\n",
        "data_race": 1,
        "trimmed_code": "#include <stdlib.h>\n#include <stdio.h>\n#include <time.h>\nint main(int argc, char* argv[])\n{\n  int i;\n  int len=100;\n  int a[100];\n\n  for (i=0;i<len;i++)\n    a[i]=i;\n   \n  srand(time(NULL));\n#pragma omp parallel for if (rand()%2)\n  for (i=0;i<len-1;i++)\n    a[i+1]=a[i]+1;\n\n  printf(\"a[50]=%d\\n\", a[50]);   \n  return 0;\n}\n",
        "code_len": 321,
        "data_race_label": "Y1",
        "var_pairs": [
            "{\"name\": [\"a[i+1]\", \"a[i]\"],\n\"line\": [66, 66],\n\"col\": [5, 12],\n\"operation\": [\"W\", \"R\"]}"
        ]
    },
    {
        "ID": "115",
        "name": "DRB115-forsimd-orig-yes.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n/* \nThis one has data races due to true dependence. \nBut data races happen at both instruction and thread level. \nData race pair: a[i+1]@66:5:W vs. a[i]@66:12:R\n*/\n#include <stdio.h>\nint main(int argc, char* argv[])\n{\n  int i;\n  int len=100;\n  int a[100], b[100];\n\n  for (i=0;i<len;i++)\n  {\n    a[i]=i;\n    b[i]=i+1;\n  }\n\n#pragma omp parallel for simd \n  for (i=0;i<len-1;i++)\n    a[i+1]=a[i]+b[i];\n\n  printf(\"a[50]=%d\\n\",a[50]);\n  return 0;\n}\n",
        "data_race": 1,
        "trimmed_code": "#include <stdio.h>\nint main(int argc, char* argv[])\n{\n  int i;\n  int len=100;\n  int a[100], b[100];\n\n  for (i=0;i<len;i++)\n  {\n    a[i]=i;\n    b[i]=i+1;\n  }\n\n#pragma omp parallel for simd \n  for (i=0;i<len-1;i++)\n    a[i+1]=a[i]+b[i];\n\n  printf(\"a[50]=%d\\n\",a[50]);\n  return 0;\n}\n",
        "code_len": 280,
        "data_race_label": "Y1,Y4",
        "var_pairs": [
            "{\"name\": [\"a[i+1]\", \"a[i]\"],\n\"line\": [66, 66],\n\"col\": [5, 12],\n\"operation\": [\"W\", \"R\"]}"
        ]
    },
    {
        "ID": "116",
        "name": "DRB116-target-teams-orig-yes.c",
        "DRB_code": "/*\nCopyright (c) 2017, Lawrence Livermore National Security, LLC.\nProduced at the Lawrence Livermore National Laboratory\nWritten by Chunhua Liao, Pei-Hung Lin, Joshua Asplund,\nMarkus Schordan, and Ian Karlin\n(email: liao6@llnl.gov, lin32@llnl.gov, asplund1@llnl.gov,\nschordan1@llnl.gov, karlin1@llnl.gov)\nLLNL-CODE-732144\nAll rights reserved.\n\nThis file is part of DataRaceBench. For details, see\nhttps://github.com/LLNL/dataracebench. Please also see the LICENSE file\nfor our additional BSD notice.\n\nRedistribution and use in source and binary forms, with\nor without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the disclaimer below.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the disclaimer (as noted below)\n  in the documentation and/or other materials provided with the\n  distribution.\n\n* Neither the name of the LLNS/LLNL nor the names of its contributors\n  may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL\nSECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n*/\n#include <stdio.h>\n\n/*\nuse of omp target + teams \nWithout protection, master threads from two teams cause data races.\nData race pair: a@66:5:W vs. a@66:5:W\n*/\nint main(int argc, char* argv[])\n{\n  int i;\n  int len = 100;\n  double a[len];\n\n  /*Initialize with some values*/\n  for (i=0; i<len; i++)\n    a[i]= ((double)i)/2.0;\n\n#pragma omp target map(tofrom: a[0:len]) \n#pragma omp teams num_teams(2) \n  {\n    a[50]*=2.0;\n  }\n\n  printf (\"a[50]=%f\\n\", a[50]);\n  return 0;\n}\n",
        "data_race": 1,
        "trimmed_code": "#include <stdio.h>\n\n\nint main(int argc, char* argv[])\n{\n  int i;\n  int len = 100;\n  double a[len];\n\n  \n  for (i=0; i<len; i++)\n    a[i]= ((double)i)/2.0;\n\n#pragma omp target map(tofrom: a[0:len]) \n#pragma omp teams num_teams(2) \n  {\n    a[50]*=2.0;\n  }\n\n  printf (\"a[50]=%f\\n\", a[50]);\n  return 0;\n}\n",
        "code_len": 300,
        "data_race_label": "Y3",
        "var_pairs": [
            "{\"name\": [\"a\", \"a\"],\n\"line\": [66, 66],\n\"col\": [5, 5],\n\"operation\": [\"W\", \"W\"]}"
        ]
    },
    {
        "ID": "117",
        "name": "DRB117-taskwait-waitonlychild-orig-yes.c",
        "DRB_code": "/*\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n!!! Copyright (c) 2017-20, Lawrence Livermore National Security, LLC\n!!! and DataRaceBench project contributors. See the DataRaceBench/COPYRIGHT file for details.\n!!!\n!!! SPDX-License-Identifier: (BSD-3-Clause)\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n*/\n\n/*\nThe thread encountering the taskwait directive at line 46 only waits for\nits child task (line 37-44) to complete. It does not wait for its\ndescendant tasks (line 39-42).\nData Race Pairs, sum@47:7:W vs. sum@47:7:W\n*/\n\n#include <stdio.h>\n#include <stdlib.h>\n\nint main(){\n\n  int a[4];\n  int psum[2];\n  int sum;\n\n  #pragma omp parallel num_threads(2)\n  {\n    #pragma omp for schedule(dynamic, 1)\n    for (int i=0; i < 4; ++i){\n      a[i] = i;\n      int s;\n      s = (- 3 - 3) / - 3;\n    }\n\n    #pragma omp single\n    {\n      #pragma omp task\n      {\n       #pragma omp task\n       {\n         psum[1] = a[2] + a[3];\n       }\n        psum[0] = a[0] + a[1];\n      }\n\n      #pragma omp taskwait\n      sum = psum[1] + psum[0];\n    }\n  }\n\n  printf(\"sum = %d\\n\", sum);\n  return 0;\n }\n",
        "data_race": 1,
        "trimmed_code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main(){\n\n  int a[4];\n  int psum[2];\n  int sum;\n\n  #pragma omp parallel num_threads(2)\n  {\n    #pragma omp for schedule(dynamic, 1)\n    for (int i=0; i < 4; ++i){\n      a[i] = i;\n      int s;\n      s = (- 3 - 3) / - 3;\n    }\n\n    #pragma omp single\n    {\n      #pragma omp task\n      {\n       #pragma omp task\n       {\n         psum[1] = a[2] + a[3];\n       }\n        psum[0] = a[0] + a[1];\n      }\n\n      #pragma omp taskwait\n      sum = psum[1] + psum[0];\n    }\n  }\n\n  printf(\"sum = %d\\n\", sum);\n  return 0;\n }\n",
        "code_len": 556,
        "data_race_label": "Y3",
        "var_pairs": [
            "{\"name\": [\"sum\", \"sum\"],\n\"line\": [47, 47],\n\"col\": [7, 7],\n\"operation\": [\"W\", \"W\"]}"
        ]
    },
    {
        "ID": "118",
        "name": "DRB118-nestlock-orig-no.c",
        "DRB_code": "/*\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n!!! Copyright (c) 2017-20, Lawrence Livermore National Security, LLC\n!!! and DataRaceBench project contributors. See the DataRaceBench/COPYRIGHT file for details.\n!!!\n!!! SPDX-License-Identifier: (BSD-3-Clause)\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n*/\n\n/* This example is modified version of nestable_lock.1.c example, OpenMP 5.0 Application Programming Examples.\nA nested lock can be locked several times. It doesn't unlock until you have unset\nit as many times as the number of calls to omp_set_nest_lock.\nincr_b is called at line 47 and line 52. So, it needs a nest_lock for p->b@30:4.\n*/\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n  int a, b;\n  omp_nest_lock_t lck;\n} pair;\n\nvoid incr_a(pair *p){\n  p->a += 1;\n}\nvoid incr_b(pair *p){\n  omp_set_nest_lock(&p->lck);\n    p->b += 1;\n  omp_unset_nest_lock(&p->lck);\n}\n\n\nint main(int argc, char* argv[])\n{\n  pair p[1];\n  p->a = 0;\n  p->b = 0;\n  omp_init_nest_lock(&p->lck);\n\n  #pragma omp parallel sections\n  {\n    #pragma omp section\n    {\n      omp_set_nest_lock(&p->lck);\n      incr_b(p);\n      incr_a(p);\n      omp_unset_nest_lock(&p->lck);\n    }\n    #pragma omp section\n      incr_b(p);\n  }\n\n  omp_destroy_nest_lock(&p->lck);\n\n  printf(\"%d\\n\",p->b);\n  return 0;\n}\n",
        "data_race": 0,
        "trimmed_code": "#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n  int a, b;\n  omp_nest_lock_t lck;\n} pair;\n\nvoid incr_a(pair *p){\n  p->a += 1;\n}\nvoid incr_b(pair *p){\n  omp_set_nest_lock(&p->lck);\n    p->b += 1;\n  omp_unset_nest_lock(&p->lck);\n}\n\n\nint main(int argc, char* argv[])\n{\n  pair p[1];\n  p->a = 0;\n  p->b = 0;\n  omp_init_nest_lock(&p->lck);\n\n  #pragma omp parallel sections\n  {\n    #pragma omp section\n    {\n      omp_set_nest_lock(&p->lck);\n      incr_b(p);\n      incr_a(p);\n      omp_unset_nest_lock(&p->lck);\n    }\n    #pragma omp section\n      incr_b(p);\n  }\n\n  omp_destroy_nest_lock(&p->lck);\n\n  printf(\"%d\\n\",p->b);\n  return 0;\n}\n",
        "code_len": 656,
        "data_race_label": "N3",
        "var_pairs": []
    },
    {
        "ID": "119",
        "name": "DRB119-nestlock-orig-yes.c",
        "DRB_code": "/*\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n!!! Copyright (c) 2017-20, Lawrence Livermore National Security, LLC\n!!! and DataRaceBench project contributors. See the DataRaceBench/COPYRIGHT file for details.\n!!!\n!!! SPDX-License-Identifier: (BSD-3-Clause)\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n*/\n\n/*\nA nested lock can be locked several times. It doesn't unlock until you have unset\nit as many times as the number of calls to omp_set_nest_lock.\nincr_b is called at line 48 and line 53. So, it needs a nest_lock enclosing line 32\nMissing nest_lock will lead to race condition at line:32.\nData Race Pairs, p->b@32:6:W vs. p->b@32:6:W\n*/\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n  int a, b;\n  omp_nest_lock_t lck;\n} pair;\n\nvoid incr_a(pair *p){\n  p->a += 1;\n}\n\nvoid incr_b(pair *p){\n  p->b += 1;\n}\n\n\nint main(int argc, char* argv[])\n{\n  pair p[1];\n  p->a = 0;\n  p->b = 0;\n  omp_init_nest_lock(&p->lck);\n\n  #pragma omp parallel sections\n  {\n    #pragma omp section\n    {\n      omp_set_nest_lock(&p->lck);\n      incr_b(p);\n      incr_a(p);\n      omp_unset_nest_lock(&p->lck);\n    }\n    #pragma omp section\n      incr_b(p);\n  }\n\n  omp_destroy_nest_lock(&p->lck);\n\n  printf(\"%d\\n\",p->b);\n  return 0;\n}\n",
        "data_race": 1,
        "trimmed_code": "#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n  int a, b;\n  omp_nest_lock_t lck;\n} pair;\n\nvoid incr_a(pair *p){\n  p->a += 1;\n}\n\nvoid incr_b(pair *p){\n  p->b += 1;\n}\n\n\nint main(int argc, char* argv[])\n{\n  pair p[1];\n  p->a = 0;\n  p->b = 0;\n  omp_init_nest_lock(&p->lck);\n\n  #pragma omp parallel sections\n  {\n    #pragma omp section\n    {\n      omp_set_nest_lock(&p->lck);\n      incr_b(p);\n      incr_a(p);\n      omp_unset_nest_lock(&p->lck);\n    }\n    #pragma omp section\n      incr_b(p);\n  }\n\n  omp_destroy_nest_lock(&p->lck);\n\n  printf(\"%d\\n\",p->b);\n  return 0;\n}\n",
        "code_len": 593,
        "data_race_label": "Y3",
        "var_pairs": [
            "{\"name\": [\"p->b\", \"p->b\"],\n\"line\": [32, 32],\n\"col\": [6, 6],\n\"operation\": [\"W\", \"W\"]}"
        ]
    },
    {
        "ID": "120",
        "name": "DRB120-barrier-orig-no.c",
        "DRB_code": "/*\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n!!! Copyright (c) 2017-20, Lawrence Livermore National Security, LLC\n!!! and DataRaceBench project contributors. See the DataRaceBench/COPYRIGHT file for details.\n!!!\n!!! SPDX-License-Identifier: (BSD-3-Clause)\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n*/\n\n/*\nThe barrier construct specifies an explicit barrier at the point at which the construct appears.\nBarrier construct at line:27 ensures that there is no data race.\n*/\n\n#include <omp.h>\n#include <stdio.h>\n\nint main(int argc, char* argv[])\n{\n  int var = 0;\n\n  #pragma omp parallel shared(var)\n  {\n    #pragma omp single\n    var++;\n\n    #pragma omp barrier\n\n    #pragma omp single\n    var++;\n  }\n\n  if(var != 2) printf(\"%d\\n\",var);\n  int error = (var != 2);\n  return error;\n}\n",
        "data_race": 0,
        "trimmed_code": "#include <omp.h>\n#include <stdio.h>\n\nint main(int argc, char* argv[])\n{\n  int var = 0;\n\n  #pragma omp parallel shared(var)\n  {\n    #pragma omp single\n    var++;\n\n    #pragma omp barrier\n\n    #pragma omp single\n    var++;\n  }\n\n  if(var != 2) printf(\"%d\\n\",var);\n  int error = (var != 2);\n  return error;\n}\n",
        "code_len": 305,
        "data_race_label": "N3",
        "var_pairs": []
    },
    {
        "ID": "121",
        "name": "DRB121-reduction-orig-no.c",
        "DRB_code": "/*\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n!!! Copyright (c) 2017-20, Lawrence Livermore National Security, LLC\n!!! and DataRaceBench project contributors. See the DataRaceBench/COPYRIGHT file for details.\n!!!\n!!! SPDX-License-Identifier: (BSD-3-Clause)\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n*/\n\n/*\nNumber of threads is empirical: We need enough threads so that\nthe reduction is really performed hierarchically in the barrier!\nThere is no data race.\n*/\n\n\n#include <omp.h>\n#include <stdio.h>\n\nint main(int argc, char* argv[])\n{\n  int var = 0, i, res;\n  int sum1 = 0;\n  int sum2 = 0;\n\n  res = omp_get_max_threads();\n\n  #pragma omp parallel reduction(+: var)\n  {\n    #pragma omp for schedule(static) reduction(+: sum1)\n    for (i=0; i<5; i++)\n    sum1+=i;\n    #pragma omp for schedule(static) reduction(+: sum2)\n    for (i=0; i<5; i++)\n    sum2+=i;\n\n    var = sum1 + sum2;\n  }\n\n  int error = (var != 20*res);\n  if (error) printf(\"%d %d\\n\",var,20*res);\n  return error;\n}\n",
        "data_race": 0,
        "trimmed_code": "#include <omp.h>\n#include <stdio.h>\n\nint main(int argc, char* argv[])\n{\n  int var = 0, i, res;\n  int sum1 = 0;\n  int sum2 = 0;\n\n  res = omp_get_max_threads();\n\n  #pragma omp parallel reduction(+: var)\n  {\n    #pragma omp for schedule(static) reduction(+: sum1)\n    for (i=0; i<5; i++)\n    sum1+=i;\n    #pragma omp for schedule(static) reduction(+: sum2)\n    for (i=0; i<5; i++)\n    sum2+=i;\n\n    var = sum1 + sum2;\n  }\n\n  int error = (var != 20*res);\n  if (error) printf(\"%d %d\\n\",var,20*res);\n  return error;\n}\n",
        "code_len": 512,
        "data_race_label": "N2",
        "var_pairs": []
    },
    {
        "ID": "122",
        "name": "DRB122-taskundeferred-orig-no.c",
        "DRB_code": "/*\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n!!! Copyright (c) 2017-20, Lawrence Livermore National Security, LLC\n!!! and DataRaceBench project contributors. See the DataRaceBench/COPYRIGHT file for details.\n!!!\n!!! SPDX-License-Identifier: (BSD-3-Clause)\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n*/\n\n/*\nNo data race. The data environment of the task is created according to the\ndata-sharing attribute clauses, here at line 28 it is var. Hence, var is\nmodified 10 times, resulting to the value 10.\n*/\n\n#include <omp.h>\n#include <stdio.h>\n#include <unistd.h>\n\nint main(int argc, char* argv[])\n{\n  int var = 0;\n  int i;\n\n  #pragma omp parallel sections \n  {\n    for (i = 0; i < 10; i++) {\n      #pragma omp task shared(var) if(0)\n      {\n        var++;\n      }\n    }\n  }\n\n  printf(\"%d\\n\",var);\n  return 0;\n}\n",
        "data_race": 0,
        "trimmed_code": "#include <omp.h>\n#include <stdio.h>\n#include <unistd.h>\n\nint main(int argc, char* argv[])\n{\n  int var = 0;\n  int i;\n\n  #pragma omp parallel sections \n  {\n    for (i = 0; i < 10; i++) {\n      #pragma omp task shared(var) if(0)\n      {\n        var++;\n      }\n    }\n  }\n\n  printf(\"%d\\n\",var);\n  return 0;\n}\n",
        "code_len": 304,
        "data_race_label": "N6",
        "var_pairs": []
    },
    {
        "ID": "123",
        "name": "DRB123-taskundeferred-orig-yes.c",
        "DRB_code": "/*\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n!!! Copyright (c) 2017-20, Lawrence Livermore National Security, LLC\n!!! and DataRaceBench project contributors. See the DataRaceBench/COPYRIGHT file for details.\n!!!\n!!! SPDX-License-Identifier: (BSD-3-Clause)\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n*/\n\n/*\nA single thread will spawn all the tasks. Add if(0) to avoid the data race, undeferring the tasks.\n\nData Race pairs var@30:9:W vs. var@30:9:W\n*/\n\n#include <omp.h>\n#include <stdio.h>\n#include <unistd.h>\n\nint main(int argc, char* argv[])\n{\n  int var = 0;\n  int i;\n\n  #pragma omp parallel sections\n  {\n    for (i = 0; i < 10; i++) {\n      #pragma omp task shared(var)\n      {\n        var++;\n      }\n    }\n  }\n\n  if (var!=10) printf(\"%d\\n\",var);\n  return 0;\n}\n",
        "data_race": 1,
        "trimmed_code": "#include <omp.h>\n#include <stdio.h>\n#include <unistd.h>\n\nint main(int argc, char* argv[])\n{\n  int var = 0;\n  int i;\n\n  #pragma omp parallel sections\n  {\n    for (i = 0; i < 10; i++) {\n      #pragma omp task shared(var)\n      {\n        var++;\n      }\n    }\n  }\n\n  if (var!=10) printf(\"%d\\n\",var);\n  return 0;\n}\n",
        "code_len": 310,
        "data_race_label": "Y6",
        "var_pairs": [
            "{\"name\": [\"var\", \"var\"],\n\"line\": [30, 30],\n\"col\": [9, 9],\n\"operation\": [\"W\", \"W\"]}"
        ]
    },
    {
        "ID": "124",
        "name": "DRB124-master-orig-yes.c",
        "DRB_code": "/*\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n!!! Copyright (c) 2017-20, Lawrence Livermore National Security, LLC\n!!! and DataRaceBench project contributors. See the DataRaceBench/COPYRIGHT file for details.\n!!!\n!!! SPDX-License-Identifier: (BSD-3-Clause)\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n*/\n\n\n/*\nThis example is derived from an example by Simone Atzeni, NVIDIA.\n\nDescription: Race on variable init. The variable is written by the\nmaster thread and concurrently read by the others.\n\nSolution: master construct at line 31:17 does not have an implicit barrier better\nuse single. Data Race Pair, init@33:7:W vs. init@36:13:R\n*/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint main (int argc, char **argv)\n{\n  int init, local;\n\n  #pragma omp parallel shared(init) private(local)\n  {\n    #pragma omp master\n    {\n      init = 10;\n    }\n\n    local = init;\n  }\n\n  return 0;\n}\n\n\n",
        "data_race": 1,
        "trimmed_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint main (int argc, char **argv)\n{\n  int init, local;\n\n  #pragma omp parallel shared(init) private(local)\n  {\n    #pragma omp master\n    {\n      init = 10;\n    }\n\n    local = init;\n  }\n\n  return 0;\n}\n\n\n",
        "code_len": 261,
        "data_race_label": "Y3",
        "var_pairs": [
            "{\"name\": [\"init\", \"init\"],\n\"line\": [33, 36],\n\"col\": [7, 13],\n\"operation\": [\"W\", \"R\"]}"
        ]
    },
    {
        "ID": "125",
        "name": "DRB125-single-orig-no.c",
        "DRB_code": "/*\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n!!! Copyright (c) 2017-20, Lawrence Livermore National Security, LLC\n!!! and DataRaceBench project contributors. See the DataRaceBench/COPYRIGHT file for details.\n!!!\n!!! SPDX-License-Identifier: (BSD-3-Clause)\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n*/\n\n\n/*\nThis example is derived from an example by Simone Atzeni, NVIDIA.\n\nDescription: Race on variable init if used master construct. The variable is written by the\nmaster thread and concurrently read by the others.\n\nSolution: master construct does not have an implicit barrier better\nuse single at line 31. Fixed version for DRB124-master-orig-yes.c. No data race.\n*/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint main (int argc, char **argv)\n{\n  int init, local;\n\n  #pragma omp parallel shared(init) private(local)\n  {\n    #pragma omp single\n    {\n    init = 10;\n    }\n    local = init;\n  }\n\n  return 0;\n}\n\n\n",
        "data_race": 0,
        "trimmed_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint main (int argc, char **argv)\n{\n  int init, local;\n\n  #pragma omp parallel shared(init) private(local)\n  {\n    #pragma omp single\n    {\n    init = 10;\n    }\n    local = init;\n  }\n\n  return 0;\n}\n\n\n",
        "code_len": 258,
        "data_race_label": "N1",
        "var_pairs": []
    },
    {
        "ID": "126",
        "name": "DRB126-firstprivatesections-orig-no.c",
        "DRB_code": "/*\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n!!! Copyright (c) 2017-20, Lawrence Livermore National Security, LLC\n!!! and DataRaceBench project contributors. See the DataRaceBench/COPYRIGHT file for details.\n!!!\n!!! SPDX-License-Identifier: (BSD-3-Clause)\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n*/\n\n/*\n * This example is based on fpriv_sections.1.c OpenMP Examples 5.0.0\n * The section construct modifies the value of section_count which breaks the independence of the\n * section constructs. If the same thread executes both the section one will print 1 and the other\n * will print 2. For a same thread execution, there is no data race. \n */\n\n#include <omp.h>\n#include <stdio.h>\n\nint main(){\n  int section_count = 0;\n  omp_set_dynamic(0);\n  \n  omp_set_num_threads(1);\n\n  #pragma omp parallel\n  #pragma omp sections firstprivate( section_count )\n  {\n    #pragma omp section\n    {\n      section_count++;\n      printf(\"%d\\n\",section_count);\n    }\n    #pragma omp section\n    {\n      section_count++;\n      printf(\"%d\\n\",section_count);\n    }\n  }\n  return 0;\n}\n",
        "data_race": 0,
        "trimmed_code": "#include <omp.h>\n#include <stdio.h>\n\nint main(){\n  int section_count = 0;\n  omp_set_dynamic(0);\n  \n  omp_set_num_threads(1);\n\n  #pragma omp parallel\n  #pragma omp sections firstprivate( section_count )\n  {\n    #pragma omp section\n    {\n      section_count++;\n      printf(\"%d\\n\",section_count);\n    }\n    #pragma omp section\n    {\n      section_count++;\n      printf(\"%d\\n\",section_count);\n    }\n  }\n  return 0;\n}\n",
        "code_len": 414,
        "data_race_label": "N1",
        "var_pairs": []
    },
    {
        "ID": "127",
        "name": "DRB127-tasking-threadprivate1-orig-no.c",
        "DRB_code": "/*\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n!!! Copyright (c) 2017-20, Lawrence Livermore National Security, LLC\n!!! and DataRaceBench project contributors. See the DataRaceBench/COPYRIGHT file for details.\n!!!\n!!! SPDX-License-Identifier: (BSD-3-Clause)\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n */\n\n/* This example is referred from OpenMP Application Programming Interface 5.0, example tasking.7.c\n * A task switch may occur at a task scheduling point. A single thread may execute both of the\n * task regions that modify tp. The parts of these task regions in which tp is modified may be\n * executed in any order so the resulting value of var can be either 1 or 2.\n * There is a  Race pair var@34:7 and var@34:7 but no data race. \n */\n\n\n#include <omp.h>\n#include <stdio.h>\n\nint tp;\n#pragma omp threadprivate(tp)\nint var;\n\nint main(){\n  #pragma omp task\n  {\n    #pragma omp task\n    {\n      tp = 1;\n      #pragma omp task\n      {\n      }\n      var = tp;\n    }\n    tp=2;\n  }\n\n  if(var==2) printf(\"%d\\n\",var);\n  return 0;\n}\n",
        "data_race": 0,
        "trimmed_code": "#include <omp.h>\n#include <stdio.h>\n\nint tp;\n#pragma omp threadprivate(tp)\nint var;\n\nint main(){\n  #pragma omp task\n  {\n    #pragma omp task\n    {\n      tp = 1;\n      #pragma omp task\n      {\n      }\n      var = tp;\n    }\n    tp=2;\n  }\n\n  if(var==2) printf(\"%d\\n\",var);\n  return 0;\n}\n",
        "code_len": 284,
        "data_race_label": "N1",
        "var_pairs": []
    },
    {
        "ID": "128",
        "name": "DRB128-tasking-threadprivate2-orig-no.c",
        "DRB_code": "/*\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n!!! Copyright (c) 2017-20, Lawrence Livermore National Security, LLC\n!!! and DataRaceBench project contributors. See the DataRaceBench/COPYRIGHT file for details.\n!!!\n!!! SPDX-License-Identifier: (BSD-3-Clause)\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n */\n\n /*\n * The scheduling constraints prohibit a thread in the team from executing\n * a new task that modifies tp while another such task region tied to\n * the same thread is suspended. Therefore, the value written will\n * persist across the task scheduling point.\n * No Data Race at var@35:7\n */\n\n\n#include <omp.h>\n#include <stdio.h>\n\nint tp;\n#pragma omp threadprivate(tp)\nint var;\n\nint main(){\n  #pragma omp task\n  {\n    #pragma omp task\n    {\n      tp = 1;\n      #pragma omp task\n      {\n      }\n      var = tp;\n    }\n  }\n  return 0;\n}\n",
        "data_race": 0,
        "trimmed_code": "#include <omp.h>\n#include <stdio.h>\n\nint tp;\n#pragma omp threadprivate(tp)\nint var;\n\nint main(){\n  #pragma omp task\n  {\n    #pragma omp task\n    {\n      tp = 1;\n      #pragma omp task\n      {\n      }\n      var = tp;\n    }\n  }\n  return 0;\n}\n",
        "code_len": 240,
        "data_race_label": "N1",
        "var_pairs": []
    },
    {
        "ID": "129",
        "name": "DRB129-mergeable-taskwait-orig-yes.c",
        "DRB_code": "/*\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n!!! Copyright (c) 2017-20, Lawrence Livermore National Security, LLC\n!!! and DataRaceBench project contributors. See the DataRaceBench/COPYRIGHT file for details.\n!!!\n!!! SPDX-License-Identifier: (BSD-3-Clause)\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n */\n\n/*\n * Taken from OpenMP Examples 5.0, example tasking.12.c\n * The created task will access different instances of the variable x if the task is not merged,\n * as x is firstprivate, but it will access the same variable x if the task is merged. It can\n * print two different values for x depending on the decisions taken by the implementation.\n * Data Race Pairs, x@27:5:W vs. x@27:5:W\n */\n\n#include <omp.h>\n#include <stdio.h>\n\n\nint main(){\n  int x = 2;\n\n  #pragma omp task mergeable\n  {\n    x++;\n  }\n  #pragma omp taskwait\n\n  printf(\"%d\\n\",x);\n  return 0;\n}\n",
        "data_race": 1,
        "trimmed_code": "#include <omp.h>\n#include <stdio.h>\n\n\nint main(){\n  int x = 2;\n\n  #pragma omp task mergeable\n  {\n    x++;\n  }\n  #pragma omp taskwait\n\n  printf(\"%d\\n\",x);\n  return 0;\n}\n",
        "code_len": 168,
        "data_race_label": "Y2",
        "var_pairs": [
            "{\"name\": [\"x\", \"x\"],\n\"line\": [27, 27],\n\"col\": [5, 5],\n\"operation\": [\"W\", \"W\"]}"
        ]
    },
    {
        "ID": "130",
        "name": "DRB130-mergeable-taskwait-orig-no.c",
        "DRB_code": "/*\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n!!! Copyright (c) 2017-20, Lawrence Livermore National Security, LLC\n!!! and DataRaceBench project contributors. See the DataRaceBench/COPYRIGHT file for details.\n!!!\n!!! SPDX-License-Identifier: (BSD-3-Clause)\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n */\n\n/*\n * Taken from OpenMP Examples 5.0, example tasking.12.c\n * x is a shared variable the outcome does not depend on whether or not the task is merged (that is,\n * the task will always increment the same variable and will always compute the same value for x).\n */\n\n#include <omp.h>\n#include <stdio.h>\n\n\nint main(){\n  int x = 2;\n\n  #pragma omp task shared(x) mergeable\n  {\n    x++;\n  }\n  #pragma omp taskwait\n\n  printf(\"%d\\n\",x);\n  return 0;\n}\n",
        "data_race": 0,
        "trimmed_code": "#include <omp.h>\n#include <stdio.h>\n\n\nint main(){\n  int x = 2;\n\n  #pragma omp task shared(x) mergeable\n  {\n    x++;\n  }\n  #pragma omp taskwait\n\n  printf(\"%d\\n\",x);\n  return 0;\n}\n",
        "code_len": 178,
        "data_race_label": "N2",
        "var_pairs": []
    },
    {
        "ID": "131",
        "name": "DRB131-taskdep4-orig-omp45-yes.c",
        "DRB_code": "/*\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n!!! Copyright (c) 2017-20, Lawrence Livermore National Security, LLC\n!!! and DataRaceBench project contributors. See the DataRaceBench/COPYRIGHT file for details.\n!!!\n!!! SPDX-License-Identifier: (BSD-3-Clause)\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n */\n\n/*\n * There is no completion restraint on the second child task. Hence, immediately after the first\n * taskwait it is unsafe to access the y variable since the second child task may still be\n * executing.\n * Data Race at y@28:2:W vs. y@34:19:R\n*/\n\n#include <stdio.h>\n#include <omp.h>\n\nvoid foo(){\n\n  int x = 0, y = 2;\n\n  #pragma omp task depend(inout: x) shared(x)\n  x++;                                                //1st Child Task\n\n  #pragma omp task shared(y)\n  y--;                                                // 2nd child task\n\n  #pragma omp task depend(in: x) if(0)                // 1st taskwait\n  {}\n\n  printf(\"x=%d\\n\",x);\n  printf(\"y=%d\\n\",y);\n  #pragma omp taskwait                                // 2nd taskwait\n}\n\n\nint main(){\n  #pragma omp parallel\n  #pragma omp single\n  foo();\n\n  return 0;\n}\n",
        "data_race": 1,
        "trimmed_code": "#include <stdio.h>\n#include <omp.h>\n\nvoid foo(){\n\n  int x = 0, y = 2;\n\n  #pragma omp task depend(inout: x) shared(x)\n  x++;                                                \n\n  #pragma omp task shared(y)\n  y--;                                                \n\n  #pragma omp task depend(in: x) if(0)                \n  {}\n\n  printf(\"x=%d\\n\",x);\n  printf(\"y=%d\\n\",y);\n  #pragma omp taskwait                                \n}\n\n\nint main(){\n  #pragma omp parallel\n  #pragma omp single\n  foo();\n\n  return 0;\n}\n",
        "code_len": 502,
        "data_race_label": "Y3",
        "var_pairs": [
            {
                "name": [
                    "var",
                    "var"
                ],
                "line": [
                    33,
                    33
                ],
                "col": [
                    5,
                    12
                ],
                "operation": [
                    "W",
                    "R"
                ]
            }
        ]
    },
    {
        "ID": "132",
        "name": "DRB132-taskdep4-orig-omp45-no.c",
        "DRB_code": "/*\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n!!! Copyright (c) 2017-20, Lawrence Livermore National Security, LLC\n!!! and DataRaceBench project contributors. See the DataRaceBench/COPYRIGHT file for details.\n!!!\n!!! SPDX-License-Identifier: (BSD-3-Clause)\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n */\n\n/* The second taskwait ensures that the second child task has completed; hence it is safe to access\n * the y variable in the following print statement.\n * */\n\n\n#include <stdio.h>\n#include <omp.h>\n\nvoid foo(){\n\n  int x = 0, y = 2;\n\n  #pragma omp task depend(inout: x) shared(x)\n  x++;                                                //1st Child Task\n\n  #pragma omp task shared(y)\n  y--;                                                // 2nd child task\n\n  #pragma omp task depend(in: x) if(0)                // 1st taskwait\n  {}\n\n  printf(\"x=%d\\n\",x);\n\n  #pragma omp taskwait                                // 2nd taskwait\n\n  printf(\"y=%d\\n\",y);\n}\n\n\nint main(){\n  #pragma omp parallel\n  #pragma omp single\n  foo();\n\n  return 0;\n}\n\n",
        "data_race": 0,
        "trimmed_code": "#include <stdio.h>\n#include <omp.h>\n\nvoid foo(){\n\n  int x = 0, y = 2;\n\n  #pragma omp task depend(inout: x) shared(x)\n  x++;                                                \n\n  #pragma omp task shared(y)\n  y--;                                                \n\n  #pragma omp task depend(in: x) if(0)                \n  {}\n\n  printf(\"x=%d\\n\",x);\n\n  #pragma omp taskwait                                \n\n  printf(\"y=%d\\n\",y);\n}\n\n\nint main(){\n  #pragma omp parallel\n  #pragma omp single\n  foo();\n\n  return 0;\n}\n\n",
        "code_len": 505,
        "data_race_label": "N3, N1",
        "var_pairs": []
    },
    {
        "ID": "133",
        "name": "DRB133-taskdep5-orig-omp45-no.c",
        "DRB_code": "/*\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n!!! Copyright (c) 2017-20, Lawrence Livermore National Security, LLC\n!!! and DataRaceBench project contributors. See the DataRaceBench/COPYRIGHT file for details.\n!!!\n!!! SPDX-License-Identifier: (BSD-3-Clause)\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n */\n\n/* The first two tasks are serialized, because a dependence on the first child is produced\n * by x with the in dependence type in the depend clause of the second task. Generating task\n * at the first taskwait only waits for the first child task to complete. The second taskwait\n * guarantees completion of the second task before y is accessed. Therefore there is no race\n * condition.\n * */\n\n\n#include <stdio.h>\n#include <omp.h>\n\nvoid foo(){\n  int x = 0, y = 2;\n\n  #pragma omp task depend(inout: x) shared(x)\n  x++;                                                                  // 1st child task\n\n  #pragma omp task depend(in: x) depend(inout: y) shared(x, y)\n  y = y-x;                                                              //2nd child task\n\n  #pragma omp task depend(in: x) if(0)                                  // 1st taskwait\n  {}\n\n  printf(\"x=%d\\n\",x);\n\n  #pragma omp taskwait                                                  // 2nd taskwait\n\n  printf(\"y=%d\\n\",y);\n}\n\nint main(){\n  #pragma omp parallel\n  #pragma omp single\n  foo();\n\n  return 0;\n}\n\n",
        "data_race": 0,
        "trimmed_code": "#include <stdio.h>\n#include <omp.h>\n\nvoid foo(){\n  int x = 0, y = 2;\n\n  #pragma omp task depend(inout: x) shared(x)\n  x++;                                                                  \n\n  #pragma omp task depend(in: x) depend(inout: y) shared(x, y)\n  y = y-x;                                                              \n\n  #pragma omp task depend(in: x) if(0)                                  \n  {}\n\n  printf(\"x=%d\\n\",x);\n\n  #pragma omp taskwait                                                  \n\n  printf(\"y=%d\\n\",y);\n}\n\nint main(){\n  #pragma omp parallel\n  #pragma omp single\n  foo();\n\n  return 0;\n}\n\n",
        "code_len": 609,
        "data_race_label": "N3",
        "var_pairs": []
    },
    {
        "ID": "134",
        "name": "DRB134-taskdep5-orig-omp45-yes.c",
        "DRB_code": "/*\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n!!! Copyright (c) 2017-20, Lawrence Livermore National Security, LLC\n!!! and DataRaceBench project contributors. See the DataRaceBench/COPYRIGHT file for details.\n!!!\n!!! SPDX-License-Identifier: (BSD-3-Clause)\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n */\n\n/* The first two tasks are serialized, because a dependence on the first child is produced\n * by x with the in dependence type in the depend clause of the second task. Generating task\n * at the first taskwait only waits for the first child task to complete. The second taskwait\n * guarantees completion of the second task before y is accessed. If we access y before the\n * second taskwait, there is a race condition at line 28:2 and 34:18. Data Race Pair, y@28:2:W vs. y@34:19:R\n * */\n\n\n#include <stdio.h>\n#include <omp.h>\n\nvoid foo(){\n  int x = 0, y = 2;\n\n  #pragma omp task depend(inout: x) shared(x)\n  x++;                                                             // 1st child task\n\n  #pragma omp task depend(in: x) depend(inout: y) shared(x, y)\n  y -= x;                                                         //2nd child task\n\n  #pragma omp task depend(in: x) if(0)                             // 1st taskwait\n  {}\n\n  printf(\"x=%d\\n\",x);\n  printf(\"y=%d\\n\",y);\n\n  #pragma omp taskwait\t\t                                         // 2nd taskwait\n\n}\n\nint main(){\n  #pragma omp parallel\n  #pragma omp single\n  foo();\n\n  return 0;\n}\n\n",
        "data_race": 1,
        "trimmed_code": "#include <stdio.h>\n#include <omp.h>\n\nvoid foo(){\n  int x = 0, y = 2;\n\n  #pragma omp task depend(inout: x) shared(x)\n  x++;                                                             \n\n  #pragma omp task depend(in: x) depend(inout: y) shared(x, y)\n  y -= x;                                                         \n\n  #pragma omp task depend(in: x) if(0)                             \n  {}\n\n  printf(\"x=%d\\n\",x);\n  printf(\"y=%d\\n\",y);\n\n  #pragma omp taskwait\t\t                                         \n\n}\n\nint main(){\n  #pragma omp parallel\n  #pragma omp single\n  foo();\n\n  return 0;\n}\n\n",
        "code_len": 586,
        "data_race_label": "Y1",
        "var_pairs": [
            "{\"name\": [\"y\", \"y\"],\n\"line\": [28, 34],\n\"col\": [2, 19],\n\"operation\": [\"W\", \"R\"]}"
        ]
    },
    {
        "ID": "135",
        "name": "DRB135-taskdep-mutexinoutset-orig-no.c",
        "DRB_code": "/*\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n!!! Copyright (c) 2017-20, Lawrence Livermore National Security, LLC\n!!! and DataRaceBench project contributors. See the DataRaceBench/COPYRIGHT file for details.\n!!!\n!!! SPDX-License-Identifier: (BSD-3-Clause)\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n */\n\n\n/* Addition of mutexinoutset dependence type on c, will ensure that line d@37:7 assignment will depend\n * on task at Line 32 and line 34. They might execute in any order but not at the same time.\n * There is no data race.\n * */\n\n\n#include <stdio.h>\n#include <omp.h>\n\nint main(){\n  int a, b, c, d;\n\n  #pragma omp parallel\n  #pragma omp single\n  {\n    #pragma omp task depend(out: c)\n      c = 1;\n    #pragma omp task depend(out: a)\n      a = 2;\n    #pragma omp task depend(out: b)\n      b = 3;\n    #pragma omp task depend(in: a) depend(mutexinoutset: c)\n      c += a;\n    #pragma omp task depend(in: b) depend(mutexinoutset: c)\n      c += b;\n    #pragma omp task depend(in: c)\n      d = c;\n  }\n\n  printf(\"%d\\n\",d);\n  return 0;\n}\n",
        "data_race": 0,
        "trimmed_code": "#include <stdio.h>\n#include <omp.h>\n\nint main(){\n  int a, b, c, d;\n\n  #pragma omp parallel\n  #pragma omp single\n  {\n    #pragma omp task depend(out: c)\n      c = 1;\n    #pragma omp task depend(out: a)\n      a = 2;\n    #pragma omp task depend(out: b)\n      b = 3;\n    #pragma omp task depend(in: a) depend(mutexinoutset: c)\n      c += a;\n    #pragma omp task depend(in: b) depend(mutexinoutset: c)\n      c += b;\n    #pragma omp task depend(in: c)\n      d = c;\n  }\n\n  printf(\"%d\\n\",d);\n  return 0;\n}\n",
        "code_len": 498,
        "data_race_label": "N1",
        "var_pairs": []
    },
    {
        "ID": "136",
        "name": "DRB136-taskdep-mutexinoutset-orig-yes.c",
        "DRB_code": "/*\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n!!! Copyright (c) 2017-20, Lawrence Livermore National Security, LLC\n!!! and DataRaceBench project contributors. See the DataRaceBench/COPYRIGHT file for details.\n!!!\n!!! SPDX-License-Identifier: (BSD-3-Clause)\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n */\n\n\n/* Due to the missing mutexinoutset dependence type on c, these tasks will execute in any\n * order leading to the data race at line 36. Data Race Pair, d@36:7:W vs. d@36:7:W\n * */\n\n\n#include <stdio.h>\n#include <omp.h>\n\nint main(){\n  int a, b, c, d;\n\n  #pragma omp parallel\n  #pragma omp single\n  {\n    #pragma omp task depend(out: c)\n      c = 1;\n    #pragma omp task depend(out: a)\n      a = 2;\n    #pragma omp task depend(out: b)\n      b = 3;\n    #pragma omp task depend(in: a)\n      c += a;\n    #pragma omp task depend(in: b)\n      c += b;\n    #pragma omp task depend(in: c)\n      d = c;\n  }\n\n  printf(\"%d\\n\",d);\n  return 0;\n}\n",
        "data_race": 1,
        "trimmed_code": "#include <stdio.h>\n#include <omp.h>\n\nint main(){\n  int a, b, c, d;\n\n  #pragma omp parallel\n  #pragma omp single\n  {\n    #pragma omp task depend(out: c)\n      c = 1;\n    #pragma omp task depend(out: a)\n      a = 2;\n    #pragma omp task depend(out: b)\n      b = 3;\n    #pragma omp task depend(in: a)\n      c += a;\n    #pragma omp task depend(in: b)\n      c += b;\n    #pragma omp task depend(in: c)\n      d = c;\n  }\n\n  printf(\"%d\\n\",d);\n  return 0;\n}\n",
        "code_len": 448,
        "data_race_label": "Y1,Y6",
        "var_pairs": [
            "{\"name\": [\"d\", \"d\"],\n\"line\": [36, 36],\n\"col\": [7, 7],\n\"operation\": [\"W\", \"W\"]}"
        ]
    },
    {
        "ID": "137",
        "name": "DRB137-simdsafelen-orig-no.c",
        "DRB_code": "/*\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n!!! Copyright (c) 2017-20, Lawrence Livermore National Security, LLC\n!!! and DataRaceBench project contributors. See the DataRaceBench/COPYRIGHT file for details.\n!!!\n!!! SPDX-License-Identifier: (BSD-3-Clause)\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n */\n\n/* The safelen(2) clause safelen(2)@24:20 guarantees that the vector code is safe for vectors up to 2 (inclusive).\n * In the loop, m can be 2 or more for the correct execution. If the value of m is less than 2,\n * the behavior is undefined. No Data Race in b[i]@26:5 assignment.\n * */\n\n\n#include <stdio.h>\n#include <omp.h>\n\nint main(){\n\n  int i, m=2, n=4;\n  int b[4] = {};\n\n  #pragma omp simd safelen(2)\n  for (i = m; i<n; i++)\n    b[i] = b[i-m] - 1.0f;\n\n  printf(\"Expected: -1; Real: %d\\n\",b[3]);\n  return 0;\n}\n\n\n",
        "data_race": 0,
        "trimmed_code": "#include <stdio.h>\n#include <omp.h>\n\nint main(){\n\n  int i, m=2, n=4;\n  int b[4] = {};\n\n  #pragma omp simd safelen(2)\n  for (i = m; i<n; i++)\n    b[i] = b[i-m] - 1.0f;\n\n  printf(\"Expected: -1; Real: %d\\n\",b[3]);\n  return 0;\n}\n\n\n",
        "code_len": 227,
        "data_race_label": "N1",
        "var_pairs": []
    },
    {
        "ID": "138",
        "name": "DRB138-simdsafelen-orig-yes.c",
        "DRB_code": "/*\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n!!! Copyright (c) 2017-20, Lawrence Livermore National Security, LLC\n!!! and DataRaceBench project contributors. See the DataRaceBench/COPYRIGHT file for details.\n!!!\n!!! SPDX-License-Identifier: (BSD-3-Clause)\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n */\n\n/* The safelen(2) clause at safelen(2)@24:20 guarantees that the vector code is safe for vectors\n * up to 2 (inclusive). In the loop, m@25:12 can be 2 or more for the correct execution. If the\n * value of m is less than 2, the behavior is undefined.\n * Data Race Pair: b[i]@26:5:W vs. b[i-m]@26:12:R\n * */\n\n#include <stdio.h>\n#include <omp.h>\n\nint main(){\n\n  int i, m=1, n=4;\n  int b[4] = {};\n\n  #pragma omp simd safelen(2)\n  for (i = m; i<n; i++)\n    b[i] = b[i-m] - 1.0f;\n\n  printf(\"Expected: -1; Real: %d\\n\",b[3]);\n  return 0;\n}\n",
        "data_race": 1,
        "trimmed_code": "#include <stdio.h>\n#include <omp.h>\n\nint main(){\n\n  int i, m=1, n=4;\n  int b[4] = {};\n\n  #pragma omp simd safelen(2)\n  for (i = m; i<n; i++)\n    b[i] = b[i-m] - 1.0f;\n\n  printf(\"Expected: -1; Real: %d\\n\",b[3]);\n  return 0;\n}\n",
        "code_len": 225,
        "data_race_label": "Y6",
        "var_pairs": [
            "{\"name\": [\"b[i]\", \"b[i-m]\"],\n\"line\": [26, 26],\n\"col\": [5, 12],\n\"operation\": [\"W\", \"R\"]}"
        ]
    },
    {
        "ID": "139",
        "name": "DRB139-worksharingcritical-orig-no.c",
        "DRB_code": "/*\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n!!! Copyright (c) 2017-20, Lawrence Livermore National Security, LLC\n!!! and DataRaceBench project contributors. See the DataRaceBench/COPYRIGHT file for details.\n!!!\n!!! SPDX-License-Identifier: (BSD-3-Clause)\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n */\n\n\n/*\n * Referred from worksharing_critical.1.c\n * A single thread executes the one and only section in the sections region, and executes the\n * critical region. The same thread encounters the nested parallel region, creates a new team\n * of threads, and becomes the master of the new team. One of the threads in the new team enters\n * the single region and increments i by 1. At the end of this example i is equal to 2.\n*/\n\n\n#include <stdio.h>\n#include <omp.h>\n\nint main(){\n\n  int i = 1;\n\n  #pragma omp parallel sections\n  {\n    #pragma omp section\n    {\n      #pragma omp critical (name)\n      {\n        #pragma omp parallel\n        {\n          #pragma omp single\n          {\n            i++;\n          }\n        }\n      }\n    }\n  }\n\n  printf(\"%d\\n\",i);\n  return 0;\n}\n",
        "data_race": 0,
        "trimmed_code": "#include <stdio.h>\n#include <omp.h>\n\nint main(){\n\n  int i = 1;\n\n  #pragma omp parallel sections\n  {\n    #pragma omp section\n    {\n      #pragma omp critical (name)\n      {\n        #pragma omp parallel\n        {\n          #pragma omp single\n          {\n            i++;\n          }\n        }\n      }\n    }\n  }\n\n  printf(\"%d\\n\",i);\n  return 0;\n}\n",
        "code_len": 344,
        "data_race_label": "N1",
        "var_pairs": []
    },
    {
        "ID": "140",
        "name": "DRB140-reduction-barrier-orig-yes.c",
        "DRB_code": "/*\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n!!! Copyright (c) 2017-20, Lawrence Livermore National Security, LLC\n!!! and DataRaceBench project contributors. See the DataRaceBench/COPYRIGHT file for details.\n!!!\n!!! SPDX-License-Identifier: (BSD-3-Clause)\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n */\n\n\n/* The assignment to a@25:7 is  not synchronized with the update of a@29:11 as a result of the\n * reduction computation in the for loop.\n * Data Race pair: a@25:5:W vs. a@27:33:W\n * */\n\n#include <stdio.h>\n#include <omp.h>\n\nint main(){\n  int a, i;\n\n  #pragma omp parallel shared(a) private(i)\n  {\n    #pragma omp master\n    a = 0;\n\n    #pragma omp for reduction(+:a)\n    for (i=0; i<10; i++){\n      a = a + i;\n    }\n\n    #pragma omp single\n    printf(\"Sum is %d\\n\", a);\n  }\n\n  return 0;\n}\n",
        "data_race": 1,
        "trimmed_code": "#include <stdio.h>\n#include <omp.h>\n\nint main(){\n  int a, i;\n\n  #pragma omp parallel shared(a) private(i)\n  {\n    #pragma omp master\n    a = 0;\n\n    #pragma omp for reduction(+:a)\n    for (i=0; i<10; i++){\n      a = a + i;\n    }\n\n    #pragma omp single\n    printf(\"Sum is %d\\n\", a);\n  }\n\n  return 0;\n}\n",
        "code_len": 302,
        "data_race_label": "Y3",
        "var_pairs": [
            "{\"name\": [\"a\", \"a\"],\n\"line\": [25, 27],\n\"col\": [5, 33],\n\"operation\": [\"W\", \"W\"]}"
        ]
    },
    {
        "ID": "141",
        "name": "DRB141-reduction-barrier-orig-no.c",
        "DRB_code": "/*\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n!!! Copyright (c) 2017-20, Lawrence Livermore National Security, LLC\n!!! and DataRaceBench project contributors. See the DataRaceBench/COPYRIGHT file for details.\n!!!\n!!! SPDX-License-Identifier: (BSD-3-Clause)\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n */\n\n\n/* To avoid data race, the initialization of the original list item \"a\" should complete before any\n * update of a as a result of the reduction clause. This can be achieved by adding an explicit\n * barrier after the assignment a=0@26:5, or by enclosing the assignment a=0@26:5 in a single directive\n * or by initializing a@21:7 before the start of the parallel region.\n * */\n\n#include <stdio.h>\n#include <omp.h>\n\nint main(){\n  int a, i;\n\n  #pragma omp parallel shared(a) private(i)\n  {\n    #pragma omp master\n    a = 0;\n\n    #pragma omp barrier\n\n    #pragma omp for reduction(+:a)\n    for (i=0; i<10; i++){\n      a += i;\n    }\n\n    #pragma omp single\n    printf(\"Sum is %d\\n\", a);\n  }\n\n  return 0;\n}\n",
        "data_race": 0,
        "trimmed_code": "#include <stdio.h>\n#include <omp.h>\n\nint main(){\n  int a, i;\n\n  #pragma omp parallel shared(a) private(i)\n  {\n    #pragma omp master\n    a = 0;\n\n    #pragma omp barrier\n\n    #pragma omp for reduction(+:a)\n    for (i=0; i<10; i++){\n      a += i;\n    }\n\n    #pragma omp single\n    printf(\"Sum is %d\\n\", a);\n  }\n\n  return 0;\n}\n",
        "code_len": 324,
        "data_race_label": "N3",
        "var_pairs": []
    },
    {
        "ID": "142",
        "name": "DRB142-acquirerelease-orig-yes.c",
        "DRB_code": "/*\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n!!! Copyright (c) 2017-20, Lawrence Livermore National Security, LLC\n!!! and DataRaceBench project contributors. See the DataRaceBench/COPYRIGHT file for details.\n!!!\n!!! SPDX-License-Identifier: (BSD-3-Clause)\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n */\n\n/* The below program will fail to order the write to x on thread 0 before the read from x on thread 1.\n * The implicit release flush on exit from the critical region will not synchronize with the acquire\n * flush that occurs on the atomic read operation performed by thread 1. This is because implicit\n * release flushes that occur on a given construct may only synchronize with implicit acquire flushes\n * on a compatible construct (and vice-versa) that internally makes use of the same synchronization\n * variable.\n *\n * Implicit flush must be used after critical construct, after line:34 and before line:35 to avoid data race.\n * Data Race pair: x@34:9:W vs. x@34:9:W\n * */\n\n\n#include <stdio.h>\n#include <omp.h>\n\nint main(){\n\n  int x = 0, y;\n\n  #pragma omp parallel num_threads(2)\n  {\n    int thrd = omp_get_thread_num();\n    if (thrd == 0) {\n      #pragma omp critical\n      { x = 10; }\n      #pragma omp atomic write\n      y = 1;\n    } else {\n      int tmp = 0;\n      while (tmp == 0) {\n        #pragma omp atomic read acquire\n        tmp = y;\n    }\n    #pragma omp critical\n    { if (x!=10) printf(\"x = %d\\n\", x); }\n    }\n  }\n  return 0;\n}\n",
        "data_race": 1,
        "trimmed_code": "#include <stdio.h>\n#include <omp.h>\n\nint main(){\n\n  int x = 0, y;\n\n  #pragma omp parallel num_threads(2)\n  {\n    int thrd = omp_get_thread_num();\n    if (thrd == 0) {\n      #pragma omp critical\n      { x = 10; }\n      #pragma omp atomic write\n      y = 1;\n    } else {\n      int tmp = 0;\n      while (tmp == 0) {\n        #pragma omp atomic read acquire\n        tmp = y;\n    }\n    #pragma omp critical\n    { if (x!=10) printf(\"x = %d\\n\", x); }\n    }\n  }\n  return 0;\n}\n",
        "code_len": 467,
        "data_race_label": "Y3",
        "var_pairs": [
            "{\"name\": [\"x\", \"x\"],\n\"line\": [34, 34],\n\"col\": [9, 9],\n\"operation\": [\"W\", \"W\"]}"
        ]
    },
    {
        "ID": "143",
        "name": "DRB143-acquirerelease-orig-no.c",
        "DRB_code": "/*\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n!!! Copyright (c) 2017-20, Lawrence Livermore National Security, LLC\n!!! and DataRaceBench project contributors. See the DataRaceBench/COPYRIGHT file for details.\n!!!\n!!! SPDX-License-Identifier: (BSD-3-Clause)\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n */\n\n/* The explicit flush directive that provides at line:29 provides release semantics is needed\n * here to complete the synchronization. No data race.\n * */\n\n\n#include <stdio.h>\n#include <omp.h>\n\nint main(){\n\n  int x = 0, y;\n\n  #pragma omp parallel num_threads(2)\n  {\n  int thrd = omp_get_thread_num();\n  if (thrd == 0) {\n    #pragma omp critical\n    { x = 10; }\n\n    #pragma omp flush(x)\n\n    #pragma omp atomic write\n    y = 1;\n  } else {\n      int tmp = 0;\n      while (tmp == 0) {\n      #pragma omp atomic read acquire\n      tmp = y;\n      }\n    #pragma omp critical\n    { if (x!=10) printf(\"x = %d\\n\", x); }\n  }\n  }\n  return 0;\n}\n",
        "data_race": 0,
        "trimmed_code": "#include <stdio.h>\n#include <omp.h>\n\nint main(){\n\n  int x = 0, y;\n\n  #pragma omp parallel num_threads(2)\n  {\n  int thrd = omp_get_thread_num();\n  if (thrd == 0) {\n    #pragma omp critical\n    { x = 10; }\n\n    #pragma omp flush(x)\n\n    #pragma omp atomic write\n    y = 1;\n  } else {\n      int tmp = 0;\n      while (tmp == 0) {\n      #pragma omp atomic read acquire\n      tmp = y;\n      }\n    #pragma omp critical\n    { if (x!=10) printf(\"x = %d\\n\", x); }\n  }\n  }\n  return 0;\n}\n",
        "code_len": 476,
        "data_race_label": "N3",
        "var_pairs": []
    },
    {
        "ID": "144",
        "name": "DRB144-critical-missingreduction-orig-gpu-yes.c",
        "DRB_code": "/*\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n!!! Copyright (c) 2017-20, Lawrence Livermore National Security, LLC\n!!! and DataRaceBench project contributors. See the DataRaceBench/COPYRIGHT file for details.\n!!!\n!!! SPDX-License-Identifier: (BSD-3-Clause)\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n */\n\n/*\nThe increment at line number 26 is critical for the variable\nvar@26:5. Therefore, there is a possible Data Race pair var@26:5:W vs. var@26:5:W\n*/\n\n#include <stdio.h>\n#include <omp.h>\n#define N 100\n\nint var = 0;\n\nint main(){\n  #pragma omp target map(tofrom:var) device(0)\n  #pragma omp teams distribute parallel for\n  for(int i=0; i<N*2; i++){\n    #pragma omp critical\n    var++;\n  }\n\n  printf(\"%d\\n \",var);\n\n  return 0;\n}\n",
        "data_race": 1,
        "trimmed_code": "#include <stdio.h>\n#include <omp.h>\n#define N 100\n\nint var = 0;\n\nint main(){\n  #pragma omp target map(tofrom:var) device(0)\n  #pragma omp teams distribute parallel for\n  for(int i=0; i<N*2; i++){\n    #pragma omp critical\n    var++;\n  }\n\n  printf(\"%d\\n \",var);\n\n  return 0;\n}\n",
        "code_len": 275,
        "data_race_label": "Y5, Y3",
        "var_pairs": [
            "{\"name\": [\"var\", \"var\"],\n\"line\": [26, 26],\n\"col\": [5, 5],\n\"operation\": [\"W\", \"W\"]}"
        ]
    },
    {
        "ID": "145",
        "name": "DRB145-atomiccritical-orig-gpu-no.c",
        "DRB_code": "/*\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n!!! Copyright (c) 2017-20, Lawrence Livermore National Security, LLC\n!!! and DataRaceBench project contributors. See the DataRaceBench/COPYRIGHT file for details.\n!!!\n!!! SPDX-License-Identifier: (BSD-3-Clause)\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n */\n\n/*\nThe increment operation at line@27:7 is team specific as each team work on their individual var.\nNo Data Race Pair\n*/\n\n#include <stdio.h>\n#include <omp.h>\n#define N 100\n\nint var = 0;\n\nint main(){\n  #pragma omp target map(tofrom:var) device(0)\n  #pragma omp teams distribute parallel for reduction(+:var)\n  for (int i=0; i<N; i++){\n    var++;\n  }\n\n  printf(\"%d\\n\",var);\n  return 0;\n}\n",
        "data_race": 0,
        "trimmed_code": "#include <stdio.h>\n#include <omp.h>\n#define N 100\n\nint var = 0;\n\nint main(){\n  #pragma omp target map(tofrom:var) device(0)\n  #pragma omp teams distribute parallel for reduction(+:var)\n  for (int i=0; i<N; i++){\n    var++;\n  }\n\n  printf(\"%d\\n\",var);\n  return 0;\n}\n",
        "code_len": 264,
        "data_race_label": "N5, N2",
        "var_pairs": []
    },
    {
        "ID": "146",
        "name": "DRB146-atomicupdate-orig-gpu-no.c",
        "DRB_code": "/*\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n!!! Copyright (c) 2017-20, Lawrence Livermore National Security, LLC\n!!! and DataRaceBench project contributors. See the DataRaceBench/COPYRIGHT file for details.\n!!!\n!!! SPDX-License-Identifier: (BSD-3-Clause)\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n */\n\n/*\nThe var@25:5 is atomic update. Hence, there is no data race pair.\n*/\n\n#include <stdio.h>\n#include <omp.h>\n#define N 100\n\nint var = 0;\n\nint main(){\n  #pragma omp target map(tofrom:var) device(0)\n  #pragma omp teams distribute\n  for (int i=0; i<N; i++){\n    #pragma omp atomic update\n    var++;\n  }\n  printf(\"%d\\n \",var);\n  return 0;\n}\n",
        "data_race": 0,
        "trimmed_code": "#include <stdio.h>\n#include <omp.h>\n#define N 100\n\nint var = 0;\n\nint main(){\n  #pragma omp target map(tofrom:var) device(0)\n  #pragma omp teams distribute\n  for (int i=0; i<N; i++){\n    #pragma omp atomic update\n    var++;\n  }\n  printf(\"%d\\n \",var);\n  return 0;\n}\n",
        "code_len": 264,
        "data_race_label": "N5, N3, N1",
        "var_pairs": []
    },
    {
        "ID": "147",
        "name": "DRB147-critical1-orig-gpu-no.c",
        "DRB_code": "/*\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n!!! Copyright (c) 2017-20, Lawrence Livermore National Security, LLC\n!!! and DataRaceBench project contributors. See the DataRaceBench/COPYRIGHT file for details.\n!!!\n!!! SPDX-License-Identifier: (BSD-3-Clause)\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n */\n\n/*\nConcurrent access on same variable var@29 and var@32 leads to the race condition if two different\nlocks are used. This is the reason here we have used the atomic directive to ensure that addition\nand subtraction are not interleaved. No data race pairs.\n*/\n\n#include <omp.h>\n#include <stdio.h>\n\n#define N 100\n\nint var = 0;\n\nint main(){\n\n  #pragma omp target map(tofrom:var) device(0)\n  #pragma omp teams distribute parallel for\n  for(int i=0; i<N; i++){\n    #pragma omp atomic\n    var++;\n\n    #pragma omp atomic\n    var -= 2;\n  }\n\n  printf(\"%d\\n\",var);\n  return 0;\n}\n",
        "data_race": 0,
        "trimmed_code": "#include <omp.h>\n#include <stdio.h>\n\n#define N 100\n\nint var = 0;\n\nint main(){\n\n  #pragma omp target map(tofrom:var) device(0)\n  #pragma omp teams distribute parallel for\n  for(int i=0; i<N; i++){\n    #pragma omp atomic\n    var++;\n\n    #pragma omp atomic\n    var -= 2;\n  }\n\n  printf(\"%d\\n\",var);\n  return 0;\n}\n",
        "code_len": 309,
        "data_race_label": "N5, N1",
        "var_pairs": []
    },
    {
        "ID": "148",
        "name": "DRB148-critical1-orig-gpu-yes.c",
        "DRB_code": "/*\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n!!! Copyright (c) 2017-20, Lawrence Livermore National Security, LLC\n!!! and DataRaceBench project contributors. See the DataRaceBench/COPYRIGHT file for details.\n!!!\n!!! SPDX-License-Identifier: (BSD-3-Clause)\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n */\n\n/*\nThis example is referred from DataRaceOnAccelerator : A Micro-benchmark Suite for Evaluating\nCorrectness Tools Targeting Accelerators.\nThough we have used critical directive to ensure that addition and subtraction are not overlapped,\ndue to different locks addlock@30:26 and sublock@33:26 interleave each others operation.\nData Race pairs, var@31:5:W vs. var@34:5:W\n*/\n\n#include <omp.h>\n#include <stdio.h>\n\n#define N 100\n\nint var = 0;\n\nint main(){\n\n  #pragma omp target map(tofrom:var) device(0)\n  #pragma omp teams distribute parallel for\n  for(int i=0; i<N; i++){\n    #pragma omp critical(addlock)\n    var++;\n\n    #pragma omp critical(sublock)\n    var -= 2;\n  }\n\n  printf(\"%d\\n\",var);\n\n  return 0;\n}\n",
        "data_race": 1,
        "trimmed_code": "#include <omp.h>\n#include <stdio.h>\n\n#define N 100\n\nint var = 0;\n\nint main(){\n\n  #pragma omp target map(tofrom:var) device(0)\n  #pragma omp teams distribute parallel for\n  for(int i=0; i<N; i++){\n    #pragma omp critical(addlock)\n    var++;\n\n    #pragma omp critical(sublock)\n    var -= 2;\n  }\n\n  printf(\"%d\\n\",var);\n\n  return 0;\n}\n",
        "code_len": 332,
        "data_race_label": "Y5, Y3",
        "var_pairs": [
            "{\"name\": [\"var\", \"var\"],\n\"line\": [31, 34],\n\"col\": [5, 5],\n\"operation\": [\"W\", \"W\"]}"
        ]
    },
    {
        "ID": "149",
        "name": "DRB149-missingdata1-orig-gpu-no.c",
        "DRB_code": "/*\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n!!! Copyright (c) 2017-20, Lawrence Livermore National Security, LLC\n!!! and DataRaceBench project contributors. See the DataRaceBench/COPYRIGHT file for details.\n!!!\n!!! SPDX-License-Identifier: (BSD-3-Clause)\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n */\n\n/*\nData Race free matrix vector multiplication using target construct.\n*/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <omp.h>\n#define C 100\n\nint *a;\nint *b;\nint *c;\n\nint main(){\n  a = malloc(C*sizeof(int));\n  b = malloc(C*C*sizeof(int));\n  c = malloc(C*sizeof(int));\n\n  for(int i=0; i<C; i++){\n    for(int j=0; j<C; j++){\n      b[j+i*C]=1;\n    }\n    a[i]=1;\n    c[i]=0;\n  }\n\n  #pragma omp target map(to:a[0:C],b[0:C*C]) map(tofrom:c[0:C]) device(0)\n  {\n    #pragma omp teams distribute parallel for\n    for(int i=0; i<C; i++){\n      for(int j=0; j<C; j++){\n        c[i]+=b[j+i*C]*a[j];\n      }\n    }\n  }\n\n  for(int i=0; i<C; i++){\n    if(c[i]!=C){\n      printf(\"Data Race\\n\");\n      return 1;\n    }\n  }\n\n  free(a);\n  free(b);\n  free(c);\n\n  return 0;\n}\n",
        "data_race": 0,
        "trimmed_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <omp.h>\n#define C 100\n\nint *a;\nint *b;\nint *c;\n\nint main(){\n  a = malloc(C*sizeof(int));\n  b = malloc(C*C*sizeof(int));\n  c = malloc(C*sizeof(int));\n\n  for(int i=0; i<C; i++){\n    for(int j=0; j<C; j++){\n      b[j+i*C]=1;\n    }\n    a[i]=1;\n    c[i]=0;\n  }\n\n  #pragma omp target map(to:a[0:C],b[0:C*C]) map(tofrom:c[0:C]) device(0)\n  {\n    #pragma omp teams distribute parallel for\n    for(int i=0; i<C; i++){\n      for(int j=0; j<C; j++){\n        c[i]+=b[j+i*C]*a[j];\n      }\n    }\n  }\n\n  for(int i=0; i<C; i++){\n    if(c[i]!=C){\n      printf(\"Data Race\\n\");\n      return 1;\n    }\n  }\n\n  free(a);\n  free(b);\n  free(c);\n\n  return 0;\n}\n",
        "code_len": 682,
        "data_race_label": "N5",
        "var_pairs": []
    },
    {
        "ID": "150",
        "name": "DRB150-missinglock1-orig-gpu-yes.c",
        "DRB_code": "/*\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n!!! Copyright (c) 2017-20, Lawrence Livermore National Security, LLC\n!!! and DataRaceBench project contributors. See the DataRaceBench/COPYRIGHT file for details.\n!!!\n!!! SPDX-License-Identifier: (BSD-3-Clause)\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n */\n\n/*\nThe distribute parallel for directive at line 27 will execute loop using multiple teams.\nThe loop iterations are distributed across the teams in chunks in round robin fashion.\nThe omp lock is only guaranteed for a contention group, i.e, within a team. Data Race Pair, var@30:5:W vs. var@30:5:W\n*/\n\n\n#include <omp.h>\n#include <stdio.h>\n\nint main(){\n\n  omp_lock_t lck;\n  int var=0,i;\n  omp_init_lock(&lck);\n\n  #pragma omp target map(tofrom:var) device(0)\n  #pragma omp teams distribute parallel for\n  for (int i=0; i<100; i++){\n    omp_set_lock(&lck);\n    var++;\n    omp_unset_lock(&lck);\n  }\n\n  omp_destroy_lock(&lck);\n\n  printf(\"%d\\n\",var);\n  return 0;\n}\n",
        "data_race": 1,
        "trimmed_code": "#include <omp.h>\n#include <stdio.h>\n\nint main(){\n\n  omp_lock_t lck;\n  int var=0,i;\n  omp_init_lock(&lck);\n\n  #pragma omp target map(tofrom:var) device(0)\n  #pragma omp teams distribute parallel for\n  for (int i=0; i<100; i++){\n    omp_set_lock(&lck);\n    var++;\n    omp_unset_lock(&lck);\n  }\n\n  omp_destroy_lock(&lck);\n\n  printf(\"%d\\n\",var);\n  return 0;\n}\n",
        "code_len": 356,
        "data_race_label": "Y5, Y3",
        "var_pairs": [
            "{\"name\": [\"var\", \"var\"],\n\"line\": [30, 30],\n\"col\": [5, 5],\n\"operation\": [\"W\", \"W\"]}"
        ]
    },
    {
        "ID": "151",
        "name": "DRB151-missinglock3-orig-gpu-yes.c",
        "DRB_code": "/*\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n!!! Copyright (c) 2017-20, Lawrence Livermore National Security, LLC\n!!! and DataRaceBench project contributors. See the DataRaceBench/COPYRIGHT file for details.\n!!!\n!!! SPDX-License-Identifier: (BSD-3-Clause)\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n*/\n\n/*This example is referred from DRACC by Adrian Schmitz et al.\nThe distribute parallel for directive at line 24 will execute loop using multiple teams.\nThe loop iterations are distributed across the teams in chunks in round robin fashion.\nThe missing lock enclosing var@26:5 leads to data race. Data Race Pairs, var@26:5:W vs. var@26:5:W\n*/\n\n#include <omp.h>\n#include <stdio.h>\n\nint main(){\n\n  int var=0,i;\n\n  #pragma omp target map(tofrom:var) device(0)\n  #pragma omp teams distribute parallel for\n  for (int i=0; i<100; i++){\n    var++;\n  }\n\n  printf(\"%d\\n\",var);\n  return 0;\n}\n",
        "data_race": 1,
        "trimmed_code": "#include <omp.h>\n#include <stdio.h>\n\nint main(){\n\n  int var=0,i;\n\n  #pragma omp target map(tofrom:var) device(0)\n  #pragma omp teams distribute parallel for\n  for (int i=0; i<100; i++){\n    var++;\n  }\n\n  printf(\"%d\\n\",var);\n  return 0;\n}\n",
        "code_len": 238,
        "data_race_label": "Y5, Y3",
        "var_pairs": [
            "{\"name\": [\"var\", \"var\"],\n\"line\": [26, 26],\n\"col\": [5, 5],\n\"operation\": [\"W\", \"W\"]}"
        ]
    },
    {
        "ID": "152",
        "name": "DRB152-missinglock2-orig-gpu-no.c",
        "DRB_code": "/*\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n!!! Copyright (c) 2017-20, Lawrence Livermore National Security, LLC\n!!! and DataRaceBench project contributors. See the DataRaceBench/COPYRIGHT file for details.\n!!!\n!!! SPDX-License-Identifier: (BSD-3-Clause)\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n*/\n\n/*\nConcurrent access of var@28:5 in an intra region. Lock ensures that there is no data race.\n*/\n\n#include <stdio.h>\n#include <omp.h>\n#define N 100\n\nint main(){\n  omp_lock_t lck;\n  int var=0;\n  omp_init_lock(&lck);\n\n  #pragma omp target map(tofrom:var) device(0)\n  #pragma omp teams num_teams(1)\n  #pragma omp distribute parallel for\n  for (int i=0; i<N; i++){\n    omp_set_lock(&lck);\n    var++;\n    omp_unset_lock(&lck);\n  }\n\n  omp_destroy_lock(&lck);\n  printf(\"%d\\n\",var);\n  return 0;\n}\n",
        "data_race": 0,
        "trimmed_code": "#include <stdio.h>\n#include <omp.h>\n#define N 100\n\nint main(){\n  omp_lock_t lck;\n  int var=0;\n  omp_init_lock(&lck);\n\n  #pragma omp target map(tofrom:var) device(0)\n  #pragma omp teams num_teams(1)\n  #pragma omp distribute parallel for\n  for (int i=0; i<N; i++){\n    omp_set_lock(&lck);\n    var++;\n    omp_unset_lock(&lck);\n  }\n\n  omp_destroy_lock(&lck);\n  printf(\"%d\\n\",var);\n  return 0;\n}\n",
        "code_len": 391,
        "data_race_label": "N5, N3",
        "var_pairs": []
    },
    {
        "ID": "153",
        "name": "DRB153-missinglock2-orig-gpu-yes.c",
        "DRB_code": "/*\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n!!! Copyright (c) 2017-20, Lawrence Livermore National Security, LLC\n!!! and DataRaceBench project contributors. See the DataRaceBench/COPYRIGHT file for details.\n!!!\n!!! SPDX-License-Identifier: (BSD-3-Clause)\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n*/\n\n/*\nThis kernel is referred from \u201cDataRaceOnAccelerator A Micro-benchmark Suite for Evaluating\nCorrectness Tools Targeting Accelerators\u201d by Adrian Schmitz et al.\nConcurrent access of var@28:5 in an intra region. Missing Lock leads to intra region data race.\nData Race pairs, var@28:5:W vs. var@28:5:W\n*/\n\n#include <stdio.h>\n#include <omp.h>\n#define N 100\n\nint main(){\n  int var = 0;\n\n  #pragma omp target map(tofrom:var) device(0)\n  #pragma omp teams num_teams(1)\n  #pragma omp distribute parallel for\n  for (int i=0; i<N; i++){\n    var++;\n  }\n\n  printf(\"%d\\n \",var);\n  return 0;\n}\n",
        "data_race": 1,
        "trimmed_code": "#include <stdio.h>\n#include <omp.h>\n#define N 100\n\nint main(){\n  int var = 0;\n\n  #pragma omp target map(tofrom:var) device(0)\n  #pragma omp teams num_teams(1)\n  #pragma omp distribute parallel for\n  for (int i=0; i<N; i++){\n    var++;\n  }\n\n  printf(\"%d\\n \",var);\n  return 0;\n}\n",
        "code_len": 277,
        "data_race_label": "Y5, Y2",
        "var_pairs": [
            "{\"name\": [\"var\", \"var\"],\n\"line\": [28, 28],\n\"col\": [5, 5],\n\"operation\": [\"W\", \"W\"]}"
        ]
    },
    {
        "ID": "154",
        "name": "DRB154-missinglock3-orig-gpu-no.c",
        "DRB_code": "/*\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n!!! Copyright (c) 2017-20, Lawrence Livermore National Security, LLC\n!!! and DataRaceBench project contributors. See the DataRaceBench/COPYRIGHT file for details.\n!!!\n!!! SPDX-License-Identifier: (BSD-3-Clause)\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n*/\n\n/*\nConcurrent accessing var@27:5 may cause atomicity violation and inter region data race.\nLock and reduction clause at line 24, avoids this. No Data Race Pair.\n*/\n\n#include <stdio.h>\n#include <omp.h>\n\nint main(){\n  omp_lock_t lck;\n  int var = 0;\n  omp_init_lock(&lck);\n\n  #pragma omp target map(tofrom:var) device(0)\n  #pragma omp teams distribute reduction(+:var)\n  for (int i=0; i<100; i++){\n    omp_set_lock(&lck);\n    var++;\n    omp_unset_lock(&lck);\n  }\n\n  omp_destroy_lock(&lck);\n  printf(\"%d\\n \",var);\n  return 0;\n}\n",
        "data_race": 0,
        "trimmed_code": "#include <stdio.h>\n#include <omp.h>\n\nint main(){\n  omp_lock_t lck;\n  int var = 0;\n  omp_init_lock(&lck);\n\n  #pragma omp target map(tofrom:var) device(0)\n  #pragma omp teams distribute reduction(+:var)\n  for (int i=0; i<100; i++){\n    omp_set_lock(&lck);\n    var++;\n    omp_unset_lock(&lck);\n  }\n\n  omp_destroy_lock(&lck);\n  printf(\"%d\\n \",var);\n  return 0;\n}\n",
        "code_len": 359,
        "data_race_label": "N5, N3",
        "var_pairs": []
    },
    {
        "ID": "155",
        "name": "DRB155-missingordered-orig-gpu-no.c",
        "DRB_code": "/*\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n!!! Copyright (c) 2017-20, Lawrence Livermore National Security, LLC\n!!! and DataRaceBench project contributors. See the DataRaceBench/COPYRIGHT file for details.\n!!!\n!!! SPDX-License-Identifier: (BSD-3-Clause)\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n*/\n\n/*\nBy utilizing the ordered construct @29 the execution will be\nsequentially consistent. No Data Race Pair.\n*/\n\n#include <stdio.h>\n#include <omp.h>\n#include <stdlib.h>\n#define N 100\n\nint main(){\n\n  int var[N];\n\n  for(int i=0; i<N; i++){\n    var[i]=0;\n  }\n\n  #pragma omp target map(tofrom:var[0:N]) device(0)\n    #pragma omp parallel for ordered\n    for (int i=1; i<N; i++){\n      #pragma omp ordered\n      {\n        var[i]=var[i-1]+1;\n      }\n    }\n\n  for(int i=0; i<N; i++){\n    if(var[i]!=i){\n      printf(\"Data Race Present\");\n      return 0;\n    }\n  }\n\n  return 0;\n}\n",
        "data_race": 0,
        "trimmed_code": "#include <stdio.h>\n#include <omp.h>\n#include <stdlib.h>\n#define N 100\n\nint main(){\n\n  int var[N];\n\n  for(int i=0; i<N; i++){\n    var[i]=0;\n  }\n\n  #pragma omp target map(tofrom:var[0:N]) device(0)\n    #pragma omp parallel for ordered\n    for (int i=1; i<N; i++){\n      #pragma omp ordered\n      {\n        var[i]=var[i-1]+1;\n      }\n    }\n\n  for(int i=0; i<N; i++){\n    if(var[i]!=i){\n      printf(\"Data Race Present\");\n      return 0;\n    }\n  }\n\n  return 0;\n}\n",
        "code_len": 459,
        "data_race_label": "N5, N1",
        "var_pairs": []
    },
    {
        "ID": "156",
        "name": "DRB156-missingordered-orig-gpu-yes.c",
        "DRB_code": "/*\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n!!! Copyright (c) 2017-20, Lawrence Livermore National Security, LLC\n!!! and DataRaceBench project contributors. See the DataRaceBench/COPYRIGHT file for details.\n!!!\n!!! SPDX-License-Identifier: (BSD-3-Clause)\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n*/\n\n/*This example is referred from DRACC by Adrian Schmitz et al.\nMissing ordered directive causes data race pairs var@28:5:W vs. var@28:13:R\n*/\n\n#include <stdio.h>\n#include <omp.h>\n#include <stdlib.h>\n#define N 100\n\nint main(){\n  int var[N];\n  for(int i=0; i<N; i++){\n    var[i]=0;\n  }\n\n  #pragma omp target map(tofrom:var[0:N]) device(0)\n  #pragma omp teams distribute parallel for\n  for (int i=1; i<N; i++){\n    var[i]=var[i-1]+1;\n  }\n\n  for(int i=0; i<N; i++){\n    if(var[i]!=i){\n      printf(\"Data Race Present\\n\");\n      return 0;\n    }\n  }\n  return 0;\n}\n",
        "data_race": 1,
        "trimmed_code": "#include <stdio.h>\n#include <omp.h>\n#include <stdlib.h>\n#define N 100\n\nint main(){\n  int var[N];\n  for(int i=0; i<N; i++){\n    var[i]=0;\n  }\n\n  #pragma omp target map(tofrom:var[0:N]) device(0)\n  #pragma omp teams distribute parallel for\n  for (int i=1; i<N; i++){\n    var[i]=var[i-1]+1;\n  }\n\n  for(int i=0; i<N; i++){\n    if(var[i]!=i){\n      printf(\"Data Race Present\\n\");\n      return 0;\n    }\n  }\n  return 0;\n}\n",
        "code_len": 415,
        "data_race_label": "Y5, Y6",
        "var_pairs": [
            "{\"name\": [\"var\", \"var\"],\n\"line\": [28, 28],\n\"col\": [5, 13],\n\"operation\": [\"W\", \"R\"]}"
        ]
    },
    {
        "ID": "157",
        "name": "DRB157-missingorderedsimd-orig-gpu-yes.c",
        "DRB_code": "/*\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n!!! Copyright (c) 2017-20, Lawrence Livermore National Security, LLC\n!!! and DataRaceBench project contributors. See the DataRaceBench/COPYRIGHT file for details.\n!!!\n!!! SPDX-License-Identifier: (BSD-3-Clause)\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n*/\n\n/*\nThis kernel is modified version from \u201cDataRaceOnAccelerator A Micro-benchmark Suite for Evaluating\nCorrectness Tools Targeting Accelerators\u201d by Adrian Schmitz et al.\nDue to distribute parallel for simd directive at line 31, there is a data race at line 33.\nData Rae Pairs, var@33:5:W vs. var@33:12:R\n.*/\n\n#include <stdio.h>\n#include <omp.h>\n#include <stdlib.h>\n#define N 100\n#define C 16\n\nint main(){\n  int var[N];\n\n  for(int i=0; i<N; i++){\n    var[i]=0;\n  }\n\n  #pragma omp target map(tofrom:var[0:N]) device(0)\n  #pragma omp teams distribute parallel for simd safelen(C)\n  for (int i=C; i<N; i++){\n    var[i]=var[i-C]+1;\n  }\n\n  printf(\"%d\\n\",var[97]);\n\n  return 0;\n}\n",
        "data_race": 1,
        "trimmed_code": "#include <stdio.h>\n#include <omp.h>\n#include <stdlib.h>\n#define N 100\n#define C 16\n\nint main(){\n  int var[N];\n\n  for(int i=0; i<N; i++){\n    var[i]=0;\n  }\n\n  #pragma omp target map(tofrom:var[0:N]) device(0)\n  #pragma omp teams distribute parallel for simd safelen(C)\n  for (int i=C; i<N; i++){\n    var[i]=var[i-C]+1;\n  }\n\n  printf(\"%d\\n\",var[97]);\n\n  return 0;\n}\n",
        "code_len": 364,
        "data_race_label": "Y5, Y4",
        "var_pairs": [
            {
                "name": [
                    "var",
                    "var"
                ],
                "line": [
                    33,
                    33
                ],
                "col": [
                    5,
                    12
                ],
                "operation": [
                    "W",
                    "R"
                ]
            }
        ]
    },
    {
        "ID": "158",
        "name": "DRB158-missingtaskbarrier-orig-gpu-no.c",
        "DRB_code": "/*\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n!!! Copyright (c) 2017-20, Lawrence Livermore National Security, LLC\n!!! and DataRaceBench project contributors. See the DataRaceBench/COPYRIGHT file for details.\n!!!\n!!! SPDX-License-Identifier: (BSD-3-Clause)\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n*/\n\n/*\nDepend clause at line 33 and 37 will ensure that there is no data race. There is an implicit barrier after tasks execution.\n*/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <omp.h>\n#define C 64\n\nfloat a;\nfloat x[C];\nfloat y[C];\n\nint main(){\n  for(int i=0; i<C; i++){\n    a=5;\n    x[i]=0;\n    y[i]=3;\n  }\n\n  #pragma omp target map(to:y[0:C],a) map(tofrom:x[0:C]) device(0)\n  {\n    for(int i=0; i<C; i++){\n      #pragma omp task depend(inout:x[i])\n      {\n        x[i] = a * x[i];\n      }\n      #pragma omp task depend(inout:x[i])\n      {\n        x[i] = x[i] + y[i];\n      }\n    }\n  }\n\n  for(int i=0; i<C; i++){\n    if(x[i]!=3){\n      printf(\"Data Race Detected\\n\");\n      return 0;\n    }\n  }\n\n  #pragma omp taskwait\n  return 0;\n}\n",
        "data_race": 0,
        "trimmed_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <omp.h>\n#define C 64\n\nfloat a;\nfloat x[C];\nfloat y[C];\n\nint main(){\n  for(int i=0; i<C; i++){\n    a=5;\n    x[i]=0;\n    y[i]=3;\n  }\n\n  #pragma omp target map(to:y[0:C],a) map(tofrom:x[0:C]) device(0)\n  {\n    for(int i=0; i<C; i++){\n      #pragma omp task depend(inout:x[i])\n      {\n        x[i] = a * x[i];\n      }\n      #pragma omp task depend(inout:x[i])\n      {\n        x[i] = x[i] + y[i];\n      }\n    }\n  }\n\n  for(int i=0; i<C; i++){\n    if(x[i]!=3){\n      printf(\"Data Race Detected\\n\");\n      return 0;\n    }\n  }\n\n  #pragma omp taskwait\n  return 0;\n}\n",
        "code_len": 604,
        "data_race_label": "N5, N1",
        "var_pairs": []
    },
    {
        "ID": "159",
        "name": "DRB159-nobarrier-orig-gpu-no.c",
        "DRB_code": "/*\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n!!! Copyright (c) 2017-20, Lawrence Livermore National Security, LLC\n!!! and DataRaceBench project contributors. See the DataRaceBench/COPYRIGHT file for details.\n!!!\n!!! SPDX-License-Identifier: (BSD-3-Clause)\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n*/\n\n/*\nVector addition followed by multiplication involving the same var should have a barrier in between.\nHere we have an implicit barrier after parallel for regions. No data race pair.\n*/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <omp.h>\n#define N 100\n#define C 8\n\n\nint a;\nint b[C];\nint c[C];\nint temp[C];\n\nint main(){\n  for(int i=0; i<C; i++){\n    b[i]=0;\n    c[i]=2;\n    temp[i]=0;\n  }\n  a=2;\n\n  #pragma omp target map(tofrom:b[0:C]) map(to:c[0:C],temp[0:C],a) device(0)\n  #pragma omp parallel\n  {\n    for(int i=0; i<N ;i++){\n      #pragma omp for\n      for(int i=0; i<C; i++){\n        temp[i] = b[i] + c[i];\n      }\n\n      #pragma omp for\n      for(int i=C-1; i>=0; i--){\n        b[i] = temp[i] * a;\n      }\n    }\n  }\n\n  int val = 0;\n\n  for(int i=0; i<N; i++){\n    val = val + 2;\n    val = val * 2;\n  }\n\n  for(int i=0; i<C; i++){\n    if(b[i]!=val){\n      printf(\"expected %d real %d \\n\",val, b[i]);\n      return 0;\n    }\n  }\n\n  return 0;\n}\n",
        "data_race": 0,
        "trimmed_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <omp.h>\n#define N 100\n#define C 8\n\n\nint a;\nint b[C];\nint c[C];\nint temp[C];\n\nint main(){\n  for(int i=0; i<C; i++){\n    b[i]=0;\n    c[i]=2;\n    temp[i]=0;\n  }\n  a=2;\n\n  #pragma omp target map(tofrom:b[0:C]) map(to:c[0:C],temp[0:C],a) device(0)\n  #pragma omp parallel\n  {\n    for(int i=0; i<N ;i++){\n      #pragma omp for\n      for(int i=0; i<C; i++){\n        temp[i] = b[i] + c[i];\n      }\n\n      #pragma omp for\n      for(int i=C-1; i>=0; i--){\n        b[i] = temp[i] * a;\n      }\n    }\n  }\n\n  int val = 0;\n\n  for(int i=0; i<N; i++){\n    val = val + 2;\n    val = val * 2;\n  }\n\n  for(int i=0; i<C; i++){\n    if(b[i]!=val){\n      printf(\"expected %d real %d \\n\",val, b[i]);\n      return 0;\n    }\n  }\n\n  return 0;\n}\n",
        "code_len": 761,
        "data_race_label": "N5, N3",
        "var_pairs": []
    },
    {
        "ID": "160",
        "name": "DRB160-nobarrier-orig-gpu-yes.c",
        "DRB_code": "/*\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n!!! Copyright (c) 2017-20, Lawrence Livermore National Security, LLC\n!!! and DataRaceBench project contributors. See the DataRaceBench/COPYRIGHT file for details.\n!!!\n!!! SPDX-License-Identifier: (BSD-3-Clause)\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n*/\n\n/*This example is referred from DRACC by Adrian Schmitz et al.\nVector addition followed by multiplication involving the same var should have a barrier in between.\nomp distribute directive does not have implicit barrier. This will cause data race.\nData Race Pair: b[i]@42:19:R vs. b[i]@47:9:W\n*/\n\n#include <stdio.h>\n#include <omp.h>\n#include <stdlib.h>\n#define N 100\n#define C 16\n\n\nint a;\nint b[C];\nint c[C];\nint temp[C];\n\nint main(){\n  for(int i=0; i<C; i++){\n    b[i]=0;\n    c[i]=2;\n    temp[i]=0;\n  }\n  a=2;\n\n  #pragma omp target map(tofrom:b[0:C]) map(to:c[0:C],temp[0:C],a) device(0)\n  {\n    #pragma omp teams\n    for(int i=0; i<N ;i++){\n      #pragma omp distribute\n      for(int i=0; i<C; i++){\n        temp[i] = b[i] + c[i];\n      }\n\n      #pragma omp distribute\n      for(int i=C-1; i>=0; i--){\n        b[i] = temp[i] * a;\n      }\n    }\n  }\n\n  int val = 0;\n\n  for(int i=0; i<N; i++){\n    val = val + 2;\n    val = val * 2;\n  }\n\n  for(int i=0; i<C; i++){\n    if(b[i]!=val){\n      printf(\"index: %d val: %d\\n\",i, b[i]);\n    }\n  }\n\n  return 0;\n}\n",
        "data_race": 1,
        "trimmed_code": "#include <stdio.h>\n#include <omp.h>\n#include <stdlib.h>\n#define N 100\n#define C 16\n\n\nint a;\nint b[C];\nint c[C];\nint temp[C];\n\nint main(){\n  for(int i=0; i<C; i++){\n    b[i]=0;\n    c[i]=2;\n    temp[i]=0;\n  }\n  a=2;\n\n  #pragma omp target map(tofrom:b[0:C]) map(to:c[0:C],temp[0:C],a) device(0)\n  {\n    #pragma omp teams\n    for(int i=0; i<N ;i++){\n      #pragma omp distribute\n      for(int i=0; i<C; i++){\n        temp[i] = b[i] + c[i];\n      }\n\n      #pragma omp distribute\n      for(int i=C-1; i>=0; i--){\n        b[i] = temp[i] * a;\n      }\n    }\n  }\n\n  int val = 0;\n\n  for(int i=0; i<N; i++){\n    val = val + 2;\n    val = val * 2;\n  }\n\n  for(int i=0; i<C; i++){\n    if(b[i]!=val){\n      printf(\"index: %d val: %d\\n\",i, b[i]);\n    }\n  }\n\n  return 0;\n}\n",
        "code_len": 754,
        "data_race_label": "Y5, Y3",
        "var_pairs": [
            "{\"name\": [\"b[i]\", \"b[i]\"],\n\"line\": [42, 47],\n\"col\": [19, 9],\n\"operation\": [\"R\", \"W\"]}"
        ]
    },
    {
        "ID": "161",
        "name": "DRB161-nolocksimd-orig-gpu-yes.c",
        "DRB_code": "/*\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n!!! Copyright (c) 2017-20, Lawrence Livermore National Security, LLC\n!!! and DataRaceBench project contributors. See the DataRaceBench/COPYRIGHT file for details.\n!!!\n!!! SPDX-License-Identifier: (BSD-3-Clause)\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n*/\n\n/* \nThis example is from DRACC by Adrian Schmitz et al.\nConcurrent access on a counter with no lock with simd. Atomicity Violation. Intra Region.\nData Race Pairs: var@33:7:W vs. var@33:7:W\n*/\n\n#include <stdio.h>\n#define N 20\n#define C 8\n\nint main(){\n  int var[C];\n\n  for(int i=0; i<C; i++){\n    var[i] = 0;\n  }\n\n  #pragma omp target map(tofrom:var) device(0)\n  #pragma omp teams num_teams(1) thread_limit(1048) \n  #pragma omp distribute parallel for \n  for (int i=0; i<N; i++){\n    #pragma omp simd\n    for(int i=0; i<C; i++){\n      var[i]++;\n    }\n  }\n\n  for(int i=0; i<C; i++){\n    if(var[i]!=N) printf(\"%d\\n \",var[i]);\n  }\n\n  return 0;\n}\n",
        "data_race": 1,
        "trimmed_code": "#include <stdio.h>\n#define N 20\n#define C 8\n\nint main(){\n  int var[C];\n\n  for(int i=0; i<C; i++){\n    var[i] = 0;\n  }\n\n  #pragma omp target map(tofrom:var) device(0)\n  #pragma omp teams num_teams(1) thread_limit(1048) \n  #pragma omp distribute parallel for \n  for (int i=0; i<N; i++){\n    #pragma omp simd\n    for(int i=0; i<C; i++){\n      var[i]++;\n    }\n  }\n\n  for(int i=0; i<C; i++){\n    if(var[i]!=N) printf(\"%d\\n \",var[i]);\n  }\n\n  return 0;\n}\n",
        "code_len": 448,
        "data_race_label": "Y5, Y3",
        "var_pairs": [
            "{\"name\": [\"var\", \"var\"],\n\"line\": [33, 33],\n\"col\": [7, 7],\n\"operation\": [\"W\", \"W\"]}"
        ]
    },
    {
        "ID": "162",
        "name": "DRB162-nolocksimd-orig-gpu-no.c",
        "DRB_code": "/*\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n!!! Copyright (c) 2017-20, Lawrence Livermore National Security, LLC\n!!! and DataRaceBench project contributors. See the DataRaceBench/COPYRIGHT file for details.\n!!!\n!!! SPDX-License-Identifier: (BSD-3-Clause)\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n*/\n\n/* \nReduction clause at line 27:39 will ensure there is no data race in var@31:7. No Dadta Race. \n*/\n\n#include <stdio.h>\n#define N 20\n#define C 8\n\nint main(){\n  int var[C];\n\n  for(int i=0; i<C; i++){\n    var[i] = 0;\n  }\n\n  #pragma omp target map(tofrom:var) device(0)\n  #pragma omp teams num_teams(1) thread_limit(1048) \n  #pragma omp distribute parallel for reduction(+:var)\n  for (int i=0; i<N; i++){\n    #pragma omp simd\n    for(int i=0; i<C; i++){\n      var[i]++;\n    }\n  }\n\n  for(int i=0; i<C; i++){\n    if(var[i]!=N) printf(\"%d\\n \",var[i]);\n  }\n\n  return 0;\n}\n",
        "data_race": 0,
        "trimmed_code": "#include <stdio.h>\n#define N 20\n#define C 8\n\nint main(){\n  int var[C];\n\n  for(int i=0; i<C; i++){\n    var[i] = 0;\n  }\n\n  #pragma omp target map(tofrom:var) device(0)\n  #pragma omp teams num_teams(1) thread_limit(1048) \n  #pragma omp distribute parallel for reduction(+:var)\n  for (int i=0; i<N; i++){\n    #pragma omp simd\n    for(int i=0; i<C; i++){\n      var[i]++;\n    }\n  }\n\n  for(int i=0; i<C; i++){\n    if(var[i]!=N) printf(\"%d\\n \",var[i]);\n  }\n\n  return 0;\n}\n",
        "code_len": 464,
        "data_race_label": "N5, N4",
        "var_pairs": []
    },
    {
        "ID": "163",
        "name": "DRB163-simdmissinglock1-orig-gpu-no.c",
        "DRB_code": "/*\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n!!! Copyright (c) 2017-20, Lawrence Livermore National Security, LLC\n!!! and DataRaceBench project contributors. See the DataRaceBench/COPYRIGHT file for details.\n!!!\n!!! SPDX-License-Identifier: (BSD-3-Clause)\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n*/\n\n/*\nConcurrent access of var@31:7 has no atomicity violation. No data race present.\n*/\n\n#include <stdio.h>\n#include <omp.h>\n#define N 100\n#define C 64\n\nint main(){\n  int var[C];\n\n  for(int i=0; i<C; i++){\n    var[i]=0;\n  }\n\n  #pragma omp target map(tofrom:var[0:C]) device(0)\n  #pragma omp teams distribute parallel for reduction(+:var) \n  for (int i=0; i<N; i++){\n    #pragma omp simd\n    for(int i=0; i<C; i++){\n      var[i]++;\n    }\n  }\n\n  for(int i=0; i<C; i++){\n    if(var[i]!=100){\n      printf(\"%d\\n\",var[i]);\n    }\n  }\n\n  return 0;\n}\n",
        "data_race": 0,
        "trimmed_code": "#include <stdio.h>\n#include <omp.h>\n#define N 100\n#define C 64\n\nint main(){\n  int var[C];\n\n  for(int i=0; i<C; i++){\n    var[i]=0;\n  }\n\n  #pragma omp target map(tofrom:var[0:C]) device(0)\n  #pragma omp teams distribute parallel for reduction(+:var) \n  for (int i=0; i<N; i++){\n    #pragma omp simd\n    for(int i=0; i<C; i++){\n      var[i]++;\n    }\n  }\n\n  for(int i=0; i<C; i++){\n    if(var[i]!=100){\n      printf(\"%d\\n\",var[i]);\n    }\n  }\n\n  return 0;\n}\n",
        "code_len": 454,
        "data_race_label": "N5, N4",
        "var_pairs": []
    },
    {
        "ID": "164",
        "name": "DRB164-simdmissinglock1-orig-gpu-yes.c",
        "DRB_code": "/*\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n!!! Copyright (c) 2017-20, Lawrence Livermore National Security, LLC\n!!! and DataRaceBench project contributors. See the DataRaceBench/COPYRIGHT file for details.\n!!!\n!!! SPDX-License-Identifier: (BSD-3-Clause)\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n*/\n\n/*\nThis kernel is referred from \u201cDataRaceOnAccelerator A Micro-benchmark Suite for Evaluating\nCorrectness Tools Targeting Accelerators\u201d by Adrian Schmitz et al.\nConcurrent access of var@35:7 without acquiring locks causes atomicity violation. Data race present.\nData Race Pairs, var@35:7:W vs. var@35:7:W\n*/\n\n#include <stdio.h>\n#include <omp.h>\n#define N 100\n#define C 64\n\nint main(){\n\n  int var[C];\n\n  for(int i=0; i<C; i++){\n    var[i]=0;\n  }\n\n  #pragma omp target map(tofrom:var[0:C]) device(0)\n  #pragma omp teams distribute parallel for\n  for (int i=0; i<N; i++){\n    #pragma omp simd\n    for(int i=0; i<C; i++){\n      var[i]++;\n    }\n  }\n\n  printf(\"%d\\n\",var[63]);\n\n  return 0;\n}\n",
        "data_race": 1,
        "trimmed_code": "#include <stdio.h>\n#include <omp.h>\n#define N 100\n#define C 64\n\nint main(){\n\n  int var[C];\n\n  for(int i=0; i<C; i++){\n    var[i]=0;\n  }\n\n  #pragma omp target map(tofrom:var[0:C]) device(0)\n  #pragma omp teams distribute parallel for\n  for (int i=0; i<N; i++){\n    #pragma omp simd\n    for(int i=0; i<C; i++){\n      var[i]++;\n    }\n  }\n\n  printf(\"%d\\n\",var[63]);\n\n  return 0;\n}\n",
        "code_len": 377,
        "data_race_label": "Y5, Y3",
        "var_pairs": [
            "{\"name\": [\"var\", \"var\"],\n\"line\": [35, 35],\n\"col\": [7, 7],\n\"operation\": [\"W\", \"W\"]}"
        ]
    },
    {
        "ID": "165",
        "name": "DRB165-taskdep4-orig-omp50-yes.c",
        "DRB_code": "/*\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n!!! Copyright (c) 2017-20, Lawrence Livermore National Security, LLC\n!!! and DataRaceBench project contributors. See the DataRaceBench/COPYRIGHT file for details.\n!!!\n!!! SPDX-License-Identifier: (BSD-3-Clause)\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n */\n\n/*\n * There is no completion restraint on the second child task. Hence, immediately after the first\n * taskwait it is unsafe to access the y variable since the second child task may still be\n * executing.\n * Data Race at y@28:2:W vs. y@33:19:R\n*/\n\n#include <stdio.h>\n#include <omp.h>\n\nvoid foo(){\n\n  int x = 0, y = 2;\n\n  #pragma omp task depend(inout: x) shared(x)\n  x++;                                                //1st Child Task\n\n  #pragma omp task shared(y)\n  y--;                                                // 2nd child task\n\n  #pragma omp taskwait depend(in: x)                  // 1st taskwait\n\n  printf(\"x=%d\\n\",x);\n  printf(\"y=%d\\n\",y);\n  #pragma omp taskwait                                // 2nd taskwait\n}\n\n\nint main(){\n  #pragma omp parallel\n  #pragma omp single\n  foo();\n\n  return 0;\n}\n",
        "data_race": 1,
        "trimmed_code": "#include <stdio.h>\n#include <omp.h>\n\nvoid foo(){\n\n  int x = 0, y = 2;\n\n  #pragma omp task depend(inout: x) shared(x)\n  x++;                                                \n\n  #pragma omp task shared(y)\n  y--;                                                \n\n  #pragma omp taskwait depend(in: x)                  \n\n  printf(\"x=%d\\n\",x);\n  printf(\"y=%d\\n\",y);\n  #pragma omp taskwait                                \n}\n\n\nint main(){\n  #pragma omp parallel\n  #pragma omp single\n  foo();\n\n  return 0;\n}\n",
        "code_len": 497,
        "data_race_label": "Y3",
        "var_pairs": [
            {
                "name": [
                    "y",
                    "y"
                ],
                "line": [
                    28,
                    33
                ],
                "col": [
                    2,
                    19
                ],
                "operation": [
                    "W",
                    "R"
                ]
            }
        ]
    },
    {
        "ID": "166",
        "name": "DRB166-taskdep4-orig-omp50-no.c",
        "DRB_code": "/*\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n!!! Copyright (c) 2017-20, Lawrence Livermore National Security, LLC\n!!! and DataRaceBench project contributors. See the DataRaceBench/COPYRIGHT file for details.\n!!!\n!!! SPDX-License-Identifier: (BSD-3-Clause)\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n */\n\n/* The second taskwait ensures that the second child task has completed; hence it is safe to access\n * the y variable in the following print statement.\n * */\n\n\n#include <stdio.h>\n#include <omp.h>\n\nvoid foo(){\n\n  int x = 0, y = 2;\n\n  #pragma omp task depend(inout: x) shared(x)\n  x++;                                                //1st Child Task\n\n  #pragma omp task shared(y)\n  y--;                                                // 2nd child task\n\n  #pragma omp taskwait depend(in: x)                  // 1st taskwait\n\n  printf(\"x=%d\\n\",x);\n\n  #pragma omp taskwait                                // 2nd taskwait\n\n  printf(\"y=%d\\n\",y);\n}\n\n\nint main(){\n  #pragma omp parallel\n  #pragma omp single\n  foo();\n\n  return 0;\n}\n\n",
        "data_race": 0,
        "trimmed_code": "#include <stdio.h>\n#include <omp.h>\n\nvoid foo(){\n\n  int x = 0, y = 2;\n\n  #pragma omp task depend(inout: x) shared(x)\n  x++;                                                \n\n  #pragma omp task shared(y)\n  y--;                                                \n\n  #pragma omp taskwait depend(in: x)                  \n\n  printf(\"x=%d\\n\",x);\n\n  #pragma omp taskwait                                \n\n  printf(\"y=%d\\n\",y);\n}\n\n\nint main(){\n  #pragma omp parallel\n  #pragma omp single\n  foo();\n\n  return 0;\n}\n\n",
        "code_len": 500,
        "data_race_label": "N1",
        "var_pairs": []
    },
    {
        "ID": "167",
        "name": "DRB167-taskdep4-orig-omp50-no.c",
        "DRB_code": "/*\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n!!! Copyright (c) 2017-20, Lawrence Livermore National Security, LLC\n!!! and DataRaceBench project contributors. See the DataRaceBench/COPYRIGHT file for details.\n!!!\n!!! SPDX-License-Identifier: (BSD-3-Clause)\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n */\n\n/* The first two tasks are serialized, because a dependence on the first child is produced\n * by x with the in dependence type in the depend clause of the second task. Generating task\n * at the first taskwait only waits for the first child task to complete. The second taskwait\n * guarantees completion of the second task before y is accessed. Therefore there is no race\n * condition.\n * */\n\n\n#include <stdio.h>\n#include <omp.h>\n\nvoid foo(){\n  int x = 0, y = 2;\n\n  #pragma omp task depend(inout: x) shared(x)\n  x++;                                                                  // 1st child task\n\n  #pragma omp task depend(in: x) depend(inout: y) shared(x, y)\n  y = y-x;                                                              //2nd child task\n\n  #pragma omp taskwait depend(in: x)                                    // 1st taskwait\n\n  printf(\"x=%d\\n\",x);\n\n  #pragma omp taskwait                                                  // 2nd taskwait\n\n  printf(\"y=%d\\n\",y);\n}\n\nint main(){\n  #pragma omp parallel\n  #pragma omp single\n  foo();\n\n  return 0;\n}\n\n",
        "data_race": 0,
        "trimmed_code": "#include <stdio.h>\n#include <omp.h>\n\nvoid foo(){\n  int x = 0, y = 2;\n\n  #pragma omp task depend(inout: x) shared(x)\n  x++;                                                                  \n\n  #pragma omp task depend(in: x) depend(inout: y) shared(x, y)\n  y = y-x;                                                              \n\n  #pragma omp taskwait depend(in: x)                                    \n\n  printf(\"x=%d\\n\",x);\n\n  #pragma omp taskwait                                                  \n\n  printf(\"y=%d\\n\",y);\n}\n\nint main(){\n  #pragma omp parallel\n  #pragma omp single\n  foo();\n\n  return 0;\n}\n\n",
        "code_len": 604,
        "data_race_label": "N1",
        "var_pairs": []
    },
    {
        "ID": "168",
        "name": "DRB168-taskdep5-orig-omp50-yes.c",
        "DRB_code": "/*\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n!!! Copyright (c) 2017-20, Lawrence Livermore National Security, LLC\n!!! and DataRaceBench project contributors. See the DataRaceBench/COPYRIGHT file for details.\n!!!\n!!! SPDX-License-Identifier: (BSD-3-Clause)\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n */\n\n/* The first two tasks are serialized, because a dependence on the first child is produced\n * by x with the in dependence type in the depend clause of the second task. Generating task\n * at the first taskwait only waits for the first child task to complete. The second taskwait\n * guarantees completion of the second task before y is accessed. If we access y before the\n * second taskwait, there is a race condition at line 28 ann 33. Data Race Pair, y@28:2:W vs. y@33:19:R\n * */\n\n\n#include <stdio.h>\n#include <omp.h>\n\nvoid foo(){\n  int x = 0, y = 2;\n\n  #pragma omp task depend(inout: x) shared(x)\n  x++;                                                             // 1st child task\n\n  #pragma omp task depend(in: x) depend(inout: y) shared(x, y)\n  y -= x;                                                         //2nd child task\n\n  #pragma omp taskwait depend(in: x)                               // 1st taskwait\n\n  printf(\"x=%d\\n\",x);\n  printf(\"y=%d\\n\",y);\n\n  #pragma omp taskwait\t\t                                         // 2nd taskwait\n\n}\n\nint main(){\n  #pragma omp parallel\n  #pragma omp single\n  foo();\n\n  return 0;\n}\n\n",
        "data_race": 1,
        "trimmed_code": "#include <stdio.h>\n#include <omp.h>\n\nvoid foo(){\n  int x = 0, y = 2;\n\n  #pragma omp task depend(inout: x) shared(x)\n  x++;                                                             \n\n  #pragma omp task depend(in: x) depend(inout: y) shared(x, y)\n  y -= x;                                                         \n\n  #pragma omp taskwait depend(in: x)                               \n\n  printf(\"x=%d\\n\",x);\n  printf(\"y=%d\\n\",y);\n\n  #pragma omp taskwait\t\t                                         \n\n}\n\nint main(){\n  #pragma omp parallel\n  #pragma omp single\n  foo();\n\n  return 0;\n}\n\n",
        "code_len": 581,
        "data_race_label": "Y1",
        "var_pairs": [
            "{\"name\": [\"y\", \"y\"],\n\"line\": [28, 33],\n\"col\": [2, 19],\n\"operation\": [\"W\", \"R\"]}"
        ]
    },
    {
        "ID": "169",
        "name": "DRB169-missingsyncwrite-orig-yes.c",
        "DRB_code": "/*\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n!!! Copyright (c) 2017-20, Lawrence Livermore National Security, LLC\n!!! and DataRaceBench project contributors. See the DataRaceBench/COPYRIGHT file for details.\n!!!\n!!! SPDX-License-Identifier: (BSD-3-Clause)\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n*/\n\n/* This kernel imitates the nature of a program from the NAS Parallel Benchmarks 3.0 MG suit.\n * Due to missing construct to write r1[k]@38:9 synchronously, there is a Data Race.\n * Data Race Pair, r1[k]@38:9:W vs. r1[k]@38:9:W\n * */\n\n#include <stdio.h>\n#include <omp.h>\n\n#define N 8\n\nint main()\n{\n  int i,j,k;\n  double r1[N], r[N][N][N];\n\n  for (i = 0; i < N; i++) {\n    for (j = 0; j < N; j++) {\n      for (k = 0; k < N; k++) {\n        r[i][j][k] = i;\n      }\n    }\n  }\n\n\n  #pragma omp parallel for default(shared) private(j,k)\n  for (i = 1; i < N-1; i++) {\n    for (j = 1; j < N-1; j++) {\n      for (k = 0; k < N; k++) {\n        r1[k] = r[i][j-1][k] + r[i][j+1][k] + r[i-1][j][k] + r[i+1][j][k];\n      }\n    }\n  }\n\n  for (k = 0; k < N; k++) printf(\"%f \",r1[k]);\n\n  printf(\"\\n\");\n\n  return 0;\n}\n\n",
        "data_race": 1,
        "trimmed_code": "#include <stdio.h>\n#include <omp.h>\n\n#define N 8\n\nint main()\n{\n  int i,j,k;\n  double r1[N], r[N][N][N];\n\n  for (i = 0; i < N; i++) {\n    for (j = 0; j < N; j++) {\n      for (k = 0; k < N; k++) {\n        r[i][j][k] = i;\n      }\n    }\n  }\n\n\n  #pragma omp parallel for default(shared) private(j,k)\n  for (i = 1; i < N-1; i++) {\n    for (j = 1; j < N-1; j++) {\n      for (k = 0; k < N; k++) {\n        r1[k] = r[i][j-1][k] + r[i][j+1][k] + r[i-1][j][k] + r[i+1][j][k];\n      }\n    }\n  }\n\n  for (k = 0; k < N; k++) printf(\"%f \",r1[k]);\n\n  printf(\"\\n\");\n\n  return 0;\n}\n\n",
        "code_len": 563,
        "data_race_label": "Y6",
        "var_pairs": [
            "{\"name\": [\"r1[k]\", \"r1[k]\"],\n\"line\": [38, 38],\n\"col\": [9, 9],\n\"operation\": [\"W\", \"W\"]}"
        ]
    },
    {
        "ID": "170",
        "name": "DRB170-nestedloops-orig-no.c",
        "DRB_code": "/*\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n!!! Copyright (c) 2017-20, Lawrence Livermore National Security, LLC\n!!! and DataRaceBench project contributors. See the DataRaceBench/COPYRIGHT file for details.\n!!!\n!!! SPDX-License-Identifier: (BSD-3-Clause)\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n*/\n\n/* This kernel imitates the nature of a program from the NAS Parallel Benchmarks 3.0 MG suit.\n * Use of private clause at 26:28 will ensure that there is no data race. No Data Race Pairs. \n */\n\n\n#include <stdio.h>\n#include <omp.h>\n\nint main(){\n  int i,j,k,m;\n  double tmp1;\n\n  double a[12][12][12];\n\n  m = 3.0;\n\n  #pragma omp parallel for private(j,k,tmp1)   \n  for (i = 0; i < 12; i++) {\n    for (j = 0; j < 12; j++) {\n      for (k = 0; k < 12; k++) {\n        tmp1 = 6.0/m;\n        a[i][j][k] = tmp1+4;\n      }\n    }\n  }\n\n  return 0;\n}\n\n",
        "data_race": 0,
        "trimmed_code": "#include <stdio.h>\n#include <omp.h>\n\nint main(){\n  int i,j,k,m;\n  double tmp1;\n\n  double a[12][12][12];\n\n  m = 3.0;\n\n  #pragma omp parallel for private(j,k,tmp1)   \n  for (i = 0; i < 12; i++) {\n    for (j = 0; j < 12; j++) {\n      for (k = 0; k < 12; k++) {\n        tmp1 = 6.0/m;\n        a[i][j][k] = tmp1+4;\n      }\n    }\n  }\n\n  return 0;\n}\n\n",
        "code_len": 343,
        "data_race_label": "N2",
        "var_pairs": []
    },
    {
        "ID": "171",
        "name": "DRB171-threadprivate3-orig-no.c",
        "DRB_code": "/*\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n!!! Copyright (c) 2017-20, Lawrence Livermore National Security, LLC\n!!! and DataRaceBench project contributors. See the DataRaceBench/COPYRIGHT file for details.\n!!!\n!!! SPDX-License-Identifier: (BSD-3-Clause)\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n*/\n\n/* This kernel imitates the nature of a program from the NAS Parallel Benchmarks 3.0 MG suit.\n * There is no data race pairs, example of a threadprivate var and update by TID==0 only.\n */\n\n#include <omp.h>\n#include <stdio.h>\n\nstatic double x[20];\n#pragma omp threadprivate(x)\n\nint main(){\n  int i;\n  double j,k;\n\n  #pragma omp parallel for default(shared)\n  for (i = 0; i < 20; i++){\n    x[i] = -1.0;\n    if(omp_get_thread_num()==0){\n      j = x[0];\n    }\n    if(omp_get_thread_num()==0){\n      k = i+0.05;\n    }\n  }\n\n  printf (\"%f %f\\n\", j, k);\n\n  return 0;\n}\n\n",
        "data_race": 0,
        "trimmed_code": "#include <omp.h>\n#include <stdio.h>\n\nstatic double x[20];\n#pragma omp threadprivate(x)\n\nint main(){\n  int i;\n  double j,k;\n\n  #pragma omp parallel for default(shared)\n  for (i = 0; i < 20; i++){\n    x[i] = -1.0;\n    if(omp_get_thread_num()==0){\n      j = x[0];\n    }\n    if(omp_get_thread_num()==0){\n      k = i+0.05;\n    }\n  }\n\n  printf (\"%f %f\\n\", j, k);\n\n  return 0;\n}\n\n",
        "code_len": 373,
        "data_race_label": "N1",
        "var_pairs": []
    },
    {
        "ID": "172",
        "name": "DRB172-critical2-orig-no.c",
        "DRB_code": "/*\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n!!! Copyright (c) 2017-20, Lawrence Livermore National Security, LLC\n!!! and DataRaceBench project contributors. See the DataRaceBench/COPYRIGHT file for details.\n!!!\n!!! SPDX-License-Identifier: (BSD-3-Clause)\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n */\n\n/* This kernel imitates the nature of a program from the NAS Parallel Benchmarks 3.0 MG suit.\n * The private(i) inline 27 and explicit barrier inline 35 will ensure synchronized behavior.\n * No Data Race Pairs.\n */\n\n#include <omp.h>\n#include <stdio.h>\n\nint main(){\n  int i;\n  double q[10], qq[10];\n\n  for (i = 0; i < 10; i++) qq[i] = (double)i;\n  for (i = 0; i < 10; i++) q[i] = (double)i;\n\n  #pragma omp parallel default(shared)\n  {\n    #pragma omp for private(i)\n    for (i = 0; i < 10; i++)\n      q[i] += qq[i];\n\n    #pragma omp critical\n    {\n      q[9] += 1.0;\n    }\n    #pragma omp barrier\n    #pragma omp single\n    {\n      q[9] = q[9] - 1.0;\n    }\n\n  } \n\n  for (i = 0; i < 10; i++)printf(\"%f %f\\n\",qq[i],q[i]);\n\n  return 0;\n}\n\n",
        "data_race": 0,
        "trimmed_code": "#include <omp.h>\n#include <stdio.h>\n\nint main(){\n  int i;\n  double q[10], qq[10];\n\n  for (i = 0; i < 10; i++) qq[i] = (double)i;\n  for (i = 0; i < 10; i++) q[i] = (double)i;\n\n  #pragma omp parallel default(shared)\n  {\n    #pragma omp for private(i)\n    for (i = 0; i < 10; i++)\n      q[i] += qq[i];\n\n    #pragma omp critical\n    {\n      q[9] += 1.0;\n    }\n    #pragma omp barrier\n    #pragma omp single\n    {\n      q[9] = q[9] - 1.0;\n    }\n\n  } \n\n  for (i = 0; i < 10; i++)printf(\"%f %f\\n\",qq[i],q[i]);\n\n  return 0;\n}\n\n",
        "code_len": 519,
        "data_race_label": "N2, N3",
        "var_pairs": []
    },
    {
        "ID": "173",
        "name": "DRB173-non-sibling-taskdep-yes.c",
        "DRB_code": "/*\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n!!! Copyright (c) 2017-20, Lawrence Livermore National Security, LLC\n!!! and DataRaceBench project contributors. See the DataRaceBench/COPYRIGHT file\nfor details.\n!!!\n!!! SPDX-License-Identifier: (BSD-3-Clause)\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n */\n\n/* \n * Data race between non-sibling tasks with declared task dependency\n * Derived from code in https://hal.archives-ouvertes.fr/hal-02177469/document,\n * Listing 1.1\n * Data Race Pair, a@30:7:W vs. a@36:7:W\n * */\n\n#include <omp.h>\n#include <stdio.h>\n\nvoid foo() {\n  int a = 0;\n\n#pragma omp parallel\n#pragma omp single\n  {\n#pragma omp task depend(inout : a) shared(a)\n    {\n#pragma omp task depend(inout : a) shared(a)\n      a++;\n    }\n\n#pragma omp task depend(inout : a) shared(a)\n    {\n#pragma omp task depend(inout : a) shared(a)\n      a++;\n    }\n  }\n\n  printf(\"a=%d\\n\", a);\n}\n\nint main() {\n  foo();\n\n  return 0;\n}\n",
        "data_race": 1,
        "trimmed_code": "#include <omp.h>\n#include <stdio.h>\n\nvoid foo() {\n  int a = 0;\n\n#pragma omp parallel\n#pragma omp single\n  {\n#pragma omp task depend(inout : a) shared(a)\n    {\n#pragma omp task depend(inout : a) shared(a)\n      a++;\n    }\n\n#pragma omp task depend(inout : a) shared(a)\n    {\n#pragma omp task depend(inout : a) shared(a)\n      a++;\n    }\n  }\n\n  printf(\"a=%d\\n\", a);\n}\n\nint main() {\n  foo();\n\n  return 0;\n}\n",
        "code_len": 403,
        "data_race_label": "Y6",
        "var_pairs": [
            "{\"name\": [\"a\", \"a\"],\n\"line\": [30, 36],\n\"col\": [7, 7],\n\"operation\": [\"W\", \"W\"]}"
        ]
    },
    {
        "ID": "174",
        "name": "DRB174-non-sibling-taskdep-no.c",
        "DRB_code": "/*\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n!!! Copyright (c) 2017-20, Lawrence Livermore National Security, LLC\n!!! and DataRaceBench project contributors. See the DataRaceBench/COPYRIGHT file\nfor details.\n!!!\n!!! SPDX-License-Identifier: (BSD-3-Clause)\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n */\n\n/* \n * Data race between non-sibling tasks with declared task dependency fixed by\n * adding a taskwait.\n * Derived from code in https://hal.archives-ouvertes.fr/hal-02177469/document,\n * Listing 1.2\n * No Data Race Pair\n * */\n\n#include <omp.h>\n#include <stdio.h>\n\nvoid foo() {\n  int a = 0;\n\n#pragma omp parallel\n#pragma omp single\n  {\n#pragma omp task depend(inout : a) shared(a)\n    {\n#pragma omp task depend(inout : a) shared(a)\n      a++;\n#pragma omp taskwait\n    }\n\n#pragma omp task depend(inout : a) shared(a)\n    {\n#pragma omp task depend(inout : a) shared(a)\n      a++;\n#pragma omp taskwait\n    }\n  }\n\n  printf(\"a=%d\\n\", a);\n}\n\nint main() {\n  foo();\n\n  return 0;\n}\n",
        "data_race": 0,
        "trimmed_code": "#include <omp.h>\n#include <stdio.h>\n\nvoid foo() {\n  int a = 0;\n\n#pragma omp parallel\n#pragma omp single\n  {\n#pragma omp task depend(inout : a) shared(a)\n    {\n#pragma omp task depend(inout : a) shared(a)\n      a++;\n#pragma omp taskwait\n    }\n\n#pragma omp task depend(inout : a) shared(a)\n    {\n#pragma omp task depend(inout : a) shared(a)\n      a++;\n#pragma omp taskwait\n    }\n  }\n\n  printf(\"a=%d\\n\", a);\n}\n\nint main() {\n  foo();\n\n  return 0;\n}\n",
        "code_len": 445,
        "data_race_label": "N3",
        "var_pairs": []
    },
    {
        "ID": "175",
        "name": "DRB175-non-sibling-taskdep2-yes.c",
        "DRB_code": "/*\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n!!! Copyright (c) 2017-20, Lawrence Livermore National Security, LLC\n!!! and DataRaceBench project contributors. See the DataRaceBench/COPYRIGHT file\nfor details.\n!!!\n!!! SPDX-License-Identifier: (BSD-3-Clause)\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n */\n\n/* \n * Data race between non-sibling tasks created from different implicit tasks \n * with declared task dependency\n * Derived from code in https://hal.archives-ouvertes.fr/hal-02177469/document,\n * Listing 1.3\n * Data Race Pair, a@28:6:W vs. a@28:6:W\n * */\n\n#include <omp.h>\n#include <stdio.h>\n\nvoid foo() {\n  int a = 0;\n\n#pragma omp parallel\n  {\n#pragma omp task depend(inout : a) shared(a)\n    a++;\n  }\n  printf(\"a=%d\\n\", a);\n}\n\nint main() {\n  foo();\n\n  return 0;\n}\n",
        "data_race": 1,
        "trimmed_code": "#include <omp.h>\n#include <stdio.h>\n\nvoid foo() {\n  int a = 0;\n\n#pragma omp parallel\n  {\n#pragma omp task depend(inout : a) shared(a)\n    a++;\n  }\n  printf(\"a=%d\\n\", a);\n}\n\nint main() {\n  foo();\n\n  return 0;\n}\n",
        "code_len": 210,
        "data_race_label": "Y6",
        "var_pairs": [
            "{\"name\": [\"a\", \"a\"],\n\"line\": [28, 28],\n\"col\": [6, 6],\n\"operation\": [\"W\", \"W\"]}"
        ]
    },
    {
        "ID": "176",
        "name": "DRB176-fib-taskdep-no.c",
        "DRB_code": "/*\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n!!! Copyright (c) 2017-20, Lawrence Livermore National Security, LLC\n!!! and DataRaceBench project contributors. See the DataRaceBench/COPYRIGHT file for details.\n!!!\n!!! SPDX-License-Identifier: (BSD-3-Clause)\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n */\n\n/* \n * Fibonacci code without data race\n * No Data Race Pair\n * */\n\n#include <stdio.h>\n#include <stdlib.h>\n\nint fib(int n) {\n  int i, j, s;\n  if (n < 2)\n    return n;\n#pragma omp task shared(i) depend(out : i)\n  i = fib(n - 1);\n#pragma omp task shared(j) depend(out : j)\n  j = fib(n - 2);\n#pragma omp task shared(i, j) depend(in : i, j)\n  s = i + j;\n#pragma omp taskwait\n  return i + j;\n}\n\nint main(int argc, char **argv) {\n  int n = 10;\n  if (argc > 1)\n    n = atoi(argv[1]);\n#pragma omp parallel sections\n  { printf(\"fib(%i) = %i\\n\", n, fib(n)); }\n  return 0;\n}\n",
        "data_race": 0,
        "trimmed_code": "#include <stdio.h>\n#include <stdlib.h>\n\nint fib(int n) {\n  int i, j, s;\n  if (n < 2)\n    return n;\n#pragma omp task shared(i) depend(out : i)\n  i = fib(n - 1);\n#pragma omp task shared(j) depend(out : j)\n  j = fib(n - 2);\n#pragma omp task shared(i, j) depend(in : i, j)\n  s = i + j;\n#pragma omp taskwait\n  return i + j;\n}\n\nint main(int argc, char **argv) {\n  int n = 10;\n  if (argc > 1)\n    n = atoi(argv[1]);\n#pragma omp parallel sections\n  { printf(\"fib(%i) = %i\\n\", n, fib(n)); }\n  return 0;\n}\n",
        "code_len": 496,
        "data_race_label": "N3",
        "var_pairs": []
    },
    {
        "ID": "177",
        "name": "DRB177-fib-taskdep-yes.c",
        "DRB_code": "/*\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n!!! Copyright (c) 2017-20, Lawrence Livermore National Security, LLC\n!!! and DataRaceBench project contributors. See the DataRaceBench/COPYRIGHT file\nfor details.\n!!!\n!!! SPDX-License-Identifier: (BSD-3-Clause)\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n */\n\n/* \n * Fibonacci code with data race (possible to scale problem size by providing\n * size argument).\n * Data Race Pair, i@25:5:W vs. i@29:7:R\n * */\n\n#include <stdio.h>\n#include <stdlib.h>\n\nint fib(int n) {\n  int i, j, s;\n  if (n < 2)\n    return n;\n#pragma omp task shared(i) depend(out : i)\n  i = fib(n - 1);\n#pragma omp task shared(j) depend(out : j)\n  j = fib(n - 2);\n#pragma omp task shared(i, j) depend(in : j)\n  s = i + j;\n#pragma omp taskwait\n  return i + j;\n}\n\nint main(int argc, char **argv) {\n  int n = 10;\n  if (argc > 1)\n    n = atoi(argv[1]);\n#pragma omp parallel sections\n  { printf(\"fib(%i) = %i\\n\", n, fib(n)); }\n  return 0;\n}\n",
        "data_race": 1,
        "trimmed_code": "#include <stdio.h>\n#include <stdlib.h>\n\nint fib(int n) {\n  int i, j, s;\n  if (n < 2)\n    return n;\n#pragma omp task shared(i) depend(out : i)\n  i = fib(n - 1);\n#pragma omp task shared(j) depend(out : j)\n  j = fib(n - 2);\n#pragma omp task shared(i, j) depend(in : j)\n  s = i + j;\n#pragma omp taskwait\n  return i + j;\n}\n\nint main(int argc, char **argv) {\n  int n = 10;\n  if (argc > 1)\n    n = atoi(argv[1]);\n#pragma omp parallel sections\n  { printf(\"fib(%i) = %i\\n\", n, fib(n)); }\n  return 0;\n}\n",
        "code_len": 493,
        "data_race_label": "Y6",
        "var_pairs": [
            "{\"name\": [\"i\", \"i\"],\n\"line\": [25, 29],\n\"col\": [5, 7],\n\"operation\": [\"W\", \"R\"]}"
        ]
    },
    {
        "ID": "178",
        "name": "DRB178-input-dependence-var-yes.c",
        "DRB_code": "/*\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n!!! Copyright (c) 2017-20, Lawrence Livermore National Security, LLC\n!!! and DataRaceBench project contributors. See the DataRaceBench/COPYRIGHT file\nfor details.\n!!!\n!!! SPDX-License-Identifier: (BSD-3-Clause)\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n */\n\n/* \n * Input dependence race: example from OMPRacer: A Scalable and Precise Static Race\n   Detector for OpenMP Programs\n * Data Race Pair, A[0]@45:7:W vs. A[i]@42:5:W\n * */\n\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid load_from_input(int *data, int size)\n{\n  for(int i = 0; i < size; i++) {\n    data[i] = size-i;\n  } \n}\n\n\nint main(int argc, char *argv[]) {\n\n  int *A; \n  int N = 100;\n\n  if (argc>1)\n    N = atoi(argv[1]);\n\n  A = (int*) malloc(sizeof(int) * N);\n\n  load_from_input(A, N);\n  \n#pragma omp parallel for shared(A)\n  for(int i = 0; i < N; i++) {\n    A[i] = i;\n    if (N > 10000) \n    { \n      A[0] = 1; \n    }\n  }\n\n  free(A);\n  return 0;\n}\n",
        "data_race": 1,
        "trimmed_code": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid load_from_input(int *data, int size)\n{\n  for(int i = 0; i < size; i++) {\n    data[i] = size-i;\n  } \n}\n\n\nint main(int argc, char *argv[]) {\n\n  int *A; \n  int N = 100;\n\n  if (argc>1)\n    N = atoi(argv[1]);\n\n  A = (int*) malloc(sizeof(int) * N);\n\n  load_from_input(A, N);\n  \n#pragma omp parallel for shared(A)\n  for(int i = 0; i < N; i++) {\n    A[i] = i;\n    if (N > 10000) \n    { \n      A[0] = 1; \n    }\n  }\n\n  free(A);\n  return 0;\n}\n",
        "code_len": 477,
        "data_race_label": "Y1",
        "var_pairs": [
            "{\"name\": [\"A[0]\", \"A[i]\"],\n\"line\": [45, 42],\n\"col\": [7, 5],\n\"operation\": [\"W\", \"W\"]}"
        ]
    },
    {
        "ID": "179",
        "name": "DRB179-thread-sensitivity-yes.c",
        "DRB_code": "/*\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n!!! Copyright (c) 2017-20, Lawrence Livermore National Security, LLC\n!!! and DataRaceBench project contributors. See the DataRaceBench/COPYRIGHT file\nfor details.\n!!!\n!!! SPDX-License-Identifier: (BSD-3-Clause)\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n */\n\n/* \n   Iteration 0 and 1 can have conflicting writes to A[0]. But if they are scheduled to be run by \n   the same thread, dynamic tools may miss this.\n   Data Race Pair, A[0]@34:7:W vs. A[i]@31:5:W\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n\n\nint main(int argc, char *argv[]) {\n\n  int *A; \n  int N = 100;\n\n  A = (int*) malloc(sizeof(int) * N);\n\n  \n#pragma omp parallel for shared(A)\n  for(int i = 0; i < N; i++) {\n    A[i] = i;\n    if (i == 1) \n    { \n      A[0] = 1; \n    }\n  }\n\n  free(A);\n  return 0;\n}\n",
        "data_race": 1,
        "trimmed_code": "#include <stdio.h>\n#include <stdlib.h>\n\n\nint main(int argc, char *argv[]) {\n\n  int *A; \n  int N = 100;\n\n  A = (int*) malloc(sizeof(int) * N);\n\n  \n#pragma omp parallel for shared(A)\n  for(int i = 0; i < N; i++) {\n    A[i] = i;\n    if (i == 1) \n    { \n      A[0] = 1; \n    }\n  }\n\n  free(A);\n  return 0;\n}\n",
        "code_len": 303,
        "data_race_label": "Y6",
        "var_pairs": [
            "{\"name\": [\"A[0]\", \"A[i]\"],\n\"line\": [34, 31],\n\"col\": [7, 5],\n\"operation\": [\"W\", \"W\"]}"
        ]
    },
    {
        "ID": "180",
        "name": "DRB180-miniAMR-yes.c",
        "DRB_code": "/*\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n!!! Copyright (c) 2017-20, Lawrence Livermore National Security, LLC\n!!! and DataRaceBench project contributors. See the DataRaceBench/COPYRIGHT file\nfor details.\n!!!\n!!! SPDX-License-Identifier: (BSD-3-Clause)\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n */\n\n/*\n   Simplified miniAMR proxy app to reproduce data race behavior. \n   Data Race Pair, in@60:43:R vs. in@52:43:W\n                   work@65:19@W vs. work@65:19@W \n                   bp->array@65:36@R vs. bp->array@75:19@W \n                   bp->array@66:36@R vs. bp->array@75:19@W \n                   bp->array@67:36@R vs. bp->array@75:19@W \n                   bp->array@68:36@R vs. bp->array@75:19@W \n                   bp->array@69:36@R vs. bp->array@75:19@W \n                   bp->array@70:36@R vs. bp->array@75:19@W \n                   bp->array@71:36@R vs. bp->array@75:19@W \n */\n\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef long long num_sz;\n\nint max_num_blocks;\nint num_refine;\nint num_vars;\nint x_block_size, y_block_size, z_block_size;\nint error_tol;\n\ndouble tol;\n\ntypedef struct {\n   num_sz number;\n   int level;\n   int refine;\n   int new_proc;\n   num_sz parent;       // if original block -1,\n                     // else if on node, number in structure\n                     // else (-2 - parent->number)\n   double ****array;\n} block;\n\nblock *blocks;\n\nvoid stencil_calc(int var, int stencil_in)\n{\n   int i, j, k, in;\n   double sb, sm, sf, work[x_block_size+2][y_block_size+2][z_block_size+2];\n   block *bp;\n\n   int tid;\n\n#pragma omp parallel default(shared) private(i, j, k, bp)\n  {\n      for (in = 0; in < max_num_blocks; ++in) {\n         bp = &blocks[in];\n         for (i = 1; i <= x_block_size; i++)\n            for (j = 1; j <= y_block_size; j++)\n               for (k = 1; k <= z_block_size; k++)\n                  work[i][j][k] = (bp->array[var][i-1][j  ][k  ] +\n                                   bp->array[var][i  ][j-1][k  ] +\n                                   bp->array[var][i  ][j  ][k-1] +\n                                   bp->array[var][i  ][j  ][k  ] +\n                                   bp->array[var][i  ][j  ][k+1] +\n                                   bp->array[var][i  ][j+1][k  ] +\n                                   bp->array[var][i+1][j  ][k  ])/7.0;\n         for (i = 1; i <= x_block_size; i++)\n            for (j = 1; j <= y_block_size; j++)\n               for (k = 1; k <= z_block_size; k++)\n                  bp->array[var][i][j][k] = work[i][j][k];\n      }\n  }\n}\n\n\nvoid allocate(void)\n{\n   int i, j, k, m, n;\n\n   blocks = (block *) malloc(max_num_blocks*sizeof(block));\n\n   for (n = 0; n < max_num_blocks; n++) {\n      blocks[n].number = -1;\n      blocks[n].array = (double ****) malloc(num_vars*sizeof(double ***));\n      for (m = 0; m < num_vars; m++) {\n         blocks[n].array[m] = (double ***)\n                              malloc((x_block_size+2)*sizeof(double **));\n         for (i = 0; i < x_block_size+2; i++) {\n            blocks[n].array[m][i] = (double **)\n                                   malloc((y_block_size+2)*sizeof(double *));\n            for (j = 0; j < y_block_size+2; j++)\n               blocks[n].array[m][i][j] = (double *)\n                                     malloc((z_block_size+2)*sizeof(double));\n         }\n      }\n   }\n}\n\nvoid deallocate(void)\n{\n   int i, j, m, n;\n\n   for (n = 0; n < max_num_blocks; n++) {\n      for (m = 0; m < num_vars; m++) {\n         for (i = 0; i < x_block_size+2; i++) {\n            for (j = 0; j < y_block_size+2; j++)\n               free(blocks[n].array[m][i][j]);\n            free(blocks[n].array[m][i]);\n         }\n         free(blocks[n].array[m]);\n      }\n      free(blocks[n].array);\n   }\n   free(blocks);\n}\n\nvoid init(void)\n{\n   int n, var, i, j, k, l, m, o, size, dir, i1, i2, j1, j2, k1, k2, ib, jb, kb;\n   num_sz num;\n   block *bp;\n\n\n   /* Determine position of each core in initial mesh */\n   // initialize\n   for (o = n = k1 = k = 0; k < 1; k++)\n      for (k2 = 0; k2 < 1; k1++, k2++)\n         for (j1 = j = 0; j < 1; j++)\n            for (j2 = 0; j2 < 1; j1++, j2++)\n               for (i1 = i = 0; i < 1; i++)\n                  for (i2 = 0; i2 < 1; i1++, i2++, n++) {\n                     bp = &blocks[o];\n                     bp->level = 0;\n                     bp->number = n;\n                     //add_sorted_list(o, n, 0);\n                     for (var = 0; var < num_vars; var++)\n                        for (ib = 1; ib <= x_block_size; ib++)\n                           for (jb = 1; jb <= y_block_size; jb++)\n                              for (kb = 1; kb <= z_block_size; kb++)\n                                 bp->array[var][ib][jb][kb] =\n                                    ((double) rand())/((double) RAND_MAX);\n                    o++;\n                  }\n}\n\n\n\nvoid driver(void)\n{\n  int start, number, var;\n\n  init();\n\n  for (var = 0; var < num_vars; var ++) {\n     stencil_calc(var, 7);\n  }\n}\n\n\nint main(int argc, char* argv[])\n{   \n  max_num_blocks = 500;\n  num_refine = 5;\n  num_vars = 40;\n  x_block_size = 10;\n  y_block_size = 10;\n  z_block_size = 10;\n\n  allocate();\n \n  driver();\n\n  deallocate();\n  return 0;\n} \n",
        "data_race": 1,
        "trimmed_code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef long long num_sz;\n\nint max_num_blocks;\nint num_refine;\nint num_vars;\nint x_block_size, y_block_size, z_block_size;\nint error_tol;\n\ndouble tol;\n\ntypedef struct {\n   num_sz number;\n   int level;\n   int refine;\n   int new_proc;\n   num_sz parent;       \n                     \n                     \n   double ****array;\n} block;\n\nblock *blocks;\n\nvoid stencil_calc(int var, int stencil_in)\n{\n   int i, j, k, in;\n   double sb, sm, sf, work[x_block_size+2][y_block_size+2][z_block_size+2];\n   block *bp;\n\n   int tid;\n\n#pragma omp parallel default(shared) private(i, j, k, bp)\n  {\n      for (in = 0; in < max_num_blocks; ++in) {\n         bp = &blocks[in];\n         for (i = 1; i <= x_block_size; i++)\n            for (j = 1; j <= y_block_size; j++)\n               for (k = 1; k <= z_block_size; k++)\n                  work[i][j][k] = (bp->array[var][i-1][j  ][k  ] +\n                                   bp->array[var][i  ][j-1][k  ] +\n                                   bp->array[var][i  ][j  ][k-1] +\n                                   bp->array[var][i  ][j  ][k  ] +\n                                   bp->array[var][i  ][j  ][k+1] +\n                                   bp->array[var][i  ][j+1][k  ] +\n                                   bp->array[var][i+1][j  ][k  ])/7.0;\n         for (i = 1; i <= x_block_size; i++)\n            for (j = 1; j <= y_block_size; j++)\n               for (k = 1; k <= z_block_size; k++)\n                  bp->array[var][i][j][k] = work[i][j][k];\n      }\n  }\n}\n\n\nvoid allocate(void)\n{\n   int i, j, k, m, n;\n\n   blocks = (block *) malloc(max_num_blocks*sizeof(block));\n\n   for (n = 0; n < max_num_blocks; n++) {\n      blocks[n].number = -1;\n      blocks[n].array = (double ****) malloc(num_vars*sizeof(double ***));\n      for (m = 0; m < num_vars; m++) {\n         blocks[n].array[m] = (double ***)\n                              malloc((x_block_size+2)*sizeof(double **));\n         for (i = 0; i < x_block_size+2; i++) {\n            blocks[n].array[m][i] = (double **)\n                                   malloc((y_block_size+2)*sizeof(double *));\n            for (j = 0; j < y_block_size+2; j++)\n               blocks[n].array[m][i][j] = (double *)\n                                     malloc((z_block_size+2)*sizeof(double));\n         }\n      }\n   }\n}\n\nvoid deallocate(void)\n{\n   int i, j, m, n;\n\n   for (n = 0; n < max_num_blocks; n++) {\n      for (m = 0; m < num_vars; m++) {\n         for (i = 0; i < x_block_size+2; i++) {\n            for (j = 0; j < y_block_size+2; j++)\n               free(blocks[n].array[m][i][j]);\n            free(blocks[n].array[m][i]);\n         }\n         free(blocks[n].array[m]);\n      }\n      free(blocks[n].array);\n   }\n   free(blocks);\n}\n\nvoid init(void)\n{\n   int n, var, i, j, k, l, m, o, size, dir, i1, i2, j1, j2, k1, k2, ib, jb, kb;\n   num_sz num;\n   block *bp;\n\n\n   \n   \n   for (o = n = k1 = k = 0; k < 1; k++)\n      for (k2 = 0; k2 < 1; k1++, k2++)\n         for (j1 = j = 0; j < 1; j++)\n            for (j2 = 0; j2 < 1; j1++, j2++)\n               for (i1 = i = 0; i < 1; i++)\n                  for (i2 = 0; i2 < 1; i1++, i2++, n++) {\n                     bp = &blocks[o];\n                     bp->level = 0;\n                     bp->number = n;\n                     \n                     for (var = 0; var < num_vars; var++)\n                        for (ib = 1; ib <= x_block_size; ib++)\n                           for (jb = 1; jb <= y_block_size; jb++)\n                              for (kb = 1; kb <= z_block_size; kb++)\n                                 bp->array[var][ib][jb][kb] =\n                                    ((double) rand())/((double) RAND_MAX);\n                    o++;\n                  }\n}\n\n\n\nvoid driver(void)\n{\n  int start, number, var;\n\n  init();\n\n  for (var = 0; var < num_vars; var ++) {\n     stencil_calc(var, 7);\n  }\n}\n\n\nint main(int argc, char* argv[])\n{   \n  max_num_blocks = 500;\n  num_refine = 5;\n  num_vars = 40;\n  x_block_size = 10;\n  y_block_size = 10;\n  z_block_size = 10;\n\n  allocate();\n \n  driver();\n\n  deallocate();\n  return 0;\n} \n",
        "code_len": 4071,
        "data_race_label": "Y6",
        "var_pairs": [
            "{\"name\": [\"in\", \"in\"],\n\"line\": [60, 52],\n\"col\": [43, 43],\n\"operation\": [\"R\", \"W\"]}"
        ]
    },
    {
        "ID": "181",
        "name": "DRB181-SmithWaterman-yes.c",
        "DRB_code": "/*\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n!!! Copyright (c) 2017-20, Lawrence Livermore National Security, LLC\n!!! and DataRaceBench project contributors. See the DataRaceBench/COPYRIGHT file\nfor details.\n!!!\n!!! SPDX-License-Identifier: (BSD-3-Clause)\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n */\n\n/* \n   Data Race Pair, *maxPos@179:9:W vs. *maxPos@177:17:R\n                   H[index]@173:5:W vs. H[*maxPos]@177:15:W\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <omp.h>\n#include <time.h>\n\n\n/*--------------------------------------------------------------------\n * Constants\n */\n#define PATH -1\n#define NONE 0\n#define UP 1\n#define LEFT 2\n#define DIAGONAL 3\n/* End of constants */\n\n/*--------------------------------------------------------------------\n* Helpers\n*/\n#define min(x, y) (((x) < (y)) ? (x) : (y))\n#define max(a,b) ((a) > (b) ? a : b)\n\n// #define DEBUG\n/* End of Helpers */\n\n/*--------------------------------------------------------------------\n * Global Variables\n */\n//Defines size of strings to be compared\nlong long int m ; //Columns - Size of string a\nlong long int n ;  //Lines - Size of string b\n\n//Defines scores\nint matchScore = 5;\nint missmatchScore = -3;\nint gapScore = -4;\n\n//Strings over the Alphabet Sigma\nchar *a, *b;\n\n/* End of global variables */\nvoid generate() {\n    //Random seed\n    srand(time(NULL));\n\n    //Generates the values of a\n    long long int i;\n    for (i = 0; i < m; i++) {\n        int aux = rand() % 4;\n        if (aux == 0)\n            a[i] = 'A';\n        else if (aux == 2)\n            a[i] = 'C';\n        else if (aux == 3)\n            a[i] = 'G';\n        else\n            a[i] = 'T';\n    }\n\n    //Generates the values of b\n    for (i = 0; i < n; i++) {\n        int aux = rand() % 4;\n        if (aux == 0)\n            b[i] = 'A';\n        else if (aux == 2)\n            b[i] = 'C';\n        else if (aux == 3)\n            b[i] = 'G';\n        else\n            b[i] = 'T';\n    }\n} /* End of generate */\n\n\n/*--------------------------------------------------------------------\n * Function:    nElement\n * Purpose:     Calculate the number of i-diagonal elements\n */\nlong long int nElement(long long int i) {\n    if (i < m && i < n) {\n        //Number of elements in the diagonal is increasing\n        return i;\n    }\n    else if (i < max(m, n)) {\n        //Number of elements in the diagonal is stable\n        long long int min = min(m, n);\n        return min - 1;\n    }\n    else {\n        //Number of elements in the diagonal is decreasing\n        long long int min = min(m, n);\n        return 2 * min - i + labs(m - n) - 2;\n    }\n}\n\n/*--------------------------------------------------------------------\n * Function:    matchMissmatchScore\n * Purpose:     Similarity function on the alphabet for match/missmatch\n */\nint matchMissmatchScore(long long int i, long long int j) {\n    if (a[j - 1] == b[i - 1])\n        return matchScore;\n    else\n        return missmatchScore;\n}  /* End of matchMissmatchScore */\n\n\nvoid similarityScore(long long int i, long long int j, int* H, int* P, long long int* maxPos) {\n\n    int up, left, diag;\n\n    //Stores index of element\n    long long int index = m * i + j;\n\n    //Get element above\n    up = H[index - m] + gapScore;\n\n    //Get element on the left\n    left = H[index - 1] + gapScore;\n\n    //Get element on the diagonal\n    diag = H[index - m - 1] + matchMissmatchScore(i, j);\n\n    //Calculates the maximum\n    int max = NONE;\n    int pred = NONE;\n    /* === Matrix ===\n     *      a[0] ... a[n]\n     * b[0]\n     * ...\n     * b[n]\n     *\n     * generate 'a' from 'b', if '\u2190' insert e '\u2191' remove\n     * a=GAATTCA\n     * b=GACTT-A\n     *\n     * generate 'b' from 'a', if '\u2190' insert e '\u2191' remove\n     * b=GACTT-A\n     * a=GAATTCA\n    */\n\n    if (diag > max) { //same letter \u2196\n        max = diag;\n        pred = DIAGONAL;\n    }\n\n    if (up > max) { //remove letter \u2191\n        max = up;\n        pred = UP;\n    }\n\n    if (left > max) { //insert letter \u2190\n        max = left;\n        pred = LEFT;\n    }\n    //Inserts the value in the similarity and predecessor matrixes\n    H[index] = max;\n    P[index] = pred;\n\n    //Updates maximum score to be used as seed on backtrack\n    if (max > H[*maxPos]) {        \n    #pragma omp critical\n        *maxPos = index;\n    }\n\n}  /* End of similarityScore */\n\n/*--------------------------------------------------------------------\n * Function:    calcElement\n * Purpose:     Calculate the position of (si, sj)-element\n */\nvoid calcFirstDiagElement(long long int *i, long long int *si, long long int *sj) {\n    // Calculate the first element of diagonal\n    if (*i < n) {\n        *si = *i;\n        *sj = 1;\n    } else {\n        *si = n - 1;\n        *sj = *i - n + 2;\n    }\n}\n\n\nint main(int argc, char* argv[]) {\n    m = 2048;\n    n = 2048;\n\n#ifdef DEBUG\n    printf(\"\\nMatrix[%lld][%lld]\\n\", n, m);\n#endif\n\n    //Allocates a and b\n    a = malloc(m * sizeof(char));\n    b = malloc(n * sizeof(char));\n\n    //Because now we have zeros\n    m++;\n    n++;\n\n    //Allocates similarity matrix H\n    int *H;\n    H = calloc(m * n, sizeof(int));\n\n    //Allocates predecessor matrix P\n    int *P;\n    P = calloc(m * n, sizeof(int));\n\n\n    //Gen rand arrays a and b\n    generate();\n\n\n    //Start position for backtrack\n    long long int maxPos = 0;\n    //Calculates the similarity matrix\n    long long int i, j;\n\n    //Gets Initial time\n    double initialTime = omp_get_wtime();\n\n    long long int si, sj, ai, aj;\n\n    //Because now we have zeros ((m-1) + (n-1) - 1)\n    long long int nDiag = m + n - 3;\n    long long int nEle;\n\n    #pragma omp parallel \\\n    default(none) shared(H, P, maxPos, nDiag) private(nEle, i, si, sj, ai, aj)\n    {\n        for (i = 1; i <= nDiag; ++i)\n        {\n            nEle = nElement(i);\n            calcFirstDiagElement(&i, &si, &sj);\n            #pragma omp for\n            for (j = 1; j <= nEle; ++j)\n            {\n                ai = si - j + 1;\n                aj = sj + j - 1;\n                similarityScore(ai, aj, H, P, &maxPos);\n            }\n        }\n    }\n}\n",
        "data_race": 1,
        "trimmed_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <omp.h>\n#include <time.h>\n\n\n\n#define PATH -1\n#define NONE 0\n#define UP 1\n#define LEFT 2\n#define DIAGONAL 3\n\n\n\n#define min(x, y) (((x) < (y)) ? (x) : (y))\n#define max(a,b) ((a) > (b) ? a : b)\n\n\n\n\n\n\nlong long int m ; \nlong long int n ;  \n\n\nint matchScore = 5;\nint missmatchScore = -3;\nint gapScore = -4;\n\n\nchar *a, *b;\n\n\nvoid generate() {\n    \n    srand(time(NULL));\n\n    \n    long long int i;\n    for (i = 0; i < m; i++) {\n        int aux = rand() % 4;\n        if (aux == 0)\n            a[i] = 'A';\n        else if (aux == 2)\n            a[i] = 'C';\n        else if (aux == 3)\n            a[i] = 'G';\n        else\n            a[i] = 'T';\n    }\n\n    \n    for (i = 0; i < n; i++) {\n        int aux = rand() % 4;\n        if (aux == 0)\n            b[i] = 'A';\n        else if (aux == 2)\n            b[i] = 'C';\n        else if (aux == 3)\n            b[i] = 'G';\n        else\n            b[i] = 'T';\n    }\n} \n\n\n\nlong long int nElement(long long int i) {\n    if (i < m && i < n) {\n        \n        return i;\n    }\n    else if (i < max(m, n)) {\n        \n        long long int min = min(m, n);\n        return min - 1;\n    }\n    else {\n        \n        long long int min = min(m, n);\n        return 2 * min - i + labs(m - n) - 2;\n    }\n}\n\n\nint matchMissmatchScore(long long int i, long long int j) {\n    if (a[j - 1] == b[i - 1])\n        return matchScore;\n    else\n        return missmatchScore;\n}  \n\n\nvoid similarityScore(long long int i, long long int j, int* H, int* P, long long int* maxPos) {\n\n    int up, left, diag;\n\n    \n    long long int index = m * i + j;\n\n    \n    up = H[index - m] + gapScore;\n\n    \n    left = H[index - 1] + gapScore;\n\n    \n    diag = H[index - m - 1] + matchMissmatchScore(i, j);\n\n    \n    int max = NONE;\n    int pred = NONE;\n    \n\n    if (diag > max) { \n        max = diag;\n        pred = DIAGONAL;\n    }\n\n    if (up > max) { \n        max = up;\n        pred = UP;\n    }\n\n    if (left > max) { \n        max = left;\n        pred = LEFT;\n    }\n    \n    H[index] = max;\n    P[index] = pred;\n\n    \n    if (max > H[*maxPos]) {        \n    #pragma omp critical\n        *maxPos = index;\n    }\n\n}  \n\n\nvoid calcFirstDiagElement(long long int *i, long long int *si, long long int *sj) {\n    \n    if (*i < n) {\n        *si = *i;\n        *sj = 1;\n    } else {\n        *si = n - 1;\n        *sj = *i - n + 2;\n    }\n}\n\n\nint main(int argc, char* argv[]) {\n    m = 2048;\n    n = 2048;\n\n#ifdef DEBUG\n    printf(\"\\nMatrix[%lld][%lld]\\n\", n, m);\n#endif\n\n    \n    a = malloc(m * sizeof(char));\n    b = malloc(n * sizeof(char));\n\n    \n    m++;\n    n++;\n\n    \n    int *H;\n    H = calloc(m * n, sizeof(int));\n\n    \n    int *P;\n    P = calloc(m * n, sizeof(int));\n\n\n    \n    generate();\n\n\n    \n    long long int maxPos = 0;\n    \n    long long int i, j;\n\n    \n    double initialTime = omp_get_wtime();\n\n    long long int si, sj, ai, aj;\n\n    \n    long long int nDiag = m + n - 3;\n    long long int nEle;\n\n    #pragma omp parallel \\\n    default(none) shared(H, P, maxPos, nDiag) private(nEle, i, si, sj, ai, aj)\n    {\n        for (i = 1; i <= nDiag; ++i)\n        {\n            nEle = nElement(i);\n            calcFirstDiagElement(&i, &si, &sj);\n            #pragma omp for\n            for (j = 1; j <= nEle; ++j)\n            {\n                ai = si - j + 1;\n                aj = sj + j - 1;\n                similarityScore(ai, aj, H, P, &maxPos);\n            }\n        }\n    }\n}\n",
        "code_len": 3443,
        "data_race_label": "Y6",
        "var_pairs": [
            "{\"name\": [\"*maxPos\", \"*maxPos\"],\n\"line\": [179, 177],\n\"col\": [9, 17],\n\"operation\": [\"W\", \"R\"]}"
        ]
    },
    {
        "ID": "182",
        "name": "DRB182-atomic3-no.c",
        "DRB_code": "/*\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n!!! Copyright (c) 2017-20, Lawrence Livermore National Security, LLC\n!!! and DataRaceBench project contributors. See the DataRaceBench/COPYRIGHT file for details.\n!!!\n!!! SPDX-License-Identifier: (BSD-3-Clause)\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n */\n\n#include <stdio.h>\n/*\n * This is a program based on a dataset contributed by \n * Wenhao Wu and Stephen F. Siegel @Univ. of Delaware.\n \n * sync with busy wait loop using atomic. No data race pair.\n */\nint main()\n{\n  int x = 0, s = 0;\n#pragma omp parallel sections shared(x, s) num_threads(2)\n  {\n#pragma omp section\n    {\n      x = 1;\n#pragma omp atomic write seq_cst\n      s = 1;\n    }\n#pragma omp section\n    {\n      int done = 0;\n      while (!done)\n      {\n#pragma omp atomic read seq_cst\n        done = s;\n      }\n      x = 2;\n    }\n  }\n  printf(\"%d\\n\", x);\n}\n",
        "data_race": 0,
        "trimmed_code": "#include <stdio.h>\n\nint main()\n{\n  int x = 0, s = 0;\n#pragma omp parallel sections shared(x, s) num_threads(2)\n  {\n#pragma omp section\n    {\n      x = 1;\n#pragma omp atomic write seq_cst\n      s = 1;\n    }\n#pragma omp section\n    {\n      int done = 0;\n      while (!done)\n      {\n#pragma omp atomic read seq_cst\n        done = s;\n      }\n      x = 2;\n    }\n  }\n  printf(\"%d\\n\", x);\n}\n",
        "code_len": 384,
        "data_race_label": "N3",
        "var_pairs": []
    },
    {
        "ID": "183",
        "name": "DRB183-atomic3-yes.c",
        "DRB_code": "/*\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n!!! Copyright (c) 2017-20, Lawrence Livermore National Security, LLC\n!!! and DataRaceBench project contributors. See the DataRaceBench/COPYRIGHT file for details.\n!!!\n!!! SPDX-License-Identifier: (BSD-3-Clause)\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n */\n\n#include <stdio.h>\n/*\n * This is a program based on a dataset contributed by \n * Wenhao Wu and Stephen F. Siegel @Univ. of Delaware.\n \n * Race because the write to s is not protected by atomic\n * Data race pair: s@26:7:W vs. s@34:16:R\n */\nint main()\n{\n  int x = 0, s = 0;\n#pragma omp parallel sections shared(x, s) num_threads(2)\n  {\n#pragma omp section\n    {\n      x = 1;\n      s = 1;\n    }\n#pragma omp section\n    {\n      int done = 0;\n      while (!done)\n      {\n#pragma omp atomic read seq_cst\n        done = s;\n      }\n      x = 2;\n    }\n  }\n  printf(\"%d\\n\", x);\n}\n",
        "data_race": 1,
        "trimmed_code": "#include <stdio.h>\n\nint main()\n{\n  int x = 0, s = 0;\n#pragma omp parallel sections shared(x, s) num_threads(2)\n  {\n#pragma omp section\n    {\n      x = 1;\n      s = 1;\n    }\n#pragma omp section\n    {\n      int done = 0;\n      while (!done)\n      {\n#pragma omp atomic read seq_cst\n        done = s;\n      }\n      x = 2;\n    }\n  }\n  printf(\"%d\\n\", x);\n}\n",
        "code_len": 351,
        "data_race_label": "Y3",
        "var_pairs": [
            "{\"name\": [\"s\", \"s\"],\n\"line\": [26, 34],\n\"col\": [7, 16],\n\"operation\": [\"W\", \"R\"]}"
        ]
    },
    {
        "ID": "184",
        "name": "DRB184-barrier1-no.c",
        "DRB_code": "/*\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n!!! Copyright (c) 2017-20, Lawrence Livermore National Security, LLC\n!!! and DataRaceBench project contributors. See the DataRaceBench/COPYRIGHT file for details.\n!!!\n!!! SPDX-License-Identifier: (BSD-3-Clause)\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n */\n\n/*\n * This is a program based on a dataset contributed by \n * Wenhao Wu and Stephen F. Siegel @Univ. of Delaware.\n \n * 2-thread flag barrier using busy-wait loops and critical, no race.\n */\n\n#include <stdio.h>\n#include <omp.h>\n#include <assert.h>\n\ntypedef _Bool flag_t;\n\nflag_t f0, f1;\nconst int n = 100;\nint x = 1;\n\nvoid init(flag_t *f)\n{\n  *f = 0;\n}\n\nvoid raise(flag_t *f)\n{\n#pragma omp critical\n  {\n    assert(*f == 0);\n    *f = 1;\n  }\n}\n\nvoid lower(flag_t *f)\n{\n  _Bool done = 0;\n  while (!done)\n  {\n#pragma omp critical\n    if (*f == 1)\n    {\n      *f = 0;\n      done = 1;\n    }\n  }\n}\n\nvoid mybarrier(int tid)\n{\n  if (tid == 0)\n  {\n    raise(&f0);\n    lower(&f1);\n  }\n  else if (tid == 1)\n  {\n    lower(&f0);\n    raise(&f1);\n  }\n}\n\nint main()\n{\n  init(&f0);\n  init(&f1);\n#pragma omp parallel num_threads(2)\n  {\n    int tid = omp_get_thread_num();\n#pragma omp barrier\n    for (int i = 0; i < n; i++)\n    {\n      printf(\"Thread %d: phase 1, i=%d, x=%d\\n\", tid, i, x);\n      fflush(stdout);\n      assert(x == 1);\n      mybarrier(tid);\n      if (tid == 0)\n        x = 0;\n      mybarrier(tid);\n      printf(\"Thread %d: phase 3, i=%d, x=%d\\n\", tid, i, x);\n      fflush(stdout);\n      assert(x == 0);\n      mybarrier(tid);\n      if (tid == 1)\n        x = 1;\n      mybarrier(tid);\n    }\n  } // end of parallel construct\n  printf(\"Done: x=%d\\n\", x);\n}",
        "data_race": 0,
        "trimmed_code": "#include <stdio.h>\n#include <omp.h>\n#include <assert.h>\n\ntypedef _Bool flag_t;\n\nflag_t f0, f1;\nconst int n = 100;\nint x = 1;\n\nvoid init(flag_t *f)\n{\n  *f = 0;\n}\n\nvoid raise(flag_t *f)\n{\n#pragma omp critical\n  {\n    assert(*f == 0);\n    *f = 1;\n  }\n}\n\nvoid lower(flag_t *f)\n{\n  _Bool done = 0;\n  while (!done)\n  {\n#pragma omp critical\n    if (*f == 1)\n    {\n      *f = 0;\n      done = 1;\n    }\n  }\n}\n\nvoid mybarrier(int tid)\n{\n  if (tid == 0)\n  {\n    raise(&f0);\n    lower(&f1);\n  }\n  else if (tid == 1)\n  {\n    lower(&f0);\n    raise(&f1);\n  }\n}\n\nint main()\n{\n  init(&f0);\n  init(&f1);\n#pragma omp parallel num_threads(2)\n  {\n    int tid = omp_get_thread_num();\n#pragma omp barrier\n    for (int i = 0; i < n; i++)\n    {\n      printf(\"Thread %d: phase 1, i=%d, x=%d\\n\", tid, i, x);\n      fflush(stdout);\n      assert(x == 1);\n      mybarrier(tid);\n      if (tid == 0)\n        x = 0;\n      mybarrier(tid);\n      printf(\"Thread %d: phase 3, i=%d, x=%d\\n\", tid, i, x);\n      fflush(stdout);\n      assert(x == 0);\n      mybarrier(tid);\n      if (tid == 1)\n        x = 1;\n      mybarrier(tid);\n    }\n  } \n  printf(\"Done: x=%d\\n\", x);\n}",
        "code_len": 1128,
        "data_race_label": "N3",
        "var_pairs": []
    },
    {
        "ID": "185",
        "name": "DRB185-barrier1-yes.c",
        "DRB_code": "/*\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n!!! Copyright (c) 2017-20, Lawrence Livermore National Security, LLC\n!!! and DataRaceBench project contributors. See the DataRaceBench/COPYRIGHT file for details.\n!!!\n!!! SPDX-License-Identifier: (BSD-3-Clause)\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n */\n\n/*\n * This is a program based on a dataset contributed by\n * Wenhao Wu and Stephen F. Siegel @Univ. of Delaware.\n\n * wrong 2-thread flag barrier using busy-waits, race\n * Data race pair: x@85:9:W vs. x@92:9:W\n */\n\n#include <stdio.h>\n#include <omp.h>\n#include <assert.h>\n\ntypedef _Bool flag_t;\n\nflag_t f0, f1;\nconst int n = 2;\nint x = 1;\n\nvoid init(flag_t *f)\n{\n  *f = 0;\n}\n\nvoid raise(flag_t *f)\n{\n#pragma omp critical\n  {\n    assert(*f == 0);\n    *f = 1;\n  }\n}\n\nvoid lower(flag_t *f)\n{\n  _Bool done = 0;\n  while (!done)\n  {\n#pragma omp critical\n    if (*f == 1)\n    {\n      *f = 0;\n      done = 1;\n    }\n  }\n}\n\nvoid mybarrier(int tid)\n{\n  if (tid == 0)\n  {\n    raise(&f0);\n    lower(&f0);\n  }\n  else if (tid == 1)\n  {\n    raise(&f1);\n    lower(&f1);\n  }\n}\n\nint main()\n{\n  init(&f0);\n  init(&f1);\n#pragma omp parallel num_threads(2)\n  {\n    int tid = omp_get_thread_num();\n#pragma omp barrier\n    for (int i = 0; i < n; i++)\n    {\n      printf(\"Thread %d: phase 1, i=%d, x=%d\\n\", tid, i, x);\n      fflush(stdout);\n      // assert(x==1);\n      mybarrier(tid);\n      if (tid == 0)\n        x = 0;\n      mybarrier(tid);\n      printf(\"Thread %d: phase 3, i=%d, x=%d\\n\", tid, i, x);\n      fflush(stdout);\n      // assert(x==0);\n      mybarrier(tid);\n      if (tid == 1)\n        x = 1;\n      mybarrier(tid);\n    }\n  } // end of parallel construct\n  printf(\"Done: x=%d\\n\", x);\n}\n",
        "data_race": 1,
        "trimmed_code": "#include <stdio.h>\n#include <omp.h>\n#include <assert.h>\n\ntypedef _Bool flag_t;\n\nflag_t f0, f1;\nconst int n = 2;\nint x = 1;\n\nvoid init(flag_t *f)\n{\n  *f = 0;\n}\n\nvoid raise(flag_t *f)\n{\n#pragma omp critical\n  {\n    assert(*f == 0);\n    *f = 1;\n  }\n}\n\nvoid lower(flag_t *f)\n{\n  _Bool done = 0;\n  while (!done)\n  {\n#pragma omp critical\n    if (*f == 1)\n    {\n      *f = 0;\n      done = 1;\n    }\n  }\n}\n\nvoid mybarrier(int tid)\n{\n  if (tid == 0)\n  {\n    raise(&f0);\n    lower(&f0);\n  }\n  else if (tid == 1)\n  {\n    raise(&f1);\n    lower(&f1);\n  }\n}\n\nint main()\n{\n  init(&f0);\n  init(&f1);\n#pragma omp parallel num_threads(2)\n  {\n    int tid = omp_get_thread_num();\n#pragma omp barrier\n    for (int i = 0; i < n; i++)\n    {\n      printf(\"Thread %d: phase 1, i=%d, x=%d\\n\", tid, i, x);\n      fflush(stdout);\n      \n      mybarrier(tid);\n      if (tid == 0)\n        x = 0;\n      mybarrier(tid);\n      printf(\"Thread %d: phase 3, i=%d, x=%d\\n\", tid, i, x);\n      fflush(stdout);\n      \n      mybarrier(tid);\n      if (tid == 1)\n        x = 1;\n      mybarrier(tid);\n    }\n  } \n  printf(\"Done: x=%d\\n\", x);\n}\n",
        "code_len": 1097,
        "data_race_label": "Y3",
        "var_pairs": [
            "{\"name\": [\"x\", \"x\"],\n\"line\": [85, 92],\n\"col\": [9, 9],\n\"operation\": [\"W\", \"W\"]}"
        ]
    },
    {
        "ID": "186",
        "name": "DRB186-barrier2-no.c",
        "DRB_code": "/*\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n!!! Copyright (c) 2017-20, Lawrence Livermore National Security, LLC\n!!! and DataRaceBench project contributors. See the DataRaceBench/COPYRIGHT file for details.\n!!!\n!!! SPDX-License-Identifier: (BSD-3-Clause)\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n */\n\n/*\n * This is a program based on a dataset contributed by\n * Wenhao Wu and Stephen F. Siegel @Univ. of Delaware.\n\n * uses locks to create a barrier that is used once.\n */\n\n#include <stdio.h>\n#include <omp.h>\n#include <assert.h>\n\nomp_lock_t l0, l1;\nint x = 1;\n\nint main()\n{\n  omp_init_lock(&l0);\n  omp_init_lock(&l1);\n#pragma omp parallel num_threads(2)\n  {\n    int tid = omp_get_thread_num();\n    if (tid == 0)\n      omp_set_lock(&l0);\n    else if (tid == 1)\n      omp_set_lock(&l1);\n#pragma omp barrier\n    if (tid == 0)\n      x = 0;\n    if (tid == 0)\n    {\n      omp_unset_lock(&l0);\n      omp_set_lock(&l1);\n    }\n    else if (tid == 1)\n    {\n      omp_set_lock(&l0);\n      omp_unset_lock(&l1);\n    }\n    if (tid == 1)\n      x = 1;\n#pragma omp barrier\n    if (tid == 0)\n      omp_unset_lock(&l1);\n    else if (tid == 1)\n      omp_unset_lock(&l0);\n  } // end of parallel construct\n  omp_destroy_lock(&l0);\n  omp_destroy_lock(&l1);\n  printf(\"Done: x=%d\\n\", x);\n}\n",
        "data_race": 0,
        "trimmed_code": "#include <stdio.h>\n#include <omp.h>\n#include <assert.h>\n\nomp_lock_t l0, l1;\nint x = 1;\n\nint main()\n{\n  omp_init_lock(&l0);\n  omp_init_lock(&l1);\n#pragma omp parallel num_threads(2)\n  {\n    int tid = omp_get_thread_num();\n    if (tid == 0)\n      omp_set_lock(&l0);\n    else if (tid == 1)\n      omp_set_lock(&l1);\n#pragma omp barrier\n    if (tid == 0)\n      x = 0;\n    if (tid == 0)\n    {\n      omp_unset_lock(&l0);\n      omp_set_lock(&l1);\n    }\n    else if (tid == 1)\n    {\n      omp_set_lock(&l0);\n      omp_unset_lock(&l1);\n    }\n    if (tid == 1)\n      x = 1;\n#pragma omp barrier\n    if (tid == 0)\n      omp_unset_lock(&l1);\n    else if (tid == 1)\n      omp_unset_lock(&l0);\n  } \n  omp_destroy_lock(&l0);\n  omp_destroy_lock(&l1);\n  printf(\"Done: x=%d\\n\", x);\n}\n",
        "code_len": 764,
        "data_race_label": "N3",
        "var_pairs": []
    },
    {
        "ID": "187",
        "name": "DRB187-barrier2-yes.c",
        "DRB_code": "/*\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n!!! Copyright (c) 2017-20, Lawrence Livermore National Security, LLC\n!!! and DataRaceBench project contributors. See the DataRaceBench/COPYRIGHT file for details.\n!!!\n!!! SPDX-License-Identifier: (BSD-3-Clause)\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n */\n\n/*\n * This is a program based on a dataset contributed by\n * Wenhao Wu and Stephen F. Siegel @Univ. of Delaware.\n\n * not a barrier.  either thread can exit before the other thread\n * enters.  So race on x can occur.\n * Data race pair: x@39:7:W vs. x@51:7:W\n */\n\n#include <stdio.h>\n#include <omp.h>\n#include <assert.h>\n\nomp_lock_t l0, l1;\nint x = 1;\n\nint main()\n{\n  omp_init_lock(&l0);\n  omp_init_lock(&l1);\n#pragma omp parallel num_threads(2)\n  {\n    int tid = omp_get_thread_num();\n    if (tid == 0)\n      omp_set_lock(&l0);\n    else if (tid == 1)\n      omp_set_lock(&l1);\n#pragma omp barrier\n    if (tid == 0)\n      x = 0;\n    if (tid == 0)\n    {\n      omp_unset_lock(&l0);\n      omp_set_lock(&l0);\n    }\n    else if (tid == 1)\n    {\n      omp_unset_lock(&l1);\n      omp_set_lock(&l1);\n    }\n    if (tid == 1)\n      x = 1;\n#pragma omp barrier\n    if (tid == 0)\n      omp_unset_lock(&l1);\n    else if (tid == 1)\n      omp_unset_lock(&l0);\n  } // end of parallel construct\n  omp_destroy_lock(&l0);\n  omp_destroy_lock(&l1);\n  printf(\"Done: x=%d\\n\", x);\n}\n",
        "data_race": 1,
        "trimmed_code": "#include <stdio.h>\n#include <omp.h>\n#include <assert.h>\n\nomp_lock_t l0, l1;\nint x = 1;\n\nint main()\n{\n  omp_init_lock(&l0);\n  omp_init_lock(&l1);\n#pragma omp parallel num_threads(2)\n  {\n    int tid = omp_get_thread_num();\n    if (tid == 0)\n      omp_set_lock(&l0);\n    else if (tid == 1)\n      omp_set_lock(&l1);\n#pragma omp barrier\n    if (tid == 0)\n      x = 0;\n    if (tid == 0)\n    {\n      omp_unset_lock(&l0);\n      omp_set_lock(&l0);\n    }\n    else if (tid == 1)\n    {\n      omp_unset_lock(&l1);\n      omp_set_lock(&l1);\n    }\n    if (tid == 1)\n      x = 1;\n#pragma omp barrier\n    if (tid == 0)\n      omp_unset_lock(&l1);\n    else if (tid == 1)\n      omp_unset_lock(&l0);\n  } \n  omp_destroy_lock(&l0);\n  omp_destroy_lock(&l1);\n  printf(\"Done: x=%d\\n\", x);\n}\n",
        "code_len": 764,
        "data_race_label": "Y3",
        "var_pairs": [
            "{\"name\": [\"x\", \"x\"],\n\"line\": [39, 51],\n\"col\": [7, 7],\n\"operation\": [\"W\", \"W\"]}"
        ]
    },
    {
        "ID": "188",
        "name": "DRB188-barrier3-no.c",
        "DRB_code": "/*\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n!!! Copyright (c) 2017-20, Lawrence Livermore National Security, LLC\n!!! and DataRaceBench project contributors. See the DataRaceBench/COPYRIGHT file for details.\n!!!\n!!! SPDX-License-Identifier: (BSD-3-Clause)\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n */\n\n/*\n * This is a program based on a dataset contributed by \n * Wenhao Wu and Stephen F. Siegel @Univ. of Delaware.\n \n * implements 2-thread reuseable barrier using 3 locks, no race.\n */\n\n#include <stdio.h>\n#include <omp.h>\n#include <assert.h>\n\nomp_lock_t l0, l1, l2;\nconst int n = 100;\nint x = 1;\n\nvoid barrier_init()\n{\n  omp_init_lock(&l0);\n  omp_init_lock(&l1);\n  omp_init_lock(&l2);\n}\n\nvoid barrier_destroy()\n{\n  omp_destroy_lock(&l0);\n  omp_destroy_lock(&l1);\n  omp_destroy_lock(&l2);\n}\n\nvoid barrier_start(int tid)\n{\n  if (tid == 0)\n  {\n    omp_set_lock(&l0);\n    omp_set_lock(&l2);\n  }\n  else if (tid == 1)\n  {\n    omp_set_lock(&l1);\n  }\n}\n\nvoid barrier_stop(int tid)\n{\n  if (tid == 0)\n  {\n    omp_unset_lock(&l0);\n    omp_unset_lock(&l2);\n  }\n  else if (tid == 1)\n  {\n    omp_unset_lock(&l1);\n  }\n}\n\nvoid barrier_wait(int tid)\n{\n  if (tid == 0)\n  {\n    omp_unset_lock(&l0);\n    omp_set_lock(&l1);\n    omp_unset_lock(&l2);\n    omp_set_lock(&l0);\n    omp_unset_lock(&l1);\n    omp_set_lock(&l2);\n  }\n  else if (tid == 1)\n  {\n    omp_set_lock(&l0);\n    omp_unset_lock(&l1);\n    omp_set_lock(&l2);\n    omp_unset_lock(&l0);\n    omp_set_lock(&l1);\n    omp_unset_lock(&l2);\n  }\n}\n\nint main()\n{\n  barrier_init();\n#pragma omp parallel num_threads(2)\n  {\n    int tid = omp_get_thread_num();\n    barrier_start(tid);\n#pragma omp barrier\n    for (int i = 0; i < n; i++)\n    {\n      printf(\"Thread %d: phase 1, i=%d, x=%d\\n\", tid, i, x);\n      fflush(stdout);\n      assert(x == 1);\n      barrier_wait(tid);\n      if (tid == 0)\n        x = 0;\n      barrier_wait(tid);\n      printf(\"Thread %d: phase 3, i=%d, x=%d\\n\", tid, i, x);\n      fflush(stdout);\n      assert(x == 0);\n      barrier_wait(tid);\n      if (tid == 1)\n        x = 1;\n      barrier_wait(tid);\n    }\n#pragma omp barrier\n    barrier_stop(tid);\n  } // end of parallel construct\n  barrier_destroy();\n  printf(\"Done: x=%d\\n\", x);\n}\n",
        "data_race": 0,
        "trimmed_code": "#include <stdio.h>\n#include <omp.h>\n#include <assert.h>\n\nomp_lock_t l0, l1, l2;\nconst int n = 100;\nint x = 1;\n\nvoid barrier_init()\n{\n  omp_init_lock(&l0);\n  omp_init_lock(&l1);\n  omp_init_lock(&l2);\n}\n\nvoid barrier_destroy()\n{\n  omp_destroy_lock(&l0);\n  omp_destroy_lock(&l1);\n  omp_destroy_lock(&l2);\n}\n\nvoid barrier_start(int tid)\n{\n  if (tid == 0)\n  {\n    omp_set_lock(&l0);\n    omp_set_lock(&l2);\n  }\n  else if (tid == 1)\n  {\n    omp_set_lock(&l1);\n  }\n}\n\nvoid barrier_stop(int tid)\n{\n  if (tid == 0)\n  {\n    omp_unset_lock(&l0);\n    omp_unset_lock(&l2);\n  }\n  else if (tid == 1)\n  {\n    omp_unset_lock(&l1);\n  }\n}\n\nvoid barrier_wait(int tid)\n{\n  if (tid == 0)\n  {\n    omp_unset_lock(&l0);\n    omp_set_lock(&l1);\n    omp_unset_lock(&l2);\n    omp_set_lock(&l0);\n    omp_unset_lock(&l1);\n    omp_set_lock(&l2);\n  }\n  else if (tid == 1)\n  {\n    omp_set_lock(&l0);\n    omp_unset_lock(&l1);\n    omp_set_lock(&l2);\n    omp_unset_lock(&l0);\n    omp_set_lock(&l1);\n    omp_unset_lock(&l2);\n  }\n}\n\nint main()\n{\n  barrier_init();\n#pragma omp parallel num_threads(2)\n  {\n    int tid = omp_get_thread_num();\n    barrier_start(tid);\n#pragma omp barrier\n    for (int i = 0; i < n; i++)\n    {\n      printf(\"Thread %d: phase 1, i=%d, x=%d\\n\", tid, i, x);\n      fflush(stdout);\n      assert(x == 1);\n      barrier_wait(tid);\n      if (tid == 0)\n        x = 0;\n      barrier_wait(tid);\n      printf(\"Thread %d: phase 3, i=%d, x=%d\\n\", tid, i, x);\n      fflush(stdout);\n      assert(x == 0);\n      barrier_wait(tid);\n      if (tid == 1)\n        x = 1;\n      barrier_wait(tid);\n    }\n#pragma omp barrier\n    barrier_stop(tid);\n  } \n  barrier_destroy();\n  printf(\"Done: x=%d\\n\", x);\n}\n",
        "code_len": 1668,
        "data_race_label": "N3",
        "var_pairs": []
    },
    {
        "ID": "189",
        "name": "DRB189-barrier3-yes.c",
        "DRB_code": "/*\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n!!! Copyright (c) 2017-20, Lawrence Livermore National Security, LLC\n!!! and DataRaceBench project contributors. See the DataRaceBench/COPYRIGHT file for details.\n!!!\n!!! SPDX-License-Identifier: (BSD-3-Clause)\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n */\n\n/*\n * This is a program based on a dataset contributed by\n * Wenhao Wu and Stephen F. Siegel @Univ. of Delaware.\n\n * one synchronization commented out.\n * enters.  So race on x can occur.\n * Data race pair: x@104:9:W vs. x@111:9:W\n */\n\n#include <stdio.h>\n#include <omp.h>\n#include <assert.h>\n\nomp_lock_t l0, l1, l2;\nconst int n = 2;\nint x = 1;\n\nvoid barrier_init()\n{\n  omp_init_lock(&l0);\n  omp_init_lock(&l1);\n  omp_init_lock(&l2);\n}\n\nvoid barrier_destroy()\n{\n  omp_destroy_lock(&l0);\n  omp_destroy_lock(&l1);\n  omp_destroy_lock(&l2);\n}\n\nvoid barrier_start(int tid)\n{\n  if (tid == 0)\n  {\n    omp_set_lock(&l0);\n    omp_set_lock(&l2);\n  }\n  else if (tid == 1)\n  {\n    omp_set_lock(&l1);\n  }\n}\n\nvoid barrier_stop(int tid)\n{\n  if (tid == 0)\n  {\n    omp_unset_lock(&l0);\n    omp_unset_lock(&l2);\n  }\n  else if (tid == 1)\n  {\n    omp_unset_lock(&l1);\n  }\n}\n\nvoid barrier_wait(int tid)\n{\n  if (tid == 0)\n  {\n    omp_unset_lock(&l0);\n    omp_set_lock(&l1);\n    // omp_unset_lock(&l2);\n    omp_set_lock(&l0);\n    omp_unset_lock(&l1);\n    // omp_set_lock(&l2);\n  }\n  else if (tid == 1)\n  {\n    omp_set_lock(&l0);\n    omp_unset_lock(&l1);\n    // omp_set_lock(&l2);\n    omp_unset_lock(&l0);\n    omp_set_lock(&l1);\n    // omp_unset_lock(&l2);\n  }\n}\n\nint main()\n{\n  barrier_init();\n#pragma omp parallel num_threads(2)\n  {\n    int tid = omp_get_thread_num();\n    barrier_start(tid);\n#pragma omp barrier\n    for (int i = 0; i < n; i++)\n    {\n      printf(\"Thread %d: phase 1, i=%d, x=%d\\n\", tid, i, x);\n      fflush(stdout);\n      // assert(x==1);\n      barrier_wait(tid);\n      if (tid == 0)\n        x = 0;\n      barrier_wait(tid);\n      printf(\"Thread %d: phase 3, i=%d, x=%d\\n\", tid, i, x);\n      fflush(stdout);\n      // assert(x==0);\n      barrier_wait(tid);\n      if (tid == 1)\n        x = 1;\n      barrier_wait(tid);\n    }\n#pragma omp barrier\n    barrier_stop(tid);\n  } // end of parallel construct\n  barrier_destroy();\n  printf(\"Done: x=%d\\n\", x);\n}\n",
        "data_race": 1,
        "trimmed_code": "#include <stdio.h>\n#include <omp.h>\n#include <assert.h>\n\nomp_lock_t l0, l1, l2;\nconst int n = 2;\nint x = 1;\n\nvoid barrier_init()\n{\n  omp_init_lock(&l0);\n  omp_init_lock(&l1);\n  omp_init_lock(&l2);\n}\n\nvoid barrier_destroy()\n{\n  omp_destroy_lock(&l0);\n  omp_destroy_lock(&l1);\n  omp_destroy_lock(&l2);\n}\n\nvoid barrier_start(int tid)\n{\n  if (tid == 0)\n  {\n    omp_set_lock(&l0);\n    omp_set_lock(&l2);\n  }\n  else if (tid == 1)\n  {\n    omp_set_lock(&l1);\n  }\n}\n\nvoid barrier_stop(int tid)\n{\n  if (tid == 0)\n  {\n    omp_unset_lock(&l0);\n    omp_unset_lock(&l2);\n  }\n  else if (tid == 1)\n  {\n    omp_unset_lock(&l1);\n  }\n}\n\nvoid barrier_wait(int tid)\n{\n  if (tid == 0)\n  {\n    omp_unset_lock(&l0);\n    omp_set_lock(&l1);\n    \n    omp_set_lock(&l0);\n    omp_unset_lock(&l1);\n    \n  }\n  else if (tid == 1)\n  {\n    omp_set_lock(&l0);\n    omp_unset_lock(&l1);\n    \n    omp_unset_lock(&l0);\n    omp_set_lock(&l1);\n    \n  }\n}\n\nint main()\n{\n  barrier_init();\n#pragma omp parallel num_threads(2)\n  {\n    int tid = omp_get_thread_num();\n    barrier_start(tid);\n#pragma omp barrier\n    for (int i = 0; i < n; i++)\n    {\n      printf(\"Thread %d: phase 1, i=%d, x=%d\\n\", tid, i, x);\n      fflush(stdout);\n      \n      barrier_wait(tid);\n      if (tid == 0)\n        x = 0;\n      barrier_wait(tid);\n      printf(\"Thread %d: phase 3, i=%d, x=%d\\n\", tid, i, x);\n      fflush(stdout);\n      \n      barrier_wait(tid);\n      if (tid == 1)\n        x = 1;\n      barrier_wait(tid);\n    }\n#pragma omp barrier\n    barrier_stop(tid);\n  } \n  barrier_destroy();\n  printf(\"Done: x=%d\\n\", x);\n}\n",
        "code_len": 1560,
        "data_race_label": "Y3",
        "var_pairs": [
            "{\"name\": [\"x\", \"x\"],\n\"line\": [104, 111],\n\"col\": [9, 9],\n\"operation\": [\"W\", \"W\"]}"
        ]
    },
    {
        "ID": "190",
        "name": "DRB190-critical-section2-no.c",
        "DRB_code": "/*\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n!!! Copyright (c) 2017-20, Lawrence Livermore National Security, LLC\n!!! and DataRaceBench project contributors. See the DataRaceBench/COPYRIGHT file for details.\n!!!\n!!! SPDX-License-Identifier: (BSD-3-Clause)\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n */\n\n/*\n * This is a program based on a dataset contributed by \n * Wenhao Wu and Stephen F. Siegel @Univ. of Delaware.\n \n * single producer single consumer with critical sections\n */\n\n#include <stdio.h>\n\nint cap = 10, size = 0;\nunsigned r = 0;\n\nint main()\n{\n#pragma omp parallel sections shared(size, cap) firstprivate(r) num_threads(2)\n  {\n#pragma omp section\n    while (1)\n    {\n#pragma omp critical\n      {\n        if (size < cap)\n        {\n          size++; // produce\n          printf(\"Produced! size=%d\\n\", size);\n          fflush(stdout);\n        }\n      }\n      for (int i = 0; i < 1000; i++)\n        r = (r + 1) % 10;\n    }\n#pragma omp section\n    while (1)\n    {\n#pragma omp critical\n      {\n        if (size > 0)\n        {\n          size--; // consume\n          printf(\"Consumed! size=%d\\n\", size);\n          fflush(stdout);\n        }\n      }\n      for (int i = 0; i < 1000; i++)\n        r = (r + 1) % 10;\n    }\n  }\n}\n",
        "data_race": 0,
        "trimmed_code": "#include <stdio.h>\n\nint cap = 10, size = 0;\nunsigned r = 0;\n\nint main()\n{\n#pragma omp parallel sections shared(size, cap) firstprivate(r) num_threads(2)\n  {\n#pragma omp section\n    while (1)\n    {\n#pragma omp critical\n      {\n        if (size < cap)\n        {\n          size++; \n          printf(\"Produced! size=%d\\n\", size);\n          fflush(stdout);\n        }\n      }\n      for (int i = 0; i < 1000; i++)\n        r = (r + 1) % 10;\n    }\n#pragma omp section\n    while (1)\n    {\n#pragma omp critical\n      {\n        if (size > 0)\n        {\n          size--; \n          printf(\"Consumed! size=%d\\n\", size);\n          fflush(stdout);\n        }\n      }\n      for (int i = 0; i < 1000; i++)\n        r = (r + 1) % 10;\n    }\n  }\n}\n",
        "code_len": 725,
        "data_race_label": "N2, N3",
        "var_pairs": []
    },
    {
        "ID": "191",
        "name": "DRB191-critical-section2-yes.c",
        "DRB_code": "/*\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n!!! Copyright (c) 2017-20, Lawrence Livermore National Security, LLC\n!!! and DataRaceBench project contributors. See the DataRaceBench/COPYRIGHT file for details.\n!!!\n!!! SPDX-License-Identifier: (BSD-3-Clause)\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n */\n\n/*\n * This is a program based on a dataset contributed by\n * Wenhao Wu and Stephen F. Siegel @Univ. of Delaware.\n\n * Race due to different critical section names\n * Data race pair: size@34:11:W vs. size@49:11:W\n */\n\n#include <stdio.h>\n\nint cap = 10, size = 0;\nunsigned r = 0;\n\nint main()\n{\n#pragma omp parallel sections shared(size, cap) firstprivate(r) num_threads(2)\n  {\n#pragma omp section\n    while (1)\n    {\n#pragma omp critical(A)\n      {\n        if (size < cap)\n        {\n          size++; // produce\n          printf(\"Produced! size=%d\\n\", size);\n          fflush(stdout);\n        }\n      }\n      for (int i = 0; i < 1000; i++)\n        r = (r + 1) % 10;\n    }\n#pragma omp section\n    while (1)\n    {\n#pragma omp critical(B)\n      {\n        if (size > 0)\n        {\n          size--; // consume\n          printf(\"Consumed! size=%d\\n\", size);\n          fflush(stdout);\n        }\n      }\n      for (int i = 0; i < 1000; i++)\n        r = (r + 1) % 10;\n    }\n  }\n}\n",
        "data_race": 1,
        "trimmed_code": "#include <stdio.h>\n\nint cap = 10, size = 0;\nunsigned r = 0;\n\nint main()\n{\n#pragma omp parallel sections shared(size, cap) firstprivate(r) num_threads(2)\n  {\n#pragma omp section\n    while (1)\n    {\n#pragma omp critical(A)\n      {\n        if (size < cap)\n        {\n          size++; \n          printf(\"Produced! size=%d\\n\", size);\n          fflush(stdout);\n        }\n      }\n      for (int i = 0; i < 1000; i++)\n        r = (r + 1) % 10;\n    }\n#pragma omp section\n    while (1)\n    {\n#pragma omp critical(B)\n      {\n        if (size > 0)\n        {\n          size--; \n          printf(\"Consumed! size=%d\\n\", size);\n          fflush(stdout);\n        }\n      }\n      for (int i = 0; i < 1000; i++)\n        r = (r + 1) % 10;\n    }\n  }\n}\n",
        "code_len": 731,
        "data_race_label": "Y3",
        "var_pairs": [
            "{\"name\": [\"size\", \"size\"],\n\"line\": [34, 49],\n\"col\": [11, 11],\n\"operation\": [\"W\", \"W\"]}"
        ]
    },
    {
        "ID": "192",
        "name": "DRB192-critical-section3-no.c",
        "DRB_code": "/*\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n!!! Copyright (c) 2017-20, Lawrence Livermore National Security, LLC\n!!! and DataRaceBench project contributors. See the DataRaceBench/COPYRIGHT file for details.\n!!!\n!!! SPDX-License-Identifier: (BSD-3-Clause)\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n */\n\n/*\n * This is a program based on a dataset contributed by \n * Wenhao Wu and Stephen F. Siegel @Univ. of Delaware.\n \n * signal with busy wait loop using critical sections\n */\n\n#include <stdio.h>\nint main()\n{\n  int x = 0, s = 0;\n#pragma omp parallel sections shared(x, s) num_threads(2)\n  {\n#pragma omp section\n    {\n      x = 1;\n#pragma omp critical\n      {\n        s = 1;\n      }\n    }\n#pragma omp section\n    {\n      int done = 0;\n      while (!done)\n      {\n#pragma omp critical\n        {\n          if (s)\n            done = 1;\n        }\n      }\n      x = 2;\n    }\n  }\n  printf(\"%d\\n\", x);\n}\n",
        "data_race": 0,
        "trimmed_code": "#include <stdio.h>\nint main()\n{\n  int x = 0, s = 0;\n#pragma omp parallel sections shared(x, s) num_threads(2)\n  {\n#pragma omp section\n    {\n      x = 1;\n#pragma omp critical\n      {\n        s = 1;\n      }\n    }\n#pragma omp section\n    {\n      int done = 0;\n      while (!done)\n      {\n#pragma omp critical\n        {\n          if (s)\n            done = 1;\n        }\n      }\n      x = 2;\n    }\n  }\n  printf(\"%d\\n\", x);\n}\n",
        "code_len": 419,
        "data_race_label": "N2, N3",
        "var_pairs": []
    },
    {
        "ID": "193",
        "name": "DRB193-critical-section3-yes.c",
        "DRB_code": "/*\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n!!! Copyright (c) 2017-20, Lawrence Livermore National Security, LLC\n!!! and DataRaceBench project contributors. See the DataRaceBench/COPYRIGHT file for details.\n!!!\n!!! SPDX-License-Identifier: (BSD-3-Clause)\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n */\n\n/*\n * This is a program based on a dataset contributed by\n * Wenhao Wu and Stephen F. Siegel @Univ. of Delaware.\n\n * Race due to different critical section names\n * Data race pair: x@26:7:W vs. x@43:7:W\n */\n\n#include <stdio.h>\nint main()\n{\n  int x = 0, s = 0;\n#pragma omp parallel sections shared(x, s) num_threads(2)\n  {\n#pragma omp section\n    {\n      x = 1;\n#pragma omp critical(A)\n      {\n        s = 1;\n      }\n    }\n#pragma omp section\n    {\n      int done = 0;\n      while (!done)\n      {\n#pragma omp critical(B)\n        {\n          if (s)\n            done = 1;\n        }\n      }\n      x = 2;\n    }\n  }\n  printf(\"%d\\n\", x);\n}\n",
        "data_race": 1,
        "trimmed_code": "#include <stdio.h>\nint main()\n{\n  int x = 0, s = 0;\n#pragma omp parallel sections shared(x, s) num_threads(2)\n  {\n#pragma omp section\n    {\n      x = 1;\n#pragma omp critical(A)\n      {\n        s = 1;\n      }\n    }\n#pragma omp section\n    {\n      int done = 0;\n      while (!done)\n      {\n#pragma omp critical(B)\n        {\n          if (s)\n            done = 1;\n        }\n      }\n      x = 2;\n    }\n  }\n  printf(\"%d\\n\", x);\n}\n",
        "code_len": 425,
        "data_race_label": "Y3",
        "var_pairs": [
            "{\"name\": [\"x\", \"x\"],\n\"line\": [26, 43],\n\"col\": [7, 7],\n\"operation\": [\"W\", \"W\"]}"
        ]
    },
    {
        "ID": "194",
        "name": "DRB194-diffusion1-no.c",
        "DRB_code": "/*\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n!!! Copyright (c) 2017-20, Lawrence Livermore National Security, LLC\n!!! and DataRaceBench project contributors. See the DataRaceBench/COPYRIGHT file for details.\n!!!\n!!! SPDX-License-Identifier: (BSD-3-Clause)\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n */\n\n/*\n * This is a program based on a dataset contributed by\n * Wenhao Wu and Stephen F. Siegel @Univ. of Delaware.\n\n * no race, but it needs to mention that u1 and u2 are not aliased\n */\n\n#include <stdlib.h>\n#include <stdio.h>\n\ndouble *u1, *u2, c = 0.2;\nint n = 10, nsteps = 10;\n\nint main()\n{\n  u1 = malloc(n * sizeof(double));\n  u2 = malloc(n * sizeof(double));\n  for (int i = 1; i < n - 1; i++)\n    u2[i] = u1[i] = 1.0 * rand() / RAND_MAX;\n  u1[0] = u1[n - 1] = u2[0] = u2[n - 1] = 0.5;\n  for (int t = 0; t < nsteps; t++)\n  {\n#pragma omp parallel for\n    for (int i = 1; i < n - 1; i++)\n    {\n      u2[i] = u1[i] + c * (u1[i - 1] + u1[i + 1] - 2 * u1[i]);\n    }\n    double *tmp = u1;\n    u1 = u2;\n    u2 = tmp;\n  }\n  for (int i = 0; i < n; i++)\n    printf(\"%1.2lf \", u1[i]);\n  printf(\"\\n\");\n  free(u1);\n  free(u2);\n}\n",
        "data_race": 0,
        "trimmed_code": "#include <stdlib.h>\n#include <stdio.h>\n\ndouble *u1, *u2, c = 0.2;\nint n = 10, nsteps = 10;\n\nint main()\n{\n  u1 = malloc(n * sizeof(double));\n  u2 = malloc(n * sizeof(double));\n  for (int i = 1; i < n - 1; i++)\n    u2[i] = u1[i] = 1.0 * rand() / RAND_MAX;\n  u1[0] = u1[n - 1] = u2[0] = u2[n - 1] = 0.5;\n  for (int t = 0; t < nsteps; t++)\n  {\n#pragma omp parallel for\n    for (int i = 1; i < n - 1; i++)\n    {\n      u2[i] = u1[i] + c * (u1[i - 1] + u1[i + 1] - 2 * u1[i]);\n    }\n    double *tmp = u1;\n    u1 = u2;\n    u2 = tmp;\n  }\n  for (int i = 0; i < n; i++)\n    printf(\"%1.2lf \", u1[i]);\n  printf(\"\\n\");\n  free(u1);\n  free(u2);\n}\n",
        "code_len": 631,
        "data_race_label": "N1",
        "var_pairs": []
    },
    {
        "ID": "195",
        "name": "DRB195-diffusion1-yes.c",
        "DRB_code": "/*\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n!!! Copyright (c) 2017-20, Lawrence Livermore National Security, LLC\n!!! and DataRaceBench project contributors. See the DataRaceBench/COPYRIGHT file for details.\n!!!\n!!! SPDX-License-Identifier: (BSD-3-Clause)\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n */\n\n/*\n * This is a program based on a dataset contributed by\n * Wenhao Wu and Stephen F. Siegel @Univ. of Delaware.\n\n * Race due to u1 and u2 are aliased.\n * Data race pairs: u2[i]@39:7:W vs. u1[i]@39:15:R\n *                  u2[i]@39:7:W vs. u1[i - 1]@39:28:R\n *                  u2[i]@39:7:W vs. u1[i + 1]@39:40:R\n *                  u2[i]@39:7:W vs. u1[i]@39:56:R\n */\n\n#include <stdlib.h>\n#include <stdio.h>\n\ndouble *u1, *u2, c = 0.2;\nint n = 10, nsteps = 10;\n\nint main()\n{\n  u1 = malloc(n * sizeof(double));\n  u2 = malloc(n * sizeof(double));\n  for (int i = 1; i < n - 1; i++)\n    u2[i] = u1[i] = 1.0 * rand() / RAND_MAX;\n  u1[0] = u1[n - 1] = u2[0] = u2[n - 1] = 0.5;\n  for (int t = 0; t < nsteps; t++)\n  {\n#pragma omp parallel for\n    for (int i = 1; i < n - 1; i++)\n    {\n      u2[i] = u1[i] + c * (u1[i - 1] + u1[i + 1] - 2 * u1[i]);\n    }\n    double *tmp = u1;\n    u1 = u2; // u2 = tmp;\n  }\n  for (int i = 0; i < n; i++)\n    printf(\"%1.2lf \", u1[i]);\n  printf(\"\\n\");\n  free(u1);\n  free(u2);\n}\n",
        "data_race": 1,
        "trimmed_code": "#include <stdlib.h>\n#include <stdio.h>\n\ndouble *u1, *u2, c = 0.2;\nint n = 10, nsteps = 10;\n\nint main()\n{\n  u1 = malloc(n * sizeof(double));\n  u2 = malloc(n * sizeof(double));\n  for (int i = 1; i < n - 1; i++)\n    u2[i] = u1[i] = 1.0 * rand() / RAND_MAX;\n  u1[0] = u1[n - 1] = u2[0] = u2[n - 1] = 0.5;\n  for (int t = 0; t < nsteps; t++)\n  {\n#pragma omp parallel for\n    for (int i = 1; i < n - 1; i++)\n    {\n      u2[i] = u1[i] + c * (u1[i - 1] + u1[i + 1] - 2 * u1[i]);\n    }\n    double *tmp = u1;\n    u1 = u2; \n  }\n  for (int i = 0; i < n; i++)\n    printf(\"%1.2lf \", u1[i]);\n  printf(\"\\n\");\n  free(u1);\n  free(u2);\n}\n",
        "code_len": 618,
        "data_race_label": "Y3",
        "var_pairs": [
            "{\"name\": [\"u2[i]\", \"u1[i]\"],\n\"line\": [39, 39],\n\"col\": [7, 15],\n\"operation\": [\"W\", \"R\"]}"
        ]
    },
    {
        "ID": "196",
        "name": "DRB196-diffusion2-no.c",
        "DRB_code": "/*\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n!!! Copyright (c) 2017-20, Lawrence Livermore National Security, LLC\n!!! and DataRaceBench project contributors. See the DataRaceBench/COPYRIGHT file for details.\n!!!\n!!! SPDX-License-Identifier: (BSD-3-Clause)\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n */\n\n/*\n * This is a program based on a dataset contributed by\n * Wenhao Wu and Stephen F. Siegel @Univ. of Delaware.\n\n * No race. The array b is divided into two non-overlapping halves that are referenced by u[0] and u[1].\n */\n\n#include <stdlib.h>\n#include <stdio.h>\n\ndouble c = 0.2;\nint n = 20, nsteps = 100;\n\nint main()\n{\n  double *b = malloc(2 * n * sizeof(double));\n  double *u[2] = {&b[0], &b[n]};\n  for (int i = 1; i < n - 1; i++)\n    u[0][i] = u[1][i] = 1.0 * rand() / RAND_MAX;\n  u[0][0] = u[0][n - 1] = u[1][0] = u[1][n - 1] = 0.5;\n  int p = 0;\n  for (int t = 0; t < nsteps; t++)\n  {\n#pragma omp parallel for\n    for (int i = 1; i < n - 1; i++)\n    {\n      u[1 - p][i] = u[p][i] + c * (u[p][i - 1] + u[p][i + 1] - 2 * u[p][i]);\n    }\n    p = 1 - p;\n  }\n  for (int i = 0; i < n; i++)\n    printf(\"%1.2lf \", u[p][i]);\n  printf(\"\\n\");\n  free(b);\n}\n",
        "data_race": 0,
        "trimmed_code": "#include <stdlib.h>\n#include <stdio.h>\n\ndouble c = 0.2;\nint n = 20, nsteps = 100;\n\nint main()\n{\n  double *b = malloc(2 * n * sizeof(double));\n  double *u[2] = {&b[0], &b[n]};\n  for (int i = 1; i < n - 1; i++)\n    u[0][i] = u[1][i] = 1.0 * rand() / RAND_MAX;\n  u[0][0] = u[0][n - 1] = u[1][0] = u[1][n - 1] = 0.5;\n  int p = 0;\n  for (int t = 0; t < nsteps; t++)\n  {\n#pragma omp parallel for\n    for (int i = 1; i < n - 1; i++)\n    {\n      u[1 - p][i] = u[p][i] + c * (u[p][i - 1] + u[p][i + 1] - 2 * u[p][i]);\n    }\n    p = 1 - p;\n  }\n  for (int i = 0; i < n; i++)\n    printf(\"%1.2lf \", u[p][i]);\n  printf(\"\\n\");\n  free(b);\n}\n",
        "code_len": 625,
        "data_race_label": "N1",
        "var_pairs": []
    },
    {
        "ID": "197",
        "name": "DRB197-diffusion2-yes.c",
        "DRB_code": "/*\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n!!! Copyright (c) 2017-20, Lawrence Livermore National Security, LLC\n!!! and DataRaceBench project contributors. See the DataRaceBench/COPYRIGHT file for details.\n!!!\n!!! SPDX-License-Identifier: (BSD-3-Clause)\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n */\n\n/*\n * This is a program based on a dataset contributed by\n * Wenhao Wu and Stephen F. Siegel @Univ. of Delaware.\n\n * Overlap of the two ranges u[0] and u[1] when u[1][i] is accessed.\n * Data race pairs: u[1 - p][i]@38:7:W vs. u[p][i - 1]@38:15:R\n *                  u[1 - p][i]@38:7:W vs. u[p][i + 1]@38:50:R\n */\n\n#include <stdlib.h>\n#include <stdio.h>\n\ndouble c = 0.2;\nint n = 20, nsteps = 100;\n\nint main()\n{\n  double *b = malloc(2 * n * sizeof(double));\n  double *u[2] = {&b[0], &b[n - 2]}; // oops, should be b[n]\n  for (int i = 1; i < n - 1; i++)\n    u[0][i] = u[1][i] = 1.0 * rand() / RAND_MAX;\n  u[0][0] = u[0][n - 1] = u[1][0] = u[1][n - 1] = 0.5;\n  int p = 0;\n  for (int t = 0; t < nsteps; t++)\n  {\n#pragma omp parallel for\n    for (int i = 1; i < n - 1; i++)\n    {\n      u[1 - p][i] = u[p][i] + c * (u[p][i - 1] + u[p][i + 1] - 2 * u[p][i]);\n    }\n    p = 1 - p;\n  }\n  for (int i = 0; i < n; i++)\n    printf(\"%1.2lf \", u[p][i]);\n  printf(\"\\n\");\n  free(b);\n}",
        "data_race": 1,
        "trimmed_code": "#include <stdlib.h>\n#include <stdio.h>\n\ndouble c = 0.2;\nint n = 20, nsteps = 100;\n\nint main()\n{\n  double *b = malloc(2 * n * sizeof(double));\n  double *u[2] = {&b[0], &b[n - 2]}; \n  for (int i = 1; i < n - 1; i++)\n    u[0][i] = u[1][i] = 1.0 * rand() / RAND_MAX;\n  u[0][0] = u[0][n - 1] = u[1][0] = u[1][n - 1] = 0.5;\n  int p = 0;\n  for (int t = 0; t < nsteps; t++)\n  {\n#pragma omp parallel for\n    for (int i = 1; i < n - 1; i++)\n    {\n      u[1 - p][i] = u[p][i] + c * (u[p][i - 1] + u[p][i + 1] - 2 * u[p][i]);\n    }\n    p = 1 - p;\n  }\n  for (int i = 0; i < n; i++)\n    printf(\"%1.2lf \", u[p][i]);\n  printf(\"\\n\");\n  free(b);\n}",
        "code_len": 629,
        "data_race_label": "Y2",
        "var_pairs": [
            "{\"name\": [\"u[1 - p][i]\", \"u[p][i - 1]\"],\n\"line\": [38, 38],\n\"col\": [7, 15],\n\"operation\": [\"W\", \"R\"]}"
        ]
    },
    {
        "ID": "199",
        "name": "DRB199-prodcons-yes.c",
        "DRB_code": "/*\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n!!! Copyright (c) 2017-20, Lawrence Livermore National Security, LLC\n!!! and DataRaceBench project contributors. See the DataRaceBench/COPYRIGHT file for details.\n!!!\n!!! SPDX-License-Identifier: (BSD-3-Clause)\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n */\n\n/*\n * This is a program based on a dataset contributed by\n * Wenhao Wu and Stephen F. Siegel @Univ. of Delaware.\n\n * race introduced because critical sections have different names for producer and consumer.\n * Data race pair: size@34:11:W vs. size@45:11:W\n */\n\n#include <stdio.h>\n#include <stdio.h>\nint nprod = 4, ncons = 4;\nint cap = 5, size = 0;\nint main()\n{\n  int nthread = nprod + ncons;\n#pragma omp parallel for shared(size, cap, nprod, ncons, nthread) num_threads(nthread)\n  for (int i = 0; i < nthread; i++)\n  {\n    if (i < nprod)\n      while (1)\n      { // I am a producer\n#pragma omp critical(A)\n        if (size < cap)\n        {\n          size++; // produce\n          printf(\"Producer %d produced! size=%d\\n\", i, size);\n          fflush(stdout);\n        }\n      }\n    else\n      while (1)\n      { // I am a consumer\n#pragma omp critical(B)\n        if (size > 0)\n        {\n          size--; // consume\n          printf(\"Consumer %d consumed! size=%d\\n\", i - nprod, size);\n          fflush(stdout);\n        }\n      }\n  }\n}",
        "data_race": 1,
        "trimmed_code": "#include <stdio.h>\n#include <stdio.h>\nint nprod = 4, ncons = 4;\nint cap = 5, size = 0;\nint main()\n{\n  int nthread = nprod + ncons;\n#pragma omp parallel for shared(size, cap, nprod, ncons, nthread) num_threads(nthread)\n  for (int i = 0; i < nthread; i++)\n  {\n    if (i < nprod)\n      while (1)\n      { \n#pragma omp critical(A)\n        if (size < cap)\n        {\n          size++; \n          printf(\"Producer %d produced! size=%d\\n\", i, size);\n          fflush(stdout);\n        }\n      }\n    else\n      while (1)\n      { \n#pragma omp critical(B)\n        if (size > 0)\n        {\n          size--; \n          printf(\"Consumer %d consumed! size=%d\\n\", i - nprod, size);\n          fflush(stdout);\n        }\n      }\n  }\n}",
        "code_len": 713,
        "data_race_label": "Y3",
        "var_pairs": [
            "{\"name\": [\"size\", \"size\"],\n\"line\": [34, 45],\n\"col\": [11, 11],\n\"operation\": [\"W\", \"W\"]}"
        ]
    },
    {
        "ID": "200",
        "name": "DRB200-sync1-no.c",
        "DRB_code": "/*\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n!!! Copyright (c) 2017-20, Lawrence Livermore National Security, LLC\n!!! and DataRaceBench project contributors. See the DataRaceBench/COPYRIGHT file for details.\n!!!\n!!! SPDX-License-Identifier: (BSD-3-Clause)\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n */\n\n/*\n * This is a program based on a dataset contributed by\n * Wenhao Wu and Stephen F. Siegel @Univ. of Delaware.\n\n * Two threads sync using one lock. No race.\n */\n\n#include <stdio.h>\n#include <omp.h>\n#include <assert.h>\n\nomp_lock_t l;\nint x = 1;\n\nint main()\n{\n  omp_init_lock(&l);\n#pragma omp parallel num_threads(2)\n  {\n    int tid = omp_get_thread_num();\n    if (tid == 0)\n      omp_set_lock(&l);\n#pragma omp barrier\n    if (tid == 0)\n    {\n      x = 0;\n      omp_unset_lock(&l);\n    }\n    else if (tid == 1)\n    {\n      omp_set_lock(&l);\n      omp_unset_lock(&l);\n      x = 1;\n    }\n#pragma omp barrier\n  } // end of parallel construct\n  omp_destroy_lock(&l);\n  printf(\"Done: x=%d\\n\", x);\n}",
        "data_race": 0,
        "trimmed_code": "#include <stdio.h>\n#include <omp.h>\n#include <assert.h>\n\nomp_lock_t l;\nint x = 1;\n\nint main()\n{\n  omp_init_lock(&l);\n#pragma omp parallel num_threads(2)\n  {\n    int tid = omp_get_thread_num();\n    if (tid == 0)\n      omp_set_lock(&l);\n#pragma omp barrier\n    if (tid == 0)\n    {\n      x = 0;\n      omp_unset_lock(&l);\n    }\n    else if (tid == 1)\n    {\n      omp_set_lock(&l);\n      omp_unset_lock(&l);\n      x = 1;\n    }\n#pragma omp barrier\n  } \n  omp_destroy_lock(&l);\n  printf(\"Done: x=%d\\n\", x);\n}",
        "code_len": 501,
        "data_race_label": "N3",
        "var_pairs": []
    },
    {
        "ID": "201",
        "name": "DRB201-sync1-yes.c",
        "DRB_code": "/*\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n!!! Copyright (c) 2017-20, Lawrence Livermore National Security, LLC\n!!! and DataRaceBench project contributors. See the DataRaceBench/COPYRIGHT file for details.\n!!!\n!!! SPDX-License-Identifier: (BSD-3-Clause)\n!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!\n */\n\n/*\n * This is a program based on a dataset contributed by\n * Wenhao Wu and Stephen F. Siegel @Univ. of Delaware.\n\n * Thread with id 1 acquires and releases the lock, but then it modifies x without holding it.\n * Data race pair: size@35:7:W vs. size@42:7:W\n */\n\n#include <stdio.h>\n#include <omp.h>\n#include <assert.h>\n\nomp_lock_t l;\nint x = 1;\n\nint main()\n{\n  omp_init_lock(&l);\n#pragma omp parallel num_threads(2)\n  {\n    int tid = omp_get_thread_num();\n#pragma omp barrier\n    if (tid == 0)\n    {\n      omp_set_lock(&l);\n      x = 0;\n      omp_unset_lock(&l);\n    }\n    else if (tid == 1)\n    {\n      omp_set_lock(&l);\n      omp_unset_lock(&l);\n      x = 1;\n    }\n#pragma omp barrier\n  } // end of parallel construct\n  omp_destroy_lock(&l);\n  printf(\"Done: x=%d\\n\", x);\n}",
        "data_race": 1,
        "trimmed_code": "#include <stdio.h>\n#include <omp.h>\n#include <assert.h>\n\nomp_lock_t l;\nint x = 1;\n\nint main()\n{\n  omp_init_lock(&l);\n#pragma omp parallel num_threads(2)\n  {\n    int tid = omp_get_thread_num();\n#pragma omp barrier\n    if (tid == 0)\n    {\n      omp_set_lock(&l);\n      x = 0;\n      omp_unset_lock(&l);\n    }\n    else if (tid == 1)\n    {\n      omp_set_lock(&l);\n      omp_unset_lock(&l);\n      x = 1;\n    }\n#pragma omp barrier\n  } \n  omp_destroy_lock(&l);\n  printf(\"Done: x=%d\\n\", x);\n}",
        "code_len": 483,
        "data_race_label": "Y3",
        "var_pairs": [
            "{\"name\": [\"size\", \"size\"],\n\"line\": [35, 42],\n\"col\": [7, 7],\n\"operation\": [\"W\", \"W\"]}"
        ]
    }
]